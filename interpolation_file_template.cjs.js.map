{"version":3,"file":"interpolation_file_template.cjs.js","sources":["../src/interpolation_objects.js","../src/interpolation_file_template.js"],"sourcesContent":["import {ExpressionParser} from \"./expression_parser.js\"\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst REGX = Object.freeze({\r\n    FUNCTION_TAG: '^\\\\s*->\\\\s*(.*)',\r\n    CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY: '^(<-\\\\s*false\\\\s*)|(<--\\\\s*false\\\\s*)$',\r\n    CMD_KEY_COPY_INTO_OBJ: '^(<-\\\\s*true\\\\s*)|(<-\\\\s*)$',\r\n    CMD_KEY_COPY_INTO_PARENT_OBJ: '^(<--\\\\s*true\\\\s*)|(<--\\\\s*)$',\r\n\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// Exceptions\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass InterpolationValueNotFoundError extends Error { constructor(){ super(\"Interpolation value not Found\"); } }\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Base class for a generic parser like an Abstract Syntax Tree or any simple parser requiring simple character scanning\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass BaseAST {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static isWhitespace(char) { return /\\s/.test(char); }\r\n    static isOpen(char) { return char === '('; }\r\n    static isClose(char) { return char === ')'; }\r\n    static isCurlyOpen(char) { return char === '{'; }\r\n    static isCurlyClose(char) { return char === '}'; }\r\n    static isArgSeparate(char) { return char === ','; }\r\n    static isSquareOpen(char) { return char === '['; }\r\n    static isSquareClose(char) { return char === ']'; }\r\n    static isGroupTokenBegin(char) { return (char === \"'\") || (char === '\"') || (char === '[') || (char === '{'); }\r\n    static isMatchingGroupTokenEnd(beginChar, char) {\r\n        if(beginChar === \"'\")\r\n            return char === \"'\";\r\n        else if(beginChar === '\"')\r\n            return char === '\"';\r\n        else if(beginChar === '[')\r\n            return char === ']';\r\n        else if(beginChar === '{')\r\n            return char === '}';\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression) {\r\n        this._expression = expression;\r\n        this._index = 0;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyParseStart() { this._index = 0; }\r\n    notifyParseComplete(parseResult) {}\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Basic character functions - non consuming\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getI() { return this._index; }\r\n    getExpr() { return this._expression; }\r\n    cAtI(n = 0) { return this.getExpr()[this._index + n]; }\r\n    cAtIIsWhite() { return BaseAST.isWhitespace(this.cAtI()); }\r\n    skip(n=1) { return this._index += n; }\r\n    hasChars(nChars = 1) { return (this.getExpr().length - this._index) >= nChars; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Useful character functions for specific cases\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisCurlyOpen() { return BaseAST.isCurlyOpen(this.cAtI()); }\r\n    cAtIisCurlyClose() { return BaseAST.isCurlyClose(this.cAtI()); }\r\n    cAtIOIsOpen() { return BaseAST.isOpen(this.cAtI()); }\r\n    cAtIOIsClose() { return BaseAST.isClose(this.cAtI()); }\r\n    cAtIIsArgSeporator() { return BaseAST.isArgSeparate(this.cAtI())}\r\n    cAtIIsGroupTokenEnd(beginChar) { return BaseAST.isMatchingGroupTokenEnd(beginChar, this.cAtI()); }\r\n    cAtIIsTag(tag) {\r\n        let hasTag = false;\r\n        const tagLen = tag.length;\r\n        if(this.hasChars(tagLen)) {\r\n            let nFoundSymbols = 0;\r\n            for(let i = 0; i < tag.length; i++) {\r\n                if(this.cAtI(i) === tag[i])\r\n                    nFoundSymbols++;\r\n            }\r\n            hasTag = (nFoundSymbols === tagLen)\r\n        }\r\n        return hasTag;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Consuming\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipWhitespace() {\r\n        while (this.hasChars() && this.cAtIIsWhite())\r\n            this.skip();\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass TagParser extends BaseAST {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options = {}) {\r\n        super(expression);\r\n\r\n        this._options = options;\r\n        this._startTag = \"{{\";\r\n        this._endTag = \"}}\"\r\n        this._ignoreEnclosed = { Opens: [\"{\"], Closes: [\"}\"] }\r\n        this._curlyBracketStack = [];\r\n        this._replacementEdits = []\r\n        this._options.TrackCurlyBrackets = this._options.TrackCurlyBrackets !== undefined ?\r\n            this._options.TrackCurlyBrackets : false;\r\n    }\r\n    getTrackCurlyBrackets() { return this._options.TrackCurlyBrackets; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    createTemplateKey(key) { return `${this._startTag}${key}${this._endTag}`; }\r\n    cAtIIsBeginTag() { return this.cAtIIsTag(this._startTag); }\r\n    cAtIIsEndTag() {\r\n        let isTag = false;\r\n        if(this._curlyBracketStack.length === 0)\r\n            isTag = this.cAtIIsTag(this._endTag);\r\n        return isTag;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisOpen() {\r\n        let closing = undefined;\r\n        const indexOfOpen = this._ignoreEnclosed.Opens.indexOf(this.cAtI());\r\n        if(indexOfOpen !== -1)\r\n            closing = this._ignoreEnclosed.Closes[indexOfOpen];\r\n\r\n\r\n        return closing;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisClosing() {\r\n        let matchedClosing = false;\r\n        if(this._curlyBracketStack.length > 0) {\r\n            const lastClosing = this._curlyBracketStack[this._curlyBracketStack.length - 1];\r\n            if(this.cAtI() === lastClosing)\r\n                matchedClosing = true;\r\n        }\r\n        return matchedClosing;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    trackEnclosedChars() {\r\n        // In the cases where we have not identified a start or end token, track curly brackets.\r\n        if(this.getTrackCurlyBrackets()) {\r\n            const closingChar = this.cAtIisOpen();\r\n            if (closingChar !== undefined)\r\n                this._curlyBracketStack.push(closingChar);\r\n            else if (this.cAtIisClosing()) {\r\n                this._curlyBracketStack.pop();\r\n            }\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseToken() {\r\n        // {{A  {{B}} }}\r\n        let token = undefined;\r\n        let start = -1; let end = -1;\r\n        let iStartToken = -1; let iEndToken = -1;\r\n        while (this.hasChars()) {\r\n            if (this.cAtIIsBeginTag()) {\r\n                iStartToken = this.getI();\r\n                this.skip(this._startTag.length);\r\n                start = this.getI();\r\n            }\r\n            else if ((start !== -1) && this.cAtIIsEndTag()) {\r\n                end = this.getI();\r\n                iEndToken = end +  this._endTag.length;\r\n\r\n                // slice out our token\r\n                token = this.getExpr().slice(start, end);\r\n\r\n                this.skip(this._endTag.length);\r\n                break;\r\n            }\r\n            else {\r\n                this.trackEnclosedChars();\r\n                this.skip();\r\n            }\r\n        }\r\n        return token !== undefined ? {\r\n            Match: this.createTemplateKey(token),\r\n            Key: token,\r\n            IStartToken: iStartToken,\r\n            IEndToken: iEndToken\r\n        } : undefined;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    applyReplacementEdits() {\r\n        return SinglePassTagReplacer.customStringReplacer(this.getExpr(), this._replacementEdits);\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass SimpleTagParser extends TagParser {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options = {}) {\r\n        super(expression, options);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    has() {\r\n        let found = false;\r\n        this.notifyParseStart();\r\n        let matchResultObj = this.parseToken();\r\n        this.notifyParseComplete(matchResultObj);\r\n        return matchResultObj !== undefined;\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass SinglePassTagReplacer extends TagParser {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static customStringReplacer(expression, replacementEdits) {\r\n        // Note: edits are already sorted from left to right\r\n\r\n        // Iterate over the replacementEdits\r\n        let result = '';\r\n        let lastIndex = 0;\r\n\r\n        for (let i = 0; i < replacementEdits.length; i++) {\r\n            const { ReplaceWith, IStartToken, IEndToken } = replacementEdits[i];\r\n\r\n            // Add the existing part of the string before the start token\r\n            result += expression.slice(lastIndex, IStartToken);\r\n\r\n            // Add the new string (key)\r\n            result += ReplaceWith;\r\n\r\n            // Update the lastIndex to be after the end token\r\n            lastIndex = IEndToken;\r\n        }\r\n\r\n        // Add any remaining part of the original string after the last change\r\n        result += expression.slice(lastIndex);\r\n\r\n        return result;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, cb, options = {}) {\r\n        super(expression, options);\r\n        this._cb = cb;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyParseResult(matchResultObj) {\r\n        const match = matchResultObj.Match;\r\n        const key = matchResultObj.Key;\r\n        const offset = matchResultObj.IStartToken;\r\n\r\n        matchResultObj.ReplaceWith = this._cb(this, match, key, offset, this.getExpr());\r\n        this._replacementEdits.push(matchResultObj);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    applyReplacementEdits() {\r\n        return SinglePassTagReplacer.customStringReplacer(this.getExpr(), this._replacementEdits);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    replace() {\r\n        this.notifyParseStart();\r\n        let matchResultObj = this.parseToken();\r\n        while(matchResultObj !== undefined) {\r\n            this.notifyParseResult(matchResultObj);\r\n            matchResultObj = this.parseToken();\r\n        }\r\n        if(this._curlyBracketStack.length > 0)\r\n            throw new Error(`Match Error - unbalanced symbols missing: ${this._curlyBracketStack.join(',')}`);\r\n        this.notifyParseComplete(matchResultObj);\r\n        return this.applyReplacementEdits();\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass PromisesHandler {\r\n    static isPromise(p) {\r\n        let result = false;\r\n        if ((p !== null) && (typeof p === 'object') && typeof p.then === 'function')\r\n            result = true;\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor() {\r\n        this._promises = [];\r\n        this._promiseKeys = [];\r\n        this._matchedOn = []\r\n\r\n        this._nextKeyId = 0;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    hasPromises() { return this._promises.length > 0; }\r\n    allSettled() { return Promise.allSettled(this._promises); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async processPromises() {\r\n        let replaceKeys = undefined;\r\n        if (this.hasPromises()) {\r\n            replaceKeys = {NResolved: 0, NRejected: 0};\r\n            const results = await this.allSettled();\r\n            for (let i = 0; i < results.length; i++) {\r\n                const promiseKey = this._promiseKeys[i];\r\n                const pResult = results[i];\r\n                if(pResult.status === 'fulfilled') {\r\n                    replaceKeys[promiseKey] = pResult.value;\r\n                    replaceKeys.NResolved++;\r\n                }\r\n                else if(pResult.status === 'rejected') {\r\n                    replaceKeys[promiseKey] = this._matchedOn[i];\r\n                    replaceKeys.NRejected++;\r\n                }\r\n            }\r\n        }\r\n        return replaceKeys;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getNextPromiseKey() {\r\n        const key  = `${this._nextKeyId}__@uniquePKey@__${this._nextKeyId}`;\r\n        this._nextKeyId++;\r\n        return key;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    add(matchedOn, pCandidate) {\r\n        let addedKey = undefined;\r\n        if(PromisesHandler.isPromise(pCandidate)) {\r\n            this._matchedOn.push(matchedOn);\r\n            this._promises.push(pCandidate);\r\n            addedKey = this.getNextPromiseKey();\r\n            this._promiseKeys.push(addedKey);\r\n        }\r\n        return addedKey;\r\n    }\r\n}\r\nconst defaultOptions = Object.freeze({\r\n    CovertValueToType: true,\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Context for key values allows lookup by simple key.  This is the Base Interface for getting a value based on a key\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass KeyValueContextI {\r\n    constructor(keyValues) {\r\n        this._keyValues = keyValues;\r\n    }\r\n    getKeyValues() { return this._keyValues; }\r\n    get(key) { return this._keyValues[key]; }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Context for key values allows lookup by a query string.\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass QueryObjKeyValueContextI extends KeyValueContextI {\r\n    constructor(keyValues, useSeparator = \".\") {\r\n        super(keyValues);\r\n        this._useSeparator = useSeparator;\r\n    }\r\n    get(q) {\r\n         function arr_deref(o, ref, i) {\r\n            const key = ref.slice(0, i ? -1 : ref.length);\r\n            return !ref ? o : (o[key]);\r\n        }\r\n        function dot_deref(o, ref) {\r\n            return !ref ? o : ref.split('[').reduce(arr_deref, o);\r\n        }\r\n        try {\r\n            return q.split(this._useSeparator).reduce(dot_deref, this.getKeyValues());\r\n        }\r\n        catch(err) { return undefined; }\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass StringInterpolator {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(templateStr, keyValuesI, options = {}) {\r\n        this._templateStr = templateStr;\r\n\r\n        this._keyValuesI = (keyValuesI instanceof KeyValueContextI) ?\r\n            keyValuesI : new KeyValueContextI(keyValuesI);\r\n\r\n        this._options = options;\r\n\r\n        this._options.CovertValueToType = this._options.CovertValueToType === undefined ?\r\n            defaultOptions.CovertValueToType : this._options.CovertValueToType;\r\n\r\n        this._options.ReplaceNotFoundHandler =\r\n            this._options.ReplaceNotFoundHandler !== undefined ? this._options.ReplaceNotFoundHandler : (templateVar, key) => { return templateVar };\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getOptionConvertType() { return this._options.CovertValueToType; }\r\n    getOptionReplaceNotFoundHandler() { return this._options.ReplaceNotFoundHandler; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getValueInMap(key) { return this._keyValuesI.get(key); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doReplaces(templateStr, options) {\r\n        let simpleReplace = undefined;\r\n        const promisesHandler = new PromisesHandler();\r\n\r\n        // Replace string with found key\r\n        let nReplaces = 0;\r\n        const replace = (new SinglePassTagReplacer(templateStr,\r\n            (sender, match, key, offset, string) => {\r\n\r\n                let replaceCandidate = options.getValueInMap(key.trim());\r\n                if((replaceCandidate === undefined) && options.canInvokeNotFoundHandler())\r\n                    replaceCandidate = this.getOptionReplaceNotFoundHandler()(match, key);\r\n\r\n                // If there are promises to resolve, replace the token with our promise key\r\n                const promiseKey = promisesHandler.add(match, replaceCandidate);\r\n                if(promiseKey !== undefined)\r\n                    replaceCandidate = sender.createTemplateKey(promiseKey);\r\n                else if(this.getOptionConvertType() && (match === string))\r\n                    simpleReplace = replaceCandidate;\r\n                else {\r\n                    if((replaceCandidate !== null) && (typeof replaceCandidate === 'object'))\r\n                        replaceCandidate = JSON.stringify(replaceCandidate)\r\n                }\r\n\r\n                return replaceCandidate;\r\n\r\n        }, this._options)).replace();\r\n        let resultingS = undefined;\r\n        const promiseReplaceKeys = await promisesHandler.processPromises();\r\n        if(promiseReplaceKeys !== undefined) {\r\n            resultingS = await this.doReplaces(replace, {\r\n                getValueInMap: (key) =>  promiseReplaceKeys[key],\r\n                canInvokeNotFoundHandler: () => false\r\n            });\r\n        }\r\n\r\n        resultingS = resultingS || (simpleReplace !== undefined ? simpleReplace : replace);\r\n        return resultingS;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async sInterpolate() {\r\n        let resultingS = this._templateStr;\r\n\r\n        if (typeof resultingS === 'string') {\r\n            resultingS = await this.doReplaces(resultingS, {\r\n                getValueInMap: (key) =>  this.getValueInMap(key),\r\n                canInvokeNotFoundHandler: () => true\r\n            });\r\n        }\r\n\r\n        return resultingS;\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst ReplaceObjectAction = Object.freeze({\r\n    ACTION_NONE: Symbol(\"ACTION_NONE\"),\r\n    ACTION_DELETE: Symbol(\"ACTION_DELETE\"),\r\n    ACTION_THROW: Symbol(\"ACTION_THROW\"),\r\n    isValidAction: function (action) {\r\n        let isValid = false;\r\n        if(action)\r\n            isValid = (action === ReplaceObjectAction.ACTION_NONE) ||\r\n                (action === ReplaceObjectAction.ACTION_DELETE) ||\r\n                (action === ReplaceObjectAction.ACTION_THROW);\r\n        return isValid;\r\n    }\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ActionI {\r\n    constructor() {\r\n        this._action = ReplaceObjectAction.ACTION_NONE;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getAction() { return this._action; }\r\n    setAction(newActionValue) {\r\n        let actionSet = false;\r\n        if(ReplaceObjectAction.isValidAction(newActionValue)) {\r\n            this._action = newActionValue;\r\n\r\n            actionSet = true;\r\n        }\r\n\r\n        return actionSet;\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst KeyCommands = Object.freeze({\r\n    KeyCmdNone: 0,\r\n    KeyCmdCopyIntoObject: 1,\r\n    KeyCmdCopyIntoParentObject: 2,\r\n    KeyCmdDelKey: 3,\r\n    KeyCmdQueueDelChildObjectIfEmpty: 4\r\n});\r\n\r\nclass ObjectInterpolatorBase  {\r\n    static isKeyCmd(key, cmd) { return key.search(new RegExp(cmd)) !== -1; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static containsTemplateVar(templateString) {\r\n        return (templateString && typeof templateString === 'string') ?\r\n            ((new SimpleTagParser(templateString)).has()) : false;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static dupWithoutVars(childObj) {\r\n        const obj = {...childObj};\r\n        for (const [key, value] of Object.entries(childObj)) {\r\n            // we should remove any variable which has a template variable\r\n            if (ObjectInterpolatorBase.containsTemplateVar(value))\r\n                delete obj[key];\r\n        }\r\n        return obj;\r\n    }\r\n    static mergeInto(target, source) {\r\n        if(Array.isArray(target) && Array.isArray((source))) {\r\n            target.splice(0, target.length, ...source);\r\n        }\r\n        else {\r\n            Object.assign(target, source);\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // {A:{a:1,b:2, c:{d:4}}\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static *iterateObjStrings(obj, keys = [], objs= []) {\r\n        let isRoot = false;\r\n        if(obj) {\r\n\r\n            // push the root object\r\n            if(objs.length === 0) { objs.push(obj); isRoot = true; }\r\n\r\n\r\n            const useKeys = Array.isArray(obj.__ProcessKeys__) ? obj.__ProcessKeys__ : Object.keys(obj);\r\n            for(let i = 0; i < useKeys.length; i++) {\r\n                const key = useKeys[i]; const value = obj[key];\r\n\r\n                if ((typeof value === 'object') && (value !== null)) {\r\n                    keys.push(key); objs.push(value);\r\n                    yield* ObjectInterpolatorBase.iterateObjStrings(value, keys, objs );\r\n                    keys.pop();  objs.pop();\r\n                }\r\n                else if (typeof value === 'string') {\r\n                    yield [obj, key, value.trim(), keys, objs];\r\n                    const regex = /^__DEBUG__\\d*$/;\r\n                    const isDebugPrint = !!key.match(regex);\r\n                    if (isDebugPrint) {\r\n                        console.log(obj[key]);\r\n                        delete obj[key];\r\n                    }\r\n                }\r\n            }\r\n\r\n            // pop the root object\r\n            if(isRoot) { objs.pop(); }\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static createPathDotNotation(keys, key) { return keys.length > 0 ? keys.join(\"¤\") + \"¤\" + key : key; }\r\n    static createObjectPath(pathDotNotation) { return pathDotNotation.split(\"¤\"); }\r\n    static dup(obj) { return JSON.parse(JSON.stringify(obj)); }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(obj, keyValues, options = {}) {\r\n        this._options = options;\r\n        this._options.CopyObj = this._options.CopyObj !== undefined ? this._options.CopyObj : false\r\n\r\n        this._obj = this.getCopyObj() ? ObjectInterpolatorBase.dup(obj) : obj;\r\n        this._keyValues = keyValues;\r\n\r\n        this._options.ActionOnNotFound = ReplaceObjectAction.isValidAction(this._options.ActionOnNotFound) ?\r\n            this._options.ActionOnNotFound : ReplaceObjectAction.ACTION_NONE;\r\n\r\n        this._options.KeyValueContextI = this._options.KeyValueContextI !== undefined ?\r\n            this._options.KeyValueContextI : KeyValueContextI;\r\n\r\n        this._nPass = 2;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getObj() { return this._obj; }\r\n    getOptions() { return this._options; }\r\n    getActionOnNotFound() { return this._options.ActionOnNotFound; }\r\n    getOptionKeyValueContextI() { return this._options.KeyValueContextI; }\r\n    getOptionKeyValueContextSeparator() { return this._options.KeyValueContextSeparator || \".\"; }\r\n    getCopyObj() { return this._options.CopyObj; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // There are two possible return values, either:\r\n    // 1. The not found template var, as in \"{{var}}\".\r\n    // 2. The value returned by the handler (as long as the return value is not an action to delete the key).\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI) {\r\n        let useValue = templateVar;\r\n        if(parentReplaceNotFoundHandler) {\r\n            // If the value returned by the handler is not an action, we can use the value the handler has sent us\r\n            const actionOrValue = parentReplaceNotFoundHandler(templateVar, key);\r\n            if(!setActionI(actionOrValue))\r\n                useValue = actionOrValue;\r\n        }\r\n        else\r\n            setActionI(this.getActionOnNotFound());\r\n\r\n        return useValue;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Keys can hold replacement parameters, which act as commands\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doInterpolateKey(replaceKeyValues, childObj, key, value){\r\n        let nReplacedKeys = 0;\r\n        let useValue = key;\r\n\r\n        for(let i = 0; i < this._nPass; i++) {\r\n            const stringInterpolator = new StringInterpolator(useValue, replaceKeyValues, {\r\n                TrackCurlyBrackets: true, ...this._options,\r\n                ReplaceNotFoundHandler:  (templateVar, key) => {\r\n                    // Return the value to be used as the replace parameter.  Note the caller may set the action,\r\n                    // which may result in this key being deleted on the object (see code below, where we test the\r\n                    // action against the delete value\r\n                    return this.notifyReplaceNotFound(replaceKeyValues, templateVar, key, null,\r\n                        (newActionValue) => undefined);\r\n                }\r\n            });\r\n\r\n            const nextReplace = await stringInterpolator.sInterpolate();\r\n            if (nextReplace !== useValue) {\r\n                nReplacedKeys++;\r\n                useValue = nextReplace;\r\n            } else\r\n                break;\r\n        }\r\n\r\n        return { nReplacedKeys: nReplacedKeys, key: useValue };\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doInterpolateObj(replaceKeyValues, childObj, key, value){\r\n        let nReplacedKeys = 0;\r\n        let useValue = value;\r\n        const parentReplaceNotFoundHandler = this._options.ReplaceNotFoundHandler;\r\n        for(let i = 0; i < this._nPass; i++) {\r\n\r\n            // 'action' interface for setting local variable 'action'.  This code is kind of confusing, but,\r\n            // there is a reason for the complexity.  When we call interpolation on the string, the\r\n            // 'StringInterpolator' object, may invoke our handler to inform us it is not able to find a key.\r\n            // There are essentially three possible actions:\r\n            //   1. Do nothing, that is keep the un-replaced templateVar (we do this by returning the templateVar)\r\n            //   2. Return something that we do want to use, a common use case is to return an empty string (for example).\r\n            //   3. Delete the key from the object.  For this action, the client may return a special value to indicate\r\n            //      that we should delete the key.  The problem is we process this return value inside the handler.\r\n            //      To make this work, we check the value in our handler and set the action, which will be used,\r\n            //      later when the handler returns.\r\n            const actionI = new ActionI();\r\n\r\n            const stringInterpolator = new StringInterpolator(useValue, replaceKeyValues, {\r\n                TrackCurlyBrackets: true, ...this._options,\r\n                ReplaceNotFoundHandler:  (templateVar, key) => {\r\n                    // Return the value to be used as the replace parameter.  Note the caller may set the action,\r\n                    // which may result in this key being deleted on the object (see code below, where we test the\r\n                    // action against the delete value\r\n                    return this.notifyReplaceNotFound(replaceKeyValues, templateVar, key, parentReplaceNotFoundHandler,\r\n                        (newActionValue) => actionI.setAction(newActionValue));\r\n                }\r\n            });\r\n\r\n            let replace = await stringInterpolator.sInterpolate();\r\n            if(actionI.getAction() === ReplaceObjectAction.ACTION_NONE) {\r\n                if (useValue!== replace) {\r\n                    childObj[key] = replace;\r\n                    nReplacedKeys++;\r\n                    useValue = replace;\r\n                } else\r\n                    break;\r\n            }\r\n            else if(actionI.getAction() === ReplaceObjectAction.ACTION_DELETE) {\r\n                delete childObj[key];\r\n                break;\r\n            }\r\n            else if(actionI.getAction() === ReplaceObjectAction.ACTION_THROW) {\r\n                throw new InterpolationValueNotFoundError();\r\n            }\r\n        }\r\n\r\n        return nReplacedKeys;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getCmdInKey(key) {\r\n        let cmd = KeyCommands.KeyCmdNone;\r\n        if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY))\r\n            cmd = KeyCommands.KeyCmdQueueDelChildObjectIfEmpty\r\n        else if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_COPY_INTO_OBJ))\r\n            cmd = KeyCommands.KeyCmdCopyIntoObject;\r\n        else if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_COPY_INTO_PARENT_OBJ))\r\n            cmd = KeyCommands.KeyCmdCopyIntoParentObject;\r\n\r\n        return cmd;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    processDeletes(queuedDeletes) {\r\n        queuedDeletes.forEach( (pathDotNotation) => {\r\n            const path = ObjectInterpolatorBase.createObjectPath(pathDotNotation);\r\n            let itObj = this._obj;\r\n            let ownerObj = null;\r\n            let parentKey = \"\";\r\n            let parentObj = null;\r\n            let childKey = \"\";\r\n            for(let i = 0; i < path.length; i++) {\r\n                if(i === path.length - 1) {\r\n                    parentKey = childKey;\r\n                    ownerObj = parentObj;\r\n                }\r\n                childKey = path[i];\r\n                parentObj = itObj;\r\n                itObj = itObj[childKey];\r\n\r\n            }\r\n            if(parentObj && typeof parentObj === 'object') {\r\n                if(childKey)\r\n                    delete parentObj[childKey];\r\n            }\r\n            if(ownerObj && typeof ownerObj === 'object') {\r\n                if(parentKey && Object.keys(ownerObj[parentKey]).length === 0) {\r\n                    if(Array.isArray(ownerObj))\r\n                        ownerObj.splice(parentKey, 1);\r\n                    else\r\n                        delete ownerObj[parentKey];\r\n                }\r\n\r\n            }\r\n\r\n        });\r\n    }\r\n    addFlattenPaths(flattenPaths, keys) {\r\n        let currentObj = this._obj;\r\n        let flattenObjs = [];\r\n        if(Array.isArray(currentObj))\r\n                flattenObjs.push(currentObj);\r\n        for(let i = 0; i < keys.length; i++) {\r\n            const key = keys[i];\r\n            currentObj = currentObj[key];\r\n            if(Array.isArray(currentObj))\r\n                flattenObjs.push(currentObj);\r\n            else\r\n                flattenObjs = [];\r\n\r\n        }\r\n        for(let i = flattenObjs.length - 1; i >= 0; i--) {\r\n            const flattenObj = flattenObjs[i];\r\n            if(!flattenPaths.has(flattenObj))\r\n                flattenPaths.add(flattenObj);\r\n        }\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // return the interface which knows how to index into our object\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    createKeyValueContextI(keyValues) { return new (this.getOptionKeyValueContextI())(keyValues, this.getOptionKeyValueContextSeparator()); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async interpolate() {\r\n        let nReplacedKeys = 0;\r\n\r\n        const queuedDeletes = [];\r\n        let flattenRoot = false;\r\n        const trackParentSetObjects = new Set();\r\n        const flattenPaths = new Set();\r\n        for (const [childObj, key, value, keys, objs] of ObjectInterpolatorBase.iterateObjStrings(this._obj)) {\r\n\r\n            // Imagine a nested object - where we may have parameters to replace and where the childObj has some keys\r\n            // which may be used as replacement parameters\r\n            const replaceKeyValues =\r\n                this.createKeyValueContextI({ ...this._keyValues, ...ObjectInterpolatorBase.dupWithoutVars(childObj) });\r\n\r\n            const keyReplaceResult = await this.doInterpolateKey(replaceKeyValues, childObj, key, value);\r\n            nReplacedKeys += keyReplaceResult.nReplacedKeys;\r\n            const cmd = this.getCmdInKey(keyReplaceResult.key);\r\n            if((cmd === KeyCommands.KeyCmdNone) ||\r\n                    (cmd === KeyCommands.KeyCmdCopyIntoObject) ||\r\n                    (cmd === KeyCommands.KeyCmdCopyIntoParentObject)) {\r\n\r\n                nReplacedKeys += await this.doInterpolateObj(replaceKeyValues, childObj, key, value);\r\n\r\n                if (cmd === KeyCommands.KeyCmdCopyIntoObject) {\r\n                    const objCandidate = childObj[key];\r\n                    if ((typeof objCandidate === 'object') && (objCandidate !== null)) {\r\n                        Object.assign(childObj, objCandidate);\r\n                        delete childObj[key];\r\n                    }\r\n                }\r\n                else if(cmd === KeyCommands.KeyCmdCopyIntoParentObject) {\r\n                    // The parent object and the parent key can be found by looking at the objs/keys\r\n                    // (which tracks all iterated objects)\r\n                    const parentObj = objs.length > 1 ? objs[objs.length - 2] : null;\r\n                    const parentKey = keys.length > 0 ? keys[keys.length - 1] : \"\";\r\n\r\n                    if(parentObj && parentKey) {\r\n                        let wasSetOn = false;\r\n                        const objCandidate = childObj[key];\r\n                        if ((typeof objCandidate === 'object') && (objCandidate !== null)) {\r\n\r\n                            // Consider the case where we want to load multiple objects to the same element position on\r\n                            // the parent.  (reference Test case **).  This case is when the parentObj is an array\r\n                            const wasPreviouslySetOn = trackParentSetObjects.has(parentObj[parentKey]);\r\n                            if(wasPreviouslySetOn && Array.isArray(objCandidate))\r\n                                parentObj[parentKey].push(...objCandidate);\r\n                            else {\r\n                                if(Array.isArray(parentObj)) {\r\n                                    parentObj[parentKey] = objCandidate;\r\n                                    if(Array.isArray(objCandidate))\r\n                                        trackParentSetObjects.add(parentObj[parentKey]);\r\n                                }\r\n                                else {\r\n                                    ObjectInterpolatorBase.mergeInto(parentObj, objCandidate)\r\n                                    queuedDeletes.push(ObjectInterpolatorBase.createPathDotNotation(keys, key));\r\n                                }\r\n                            }\r\n\r\n                            if(Array.isArray(parentObj)) {\r\n                                this.addFlattenPaths(flattenPaths, keys);\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                    else\r\n                        throw new Error(\"No parent object to merge\");\r\n                }\r\n                else if(keyReplaceResult.nReplacedKeys > 0) {\r\n                    childObj[keyReplaceResult.key] = childObj[key];\r\n                    delete childObj[key];\r\n                }\r\n\r\n            }\r\n            else if(cmd === KeyCommands.KeyCmdQueueDelChildObjectIfEmpty) {\r\n                queuedDeletes.push(ObjectInterpolatorBase.createPathDotNotation(keys, key));\r\n            }\r\n        }\r\n        for(const flattenObj of flattenPaths)\r\n             ObjectInterpolatorBase.mergeInto(flattenObj, flattenObj.flat());\r\n\r\n        this.processDeletes(queuedDeletes);\r\n\r\n        return { obj: this.getObj(), nReplacedKeys: nReplacedKeys };\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Takes a function expression with arguments and returns abstract syntax tree\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ParseFunctionCalls extends BaseAST {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options) {\r\n        super(expression);\r\n        this._options = options;\r\n        this._options.OptionStringArgQuoted = this._options.OptionStringArgQuoted !== undefined ?\r\n            this._options.OptionStringArgQuoted : false;\r\n    }\r\n    getOptionStringArgQuoted() { return this._options.OptionStringArgQuoted; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // We need to pass over any group of characters enclosed in single quotes, double quotes or array brackets as in:\r\n    //  * 'skip this stuff'\r\n    //  * \"skip this stuff\"\r\n    //  * [skip this stuff]\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipGroupedChars() {\r\n        let beginChar = this.cAtI();\r\n\r\n        // Special token which indicates the start of a group, one of: ' \" [\r\n        if(BaseAST.isGroupTokenBegin(beginChar)) {\r\n            let inTokens = [];\r\n            inTokens.push(beginChar);\r\n\r\n            // We need to scan ahead until we find the matching end token\r\n            while(this.hasChars() && inTokens.length > 0) {\r\n\r\n                // Use the last group token pushed - and skip it\r\n                beginChar = inTokens[inTokens.length - 1];\r\n                this.skip();\r\n\r\n                // It is possible that we could have nested group tokens, consider: [\"4\", \"1\"]\r\n                while (this.hasChars()) {\r\n\r\n                    // 1st - check if we have a matching token to our current beginChar, one of: ' \" ]\r\n                    if(this.cAtIIsGroupTokenEnd(beginChar)) {\r\n                        inTokens.pop();\r\n                        break;\r\n                    }\r\n                    else {\r\n                        // 2nd - we can consider that we may have a nested group token, if we do, we will work with this\r\n                        // one until we find its matching end token\r\n                        const newBeginChar = this.cAtI();\r\n                        if (BaseAST.isGroupTokenBegin(newBeginChar)) {\r\n                            beginChar = newBeginChar;\r\n                            inTokens.push(newBeginChar);\r\n                            break;\r\n                        }\r\n                    }\r\n                    // If we got here, we are happily moving along, consuming characters between our start group token\r\n                    // while we attempt to find a matching end to our group\r\n                    this.skip();\r\n                }\r\n            }\r\n            // if we have unmatched ending tokens we should raise and exception\r\n            if(inTokens.length > 0)\r\n                throw new Error(`Parse error - mismatch on some ending symbols: [${inTokens.map((symbol) => `'${symbol}'`).join(\",\")}]`);\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipNonSpecialChars() {\r\n        while (this.hasChars() && !this.cAtIIsWhite() && !this.cAtIOIsOpen() && !this.cAtIOIsClose() && !this.cAtIIsArgSeporator()) {\r\n            this.skip();\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    readToken() {\r\n        this.skipWhitespace();\r\n\r\n        let token;\r\n        if (!this.cAtIOIsOpen() && !this.cAtIOIsClose()) {\r\n\r\n            // our token should start at this index\r\n            const start = this.getI();\r\n\r\n            this.skipGroupedChars();\r\n            this.skipNonSpecialChars();\r\n\r\n            // our token should end at this index\r\n            const end = this.getI();\r\n\r\n            // slice out our token\r\n            token = this.getExpr().slice(start, end);\r\n        }\r\n        else\r\n            throw new Error(`Parse error - Unexpected '(' or ')' missing function name`);\r\n\r\n        return token;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseArguments() {\r\n        let args = [];\r\n        while (this.hasChars() && !this.cAtIOIsClose()) {\r\n            args.push(this.parseExpression());\r\n            this.skipWhitespace();\r\n\r\n            if (this.cAtIIsArgSeporator())\r\n                this.skip();  // Skip comma\r\n        }\r\n        return args;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseExpression() {\r\n        let token = this.readToken();\r\n\r\n        if (/^true|false$/.test(token)) {\r\n            /* literal true or false */\r\n        }\r\n        else if(/^null$/.test(token)) {\r\n            /* literal null */\r\n        }\r\n        else if (/^[a-zA-Z_ƒ][\\w]*$/.test(token)) {\r\n            this.skipWhitespace();\r\n\r\n            // make sure we have an open bracket '(' - and skip it\r\n            if (this.cAtIOIsOpen()) {\r\n                /* function name */\r\n                let funcName = token;\r\n\r\n                this.skip(); // Skip\r\n\r\n                // parse the arguments\r\n                let args = this.parseArguments();\r\n\r\n                // make sure we have an open bracket '(' - and skip it\r\n                this.skipWhitespace();\r\n                if (!this.cAtIOIsClose())\r\n                    throw new Error(`Parse error - Expected '(' after function name ${funcName}`);\r\n                this.skip(); // Skip ')'\r\n\r\n                return {\r\n                    type: 'FunctionCall',\r\n                    name: funcName,\r\n                    arguments: args\r\n                };\r\n            }\r\n            else if(this.getOptionStringArgQuoted())\r\n                throw new Error(`Parse error - Expected '(' after function name ${token}`);\r\n            else {\r\n                // getting here implies that the token is a string parameter and not a function call, it also means\r\n                // we are missing single quotes around the param.  However, we should have single quotes around\r\n                // string params.  Let's add them\r\n               token = `'${token}'`;\r\n            }\r\n        }\r\n\r\n        return {\r\n          type: 'Literal',\r\n          value: token\r\n        };\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parse() {\r\n        this.notifyParseStart();\r\n\r\n        // create the abstract syntax tree\r\n        const asTree =  this.parseExpression();\r\n\r\n        this.notifyParseComplete(asTree);\r\n\r\n        return asTree;\r\n    }\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Derived class handles evaluation of abstract syntax tree\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass EvaluateFunctions extends ParseFunctionCalls {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertNum(value) {\r\n        let result = undefined;\r\n        if((typeof value === 'string') && (value !== '')) {\r\n            const num = Number(value);\r\n            if (!isNaN(num))\r\n                result = num;\r\n        }\r\n\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertString(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^['\"](.*)['\"]$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1];\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertBool(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^(true|false)$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1] === 'true';\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertNull(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^(null)$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1] === 'null' ? null : undefined;\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertObj(value) {\r\n        let result = undefined;\r\n        try {\r\n            result = JSON.parse(value);\r\n        }\r\n        catch(er) { throw new Error('Failed to convert value to Json object'); }\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertToLiteral(value) {\r\n        let result = value;\r\n        const num = EvaluateFunctions.convertNum(value);\r\n        if(num !== undefined)\r\n            result = num;\r\n        else\r\n        {\r\n            const str = EvaluateFunctions.convertString(value);\r\n            if(str !== undefined)\r\n                result = str;\r\n            else\r\n            {\r\n                const bool = EvaluateFunctions.convertBool(value);\r\n                if(bool !== undefined)\r\n                    result = bool;\r\n                else\r\n                {\r\n                    const nullValue = EvaluateFunctions.convertNull(value);\r\n                    if(nullValue !== undefined)\r\n                        result = nullValue\r\n                    else\r\n                    {\r\n                        try {\r\n                            const obj = EvaluateFunctions.convertObj(value);\r\n                            if (obj !== undefined)\r\n                                result = obj;\r\n                        }\r\n                        catch(er) {\r\n                            if(typeof value === 'string')\r\n                                return value;\r\n                            else\r\n                                throw new Error('Invalid type in convertToLiteral');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static invokeParsedFunction(sender, asTree, context) {\r\n\r\n        // If it's a literal, return the value directly\r\n        if (asTree.type === 'Literal')\r\n            return EvaluateFunctions.convertToLiteral(asTree.value);\r\n        else if (asTree.type === 'FunctionCall') {\r\n            const func = context[asTree.name];\r\n            if (typeof func !== 'function')\r\n                throw new Error(`Function ${asTree.name} is not defined in the context`);\r\n\r\n            // Recursively evaluate and collect arguments\r\n            const args = asTree.arguments.map(arg => EvaluateFunctions.invokeParsedFunction(sender, arg, context));\r\n\r\n            // Invoke the function with the evaluated arguments\r\n            return func(sender, ...args);\r\n        } else {\r\n            throw new Error(\"Unknown AST node type\");\r\n        }\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(parent, expression, keyValueContext, fContext, options = {}) {\r\n        super(expression, options);\r\n        this._parent = parent;\r\n        this._keyValueContext = keyValueContext;\r\n        this._fContext = fContext;\r\n        this._asTree = null;\r\n    }\r\n    getParent() { return this._parent; }\r\n    getKeyValueContext() { return this._keyValueContext; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parse() {\r\n        this._asTree = super.parse();\r\n        const evaluation =  EvaluateFunctions.invokeParsedFunction(this, this._asTree, this._fContext);\r\n        return evaluation;\r\n    }\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Attempts to resolve undefined parameters as embedded function calls, during interpolation.  Any key prepended with\r\n// \"->\", will be parsed as a function.  For example, interpolation parameters like:\r\n//   {{->Add(1,2)}}\r\n//  Will be parsed as function Add(1,2).  As long as \"Add\" function exists in provided context, the function will be\r\n//  invoked.  The resulting value will be used as the replacement parameter\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\n\r\nclass ObjectInterpolator extends ObjectInterpolatorBase {\r\n    static convertToString(value) {\r\n        let result = value;\r\n        if((typeof value === 'number') || (typeof value === 'bigint') ||(typeof value === 'boolean') || (typeof value === 'string'))\r\n            result = value.toString();\r\n        else if(value === null)\r\n            result = 'null';\r\n        else if(value === undefined)\r\n            result = undefined;\r\n        else if(Array.isArray(value))\r\n            result = JSON.stringify(value);\r\n        else\r\n            console.error('Failed to convert to primitive type');\r\n\r\n        return result;\r\n    }\r\n\r\n    static processExpression(expression) {\r\n        const e = new ExpressionParser(expression);\r\n        return e.evaluate();\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static getFunctionExpression(expression) {\r\n        let result = \"\";\r\n        if(expression) {\r\n            const regX = new RegExp(REGX.FUNCTION_TAG)\r\n            const match = regX.exec(expression);\r\n            if(Array.isArray(match) && (match.length === 2))\r\n                result = match[1];\r\n        }\r\n\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(obj, keyValues, parseFContext, options = {}) {\r\n        super(obj, keyValues, options);\r\n        this._parseFContext = parseFContext ? parseFContext : {};\r\n        this._buildInFContext = {\r\n            'ƒ': (sender, expression) => ObjectInterpolator.processExpression(expression),\r\n            'Exp': (sender, expression) => ObjectInterpolator.processExpression(expression),\r\n            '_': (sender, value) => ObjectInterpolator.convertToString(value)\r\n        };\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI) {\r\n        const functionExpression = ObjectInterpolator.getFunctionExpression(key);\r\n        if(this._parseFContext && functionExpression) {\r\n            const evaluateF = new EvaluateFunctions(this, functionExpression, keyValueContext,\r\n                {...this._parseFContext, ...this._buildInFContext });\r\n            return evaluateF.parse();\r\n        }\r\n        else {\r\n            return super.notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI);\r\n        }\r\n    }\r\n}\r\n\r\nexport { ObjectInterpolator, StringInterpolator, ObjectInterpolatorBase, SinglePassTagReplacer, SimpleTagParser,\r\n    InterpolationValueNotFoundError, ReplaceObjectAction, KeyValueContextI, QueryObjKeyValueContextI};\r\n\r\n","#!/usr/bin/env node\r\nimport { readFile, writeFile } from 'fs/promises';\r\nimport path from 'path';\r\nimport { StringInterpolator } from \"./interpolation_objects.js\";\r\n\r\n// --------------------------------------------------------------------------------------------------------------------\r\n//\r\n// main entry point for replace on file template\r\n//\r\n// --------------------------------------------------------------------------------------------------------------------\r\nclass Main {\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    static parseReplaceParams(paramString) {\r\n        const replaceParams = {};\r\n        paramString.split(';').forEach( (keyValuePair) => {\r\n            const [key, value] = keyValuePair.split('=');\r\n            if (key && value) {\r\n                replaceParams[key.trim()] = value.trim();\r\n            }\r\n        });\r\n        return replaceParams;\r\n    }\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    static logUsageExit() {\r\n        console.info(`Replace template parameters in a file:`);\r\n        console.info(`  Usage: ${path.basename(process.argv[0])} ${path.basename(process.argv[1])} <templateFileName> <outputFileName> <Key1=value1; Key2=value2; ...>`);\r\n        process.exit(1);\r\n    }\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    constructor() {\r\n        this._templateFileName = \"\";\r\n        this._outputFileName = \"\";\r\n        this._replaceParams = {};\r\n        if (process.argv.length > 4) {\r\n            // Step 1: Validate templateFileName\r\n            this._templateFileName = process.argv[2];\r\n            this._outputFileName = process.argv[3];\r\n\r\n            // Step 2: Parse replacement parameters\r\n            const paramString = process.argv.slice(4).join(' ');\r\n            this._replaceParams = Main.parseReplaceParams(paramString);\r\n        }\r\n        else\r\n            Main.logUsageExit();\r\n\r\n\r\n    }\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    // Main entry point\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    async main() {\r\n        try {\r\n            // Step 3: Read template file content\r\n            const templateString = await readFile(this._templateFileName, 'utf8');\r\n\r\n            // Step 4: Interpolate with provided params\r\n            const si = new StringInterpolator(templateString, this._replaceParams,\r\n                {TrackCurlyBrackets: false});\r\n            const resultingOutput = await si.sInterpolate();\r\n\r\n            // Step 5: Write the interpolated content to the output file\r\n            await writeFile(this._outputFileName, resultingOutput, 'utf8');\r\n\r\n            console.log(`File content written successfully to: ${this._outputFileName}`);\r\n\r\n        } catch (err) {\r\n            console.error('Error processing the file:', err.message);\r\n            Main.logUsageExit();\r\n        }\r\n    }\r\n}\r\n\r\n// --------------------------------------------------------------------------------------------------------------------\r\n// Run main\r\n// --------------------------------------------------------------------------------------------------------------------\r\n( async () => { await (new Main()).main(); } )();\r\n\r\n"],"names":["readFile","writeFile"],"mappings":"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"}