{"version":3,"file":"interpolation_file_template.min.esm","sources":["../src/interpolation_objects.js","../src/interpolation_file_template.js"],"sourcesContent":["import {ExpressionParser} from \"./expression_parser.js\"\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst REGX = Object.freeze({\r\n    FUNCTION_TAG: '^\\\\s*->\\\\s*(.*)',\r\n    CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY: '^(<-\\\\s*false\\\\s*)|(<--\\\\s*false\\\\s*)$',\r\n    CMD_KEY_COPY_INTO_OBJ: '^(<-\\\\s*true\\\\s*)|(<-\\\\s*)$',\r\n    CMD_KEY_COPY_INTO_PARENT_OBJ: '^(<--\\\\s*true\\\\s*)|(<--\\\\s*)$',\r\n\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// Exceptions\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass InterpolationValueNotFoundError extends Error { constructor(){ super(\"Interpolation value not Found\"); } }\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Base class for a generic parser like an Abstract Syntax Tree or any simple parser requiring simple character scanning\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass BaseAST {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static isWhitespace(char) { return /\\s/.test(char); }\r\n    static isOpen(char) { return char === '('; }\r\n    static isClose(char) { return char === ')'; }\r\n    static isCurlyOpen(char) { return char === '{'; }\r\n    static isCurlyClose(char) { return char === '}'; }\r\n    static isArgSeparate(char) { return char === ','; }\r\n    static isSquareOpen(char) { return char === '['; }\r\n    static isSquareClose(char) { return char === ']'; }\r\n    static isGroupTokenBegin(char) { return (char === \"'\") || (char === '\"') || (char === '[') || (char === '{'); }\r\n    static isMatchingGroupTokenEnd(beginChar, char) {\r\n        if(beginChar === \"'\")\r\n            return char === \"'\";\r\n        else if(beginChar === '\"')\r\n            return char === '\"';\r\n        else if(beginChar === '[')\r\n            return char === ']';\r\n        else if(beginChar === '{')\r\n            return char === '}';\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression) {\r\n        this._expression = expression;\r\n        this._index = 0;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyParseStart() { this._index = 0; }\r\n    notifyParseComplete(parseResult) {}\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Basic character functions - non consuming\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getI() { return this._index; }\r\n    getExpr() { return this._expression; }\r\n    cAtI(n = 0) { return this.getExpr()[this._index + n]; }\r\n    cAtIIsWhite() { return BaseAST.isWhitespace(this.cAtI()); }\r\n    skip(n=1) { return this._index += n; }\r\n    hasChars(nChars = 1) { return (this.getExpr().length - this._index) >= nChars; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Useful character functions for specific cases\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisCurlyOpen() { return BaseAST.isCurlyOpen(this.cAtI()); }\r\n    cAtIisCurlyClose() { return BaseAST.isCurlyClose(this.cAtI()); }\r\n    cAtIOIsOpen() { return BaseAST.isOpen(this.cAtI()); }\r\n    cAtIOIsClose() { return BaseAST.isClose(this.cAtI()); }\r\n    cAtIIsArgSeporator() { return BaseAST.isArgSeparate(this.cAtI())}\r\n    cAtIIsGroupTokenEnd(beginChar) { return BaseAST.isMatchingGroupTokenEnd(beginChar, this.cAtI()); }\r\n    cAtIIsTag(tag) {\r\n        let hasTag = false;\r\n        const tagLen = tag.length;\r\n        if(this.hasChars(tagLen)) {\r\n            let nFoundSymbols = 0;\r\n            for(let i = 0; i < tag.length; i++) {\r\n                if(this.cAtI(i) === tag[i])\r\n                    nFoundSymbols++;\r\n            }\r\n            hasTag = (nFoundSymbols === tagLen)\r\n        }\r\n        return hasTag;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Consuming\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipWhitespace() {\r\n        while (this.hasChars() && this.cAtIIsWhite())\r\n            this.skip();\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass TagParser extends BaseAST {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options = {}) {\r\n        super(expression);\r\n\r\n        this._options = options;\r\n        this._startTag = \"{{\";\r\n        this._endTag = \"}}\"\r\n        this._ignoreEnclosed = { Opens: [\"{\"], Closes: [\"}\"] }\r\n        this._curlyBracketStack = [];\r\n        this._replacementEdits = []\r\n        this._options.TrackCurlyBrackets = this._options.TrackCurlyBrackets !== undefined ?\r\n            this._options.TrackCurlyBrackets : false;\r\n    }\r\n    getTrackCurlyBrackets() { return this._options.TrackCurlyBrackets; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    createTemplateKey(key) { return `${this._startTag}${key}${this._endTag}`; }\r\n    cAtIIsBeginTag() { return this.cAtIIsTag(this._startTag); }\r\n    cAtIIsEndTag() {\r\n        let isTag = false;\r\n        if(this._curlyBracketStack.length === 0)\r\n            isTag = this.cAtIIsTag(this._endTag);\r\n        return isTag;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisOpen() {\r\n        let closing = undefined;\r\n        const indexOfOpen = this._ignoreEnclosed.Opens.indexOf(this.cAtI());\r\n        if(indexOfOpen !== -1)\r\n            closing = this._ignoreEnclosed.Closes[indexOfOpen];\r\n\r\n\r\n        return closing;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisClosing() {\r\n        let matchedClosing = false;\r\n        if(this._curlyBracketStack.length > 0) {\r\n            const lastClosing = this._curlyBracketStack[this._curlyBracketStack.length - 1];\r\n            if(this.cAtI() === lastClosing)\r\n                matchedClosing = true;\r\n        }\r\n        return matchedClosing;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    trackEnclosedChars() {\r\n        // In the cases where we have not identified a start or end token, track curly brackets.\r\n        if(this.getTrackCurlyBrackets()) {\r\n            const closingChar = this.cAtIisOpen();\r\n            if (closingChar !== undefined)\r\n                this._curlyBracketStack.push(closingChar);\r\n            else if (this.cAtIisClosing()) {\r\n                this._curlyBracketStack.pop();\r\n            }\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseToken() {\r\n        // {{A  {{B}} }}\r\n        let token = undefined;\r\n        let start = -1; let end = -1;\r\n        let iStartToken = -1; let iEndToken = -1;\r\n        while (this.hasChars()) {\r\n            if (this.cAtIIsBeginTag()) {\r\n                iStartToken = this.getI();\r\n                this.skip(this._startTag.length);\r\n                start = this.getI();\r\n            }\r\n            else if ((start !== -1) && this.cAtIIsEndTag()) {\r\n                end = this.getI();\r\n                iEndToken = end +  this._endTag.length;\r\n\r\n                // slice out our token\r\n                token = this.getExpr().slice(start, end);\r\n\r\n                this.skip(this._endTag.length);\r\n                break;\r\n            }\r\n            else {\r\n                this.trackEnclosedChars();\r\n                this.skip();\r\n            }\r\n        }\r\n        return token !== undefined ? {\r\n            Match: this.createTemplateKey(token),\r\n            Key: token,\r\n            IStartToken: iStartToken,\r\n            IEndToken: iEndToken\r\n        } : undefined;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    applyReplacementEdits() {\r\n        return SinglePassTagReplacer.customStringReplacer(this.getExpr(), this._replacementEdits);\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass SimpleTagParser extends TagParser {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options = {}) {\r\n        super(expression, options);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    has() {\r\n        let found = false;\r\n        this.notifyParseStart();\r\n        let matchResultObj = this.parseToken();\r\n        this.notifyParseComplete(matchResultObj);\r\n        return matchResultObj !== undefined;\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass SinglePassTagReplacer extends TagParser {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static customStringReplacer(expression, replacementEdits) {\r\n        // Note: edits are already sorted from left to right\r\n\r\n        // Iterate over the replacementEdits\r\n        let result = '';\r\n        let lastIndex = 0;\r\n\r\n        for (let i = 0; i < replacementEdits.length; i++) {\r\n            const { ReplaceWith, IStartToken, IEndToken } = replacementEdits[i];\r\n\r\n            // Add the existing part of the string before the start token\r\n            result += expression.slice(lastIndex, IStartToken);\r\n\r\n            // Add the new string (key)\r\n            result += ReplaceWith;\r\n\r\n            // Update the lastIndex to be after the end token\r\n            lastIndex = IEndToken;\r\n        }\r\n\r\n        // Add any remaining part of the original string after the last change\r\n        result += expression.slice(lastIndex);\r\n\r\n        return result;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, cb, options = {}) {\r\n        super(expression, options);\r\n        this._cb = cb;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyParseResult(matchResultObj) {\r\n        const match = matchResultObj.Match;\r\n        const key = matchResultObj.Key;\r\n        const offset = matchResultObj.IStartToken;\r\n\r\n        matchResultObj.ReplaceWith = this._cb(this, match, key, offset, this.getExpr());\r\n        this._replacementEdits.push(matchResultObj);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    applyReplacementEdits() {\r\n        return SinglePassTagReplacer.customStringReplacer(this.getExpr(), this._replacementEdits);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    replace() {\r\n        this.notifyParseStart();\r\n        let matchResultObj = this.parseToken();\r\n        while(matchResultObj !== undefined) {\r\n            this.notifyParseResult(matchResultObj);\r\n            matchResultObj = this.parseToken();\r\n        }\r\n        if(this._curlyBracketStack.length > 0)\r\n            throw new Error(`Match Error - unbalanced symbols missing: ${this._curlyBracketStack.join(',')}`);\r\n        this.notifyParseComplete(matchResultObj);\r\n        return this.applyReplacementEdits();\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass PromisesHandler {\r\n    static isPromise(p) {\r\n        let result = false;\r\n        if ((p !== null) && (typeof p === 'object') && typeof p.then === 'function')\r\n            result = true;\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor() {\r\n        this._promises = [];\r\n        this._promiseKeys = [];\r\n        this._matchedOn = []\r\n\r\n        this._nextKeyId = 0;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    hasPromises() { return this._promises.length > 0; }\r\n    allSettled() { return Promise.allSettled(this._promises); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async processPromises() {\r\n        let replaceKeys = undefined;\r\n        if (this.hasPromises()) {\r\n            replaceKeys = {NResolved: 0, NRejected: 0};\r\n            const results = await this.allSettled();\r\n            for (let i = 0; i < results.length; i++) {\r\n                const promiseKey = this._promiseKeys[i];\r\n                const pResult = results[i];\r\n                if(pResult.status === 'fulfilled') {\r\n                    replaceKeys[promiseKey] = pResult.value;\r\n                    replaceKeys.NResolved++;\r\n                }\r\n                else if(pResult.status === 'rejected') {\r\n                    replaceKeys[promiseKey] = this._matchedOn[i];\r\n                    replaceKeys.NRejected++;\r\n                }\r\n            }\r\n        }\r\n        return replaceKeys;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getNextPromiseKey() {\r\n        const key  = `${this._nextKeyId}__@uniquePKey@__${this._nextKeyId}`;\r\n        this._nextKeyId++;\r\n        return key;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    add(matchedOn, pCandidate) {\r\n        let addedKey = undefined;\r\n        if(PromisesHandler.isPromise(pCandidate)) {\r\n            this._matchedOn.push(matchedOn);\r\n            this._promises.push(pCandidate);\r\n            addedKey = this.getNextPromiseKey();\r\n            this._promiseKeys.push(addedKey);\r\n        }\r\n        return addedKey;\r\n    }\r\n}\r\nconst defaultOptions = Object.freeze({\r\n    CovertValueToType: true,\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Context for key values allows lookup by simple key.  This is the Base Interface for getting a value based on a key\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass KeyValueContextI {\r\n    constructor(keyValues) {\r\n        this._keyValues = keyValues;\r\n    }\r\n    getKeyValues() { return this._keyValues; }\r\n    get(key) { return this._keyValues[key]; }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Context for key values allows lookup by a query string.\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass QueryObjKeyValueContextI extends KeyValueContextI {\r\n    constructor(keyValues, useSeparator = \".\") {\r\n        super(keyValues);\r\n        this._useSeparator = useSeparator;\r\n    }\r\n    get(q) {\r\n         function arr_deref(o, ref, i) {\r\n            const key = ref.slice(0, i ? -1 : ref.length);\r\n            return !ref ? o : (o[key]);\r\n        }\r\n        function dot_deref(o, ref) {\r\n            return !ref ? o : ref.split('[').reduce(arr_deref, o);\r\n        }\r\n        try {\r\n            return q.split(this._useSeparator).reduce(dot_deref, this.getKeyValues());\r\n        }\r\n        catch(err) { return undefined; }\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass StringInterpolator {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(templateStr, keyValuesI, options = {}) {\r\n        this._templateStr = templateStr;\r\n\r\n        this._keyValuesI = (keyValuesI instanceof KeyValueContextI) ?\r\n            keyValuesI : new KeyValueContextI(keyValuesI);\r\n\r\n        this._options = options;\r\n\r\n        this._options.CovertValueToType = this._options.CovertValueToType === undefined ?\r\n            defaultOptions.CovertValueToType : this._options.CovertValueToType;\r\n\r\n        this._options.ReplaceNotFoundHandler =\r\n            this._options.ReplaceNotFoundHandler !== undefined ? this._options.ReplaceNotFoundHandler : (templateVar, key) => { return templateVar };\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getOptionConvertType() { return this._options.CovertValueToType; }\r\n    getOptionReplaceNotFoundHandler() { return this._options.ReplaceNotFoundHandler; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getValueInMap(key) { return this._keyValuesI.get(key); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doReplaces(templateStr, options) {\r\n        let simpleReplace = undefined;\r\n        const promisesHandler = new PromisesHandler();\r\n\r\n        // Replace string with found key\r\n        let nReplaces = 0;\r\n        const replace = (new SinglePassTagReplacer(templateStr,\r\n            (sender, match, key, offset, string) => {\r\n\r\n                let replaceCandidate = options.getValueInMap(key.trim());\r\n                if((replaceCandidate === undefined) && options.canInvokeNotFoundHandler())\r\n                    replaceCandidate = this.getOptionReplaceNotFoundHandler()(match, key);\r\n\r\n                // If there are promises to resolve, replace the token with our promise key\r\n                const promiseKey = promisesHandler.add(match, replaceCandidate);\r\n                if(promiseKey !== undefined)\r\n                    replaceCandidate = sender.createTemplateKey(promiseKey);\r\n                else if(this.getOptionConvertType() && (match === string))\r\n                    simpleReplace = replaceCandidate;\r\n                else {\r\n                    if((replaceCandidate !== null) && (typeof replaceCandidate === 'object'))\r\n                        replaceCandidate = JSON.stringify(replaceCandidate)\r\n                }\r\n\r\n                return replaceCandidate;\r\n\r\n        }, this._options)).replace();\r\n        let resultingS = undefined;\r\n        const promiseReplaceKeys = await promisesHandler.processPromises();\r\n        if(promiseReplaceKeys !== undefined) {\r\n            resultingS = await this.doReplaces(replace, {\r\n                getValueInMap: (key) =>  promiseReplaceKeys[key],\r\n                canInvokeNotFoundHandler: () => false\r\n            });\r\n        }\r\n\r\n        resultingS = resultingS || (simpleReplace !== undefined ? simpleReplace : replace);\r\n        return resultingS;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async sInterpolate() {\r\n        let resultingS = this._templateStr;\r\n\r\n        if (typeof resultingS === 'string') {\r\n            resultingS = await this.doReplaces(resultingS, {\r\n                getValueInMap: (key) =>  this.getValueInMap(key),\r\n                canInvokeNotFoundHandler: () => true\r\n            });\r\n        }\r\n\r\n        return resultingS;\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst ReplaceObjectAction = Object.freeze({\r\n    ACTION_NONE: Symbol(\"ACTION_NONE\"),\r\n    ACTION_DELETE: Symbol(\"ACTION_DELETE\"),\r\n    ACTION_THROW: Symbol(\"ACTION_THROW\"),\r\n    isValidAction: function (action) {\r\n        let isValid = false;\r\n        if(action)\r\n            isValid = (action === ReplaceObjectAction.ACTION_NONE) ||\r\n                (action === ReplaceObjectAction.ACTION_DELETE) ||\r\n                (action === ReplaceObjectAction.ACTION_THROW);\r\n        return isValid;\r\n    }\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ActionI {\r\n    constructor() {\r\n        this._action = ReplaceObjectAction.ACTION_NONE;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getAction() { return this._action; }\r\n    setAction(newActionValue) {\r\n        let actionSet = false;\r\n        if(ReplaceObjectAction.isValidAction(newActionValue)) {\r\n            this._action = newActionValue;\r\n\r\n            actionSet = true;\r\n        }\r\n\r\n        return actionSet;\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst KeyCommands = Object.freeze({\r\n    KeyCmdNone: 0,\r\n    KeyCmdCopyIntoObject: 1,\r\n    KeyCmdCopyIntoParentObject: 2,\r\n    KeyCmdDelKey: 3,\r\n    KeyCmdQueueDelChildObjectIfEmpty: 4\r\n});\r\n\r\nclass ObjectInterpolatorBase  {\r\n    static isKeyCmd(key, cmd) { return key.search(new RegExp(cmd)) !== -1; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static containsTemplateVar(templateString) {\r\n        return (templateString && typeof templateString === 'string') ?\r\n            ((new SimpleTagParser(templateString)).has()) : false;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static dupWithoutVars(childObj) {\r\n        const obj = {...childObj};\r\n        for (const [key, value] of Object.entries(childObj)) {\r\n            // we should remove any variable which has a template variable\r\n            if (ObjectInterpolatorBase.containsTemplateVar(value))\r\n                delete obj[key];\r\n        }\r\n        return obj;\r\n    }\r\n    static mergeInto(target, source) {\r\n        if(Array.isArray(target) && Array.isArray((source))) {\r\n            target.splice(0, target.length, ...source);\r\n        }\r\n        else {\r\n            Object.assign(target, source);\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // {A:{a:1,b:2, c:{d:4}}\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static *iterateObjStrings(obj, keys = [], objs= []) {\r\n        let isRoot = false;\r\n        if(obj) {\r\n\r\n            // push the root object\r\n            if(objs.length === 0) { objs.push(obj); isRoot = true; }\r\n\r\n\r\n            const useKeys = Array.isArray(obj.__ProcessKeys__) ? obj.__ProcessKeys__ : Object.keys(obj);\r\n            for(let i = 0; i < useKeys.length; i++) {\r\n                const key = useKeys[i]; const value = obj[key];\r\n\r\n                if ((typeof value === 'object') && (value !== null)) {\r\n                    keys.push(key); objs.push(value);\r\n                    yield* ObjectInterpolatorBase.iterateObjStrings(value, keys, objs );\r\n                    keys.pop();  objs.pop();\r\n                }\r\n                else if (typeof value === 'string') {\r\n                    yield [obj, key, value.trim(), keys, objs];\r\n                    const regex = /^__DEBUG__\\d*$/;\r\n                    const isDebugPrint = !!key.match(regex);\r\n                    if (isDebugPrint) {\r\n                        console.log(obj[key]);\r\n                        delete obj[key];\r\n                    }\r\n                }\r\n            }\r\n\r\n            // pop the root object\r\n            if(isRoot) { objs.pop(); }\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static createPathDotNotation(keys, key) { return keys.length > 0 ? keys.join(\"¤\") + \"¤\" + key : key; }\r\n    static createObjectPath(pathDotNotation) { return pathDotNotation.split(\"¤\"); }\r\n    static dup(obj) { return JSON.parse(JSON.stringify(obj)); }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(obj, keyValues, options = {}) {\r\n        this._options = options;\r\n        this._options.CopyObj = this._options.CopyObj !== undefined ? this._options.CopyObj : false\r\n\r\n        this._obj = this.getCopyObj() ? ObjectInterpolatorBase.dup(obj) : obj;\r\n        this._keyValues = keyValues;\r\n\r\n        this._options.ActionOnNotFound = ReplaceObjectAction.isValidAction(this._options.ActionOnNotFound) ?\r\n            this._options.ActionOnNotFound : ReplaceObjectAction.ACTION_NONE;\r\n\r\n        this._options.KeyValueContextI = this._options.KeyValueContextI !== undefined ?\r\n            this._options.KeyValueContextI : KeyValueContextI;\r\n\r\n        this._nPass = 2;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getObj() { return this._obj; }\r\n    getOptions() { return this._options; }\r\n    getActionOnNotFound() { return this._options.ActionOnNotFound; }\r\n    getOptionKeyValueContextI() { return this._options.KeyValueContextI; }\r\n    getOptionKeyValueContextSeparator() { return this._options.KeyValueContextSeparator || \".\"; }\r\n    getCopyObj() { return this._options.CopyObj; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // There are two possible return values, either:\r\n    // 1. The not found template var, as in \"{{var}}\".\r\n    // 2. The value returned by the handler (as long as the return value is not an action to delete the key).\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI) {\r\n        let useValue = templateVar;\r\n        if(parentReplaceNotFoundHandler) {\r\n            // If the value returned by the handler is not an action, we can use the value the handler has sent us\r\n            const actionOrValue = parentReplaceNotFoundHandler(templateVar, key);\r\n            if(!setActionI(actionOrValue))\r\n                useValue = actionOrValue;\r\n        }\r\n        else\r\n            setActionI(this.getActionOnNotFound());\r\n\r\n        return useValue;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Keys can hold replacement parameters, which act as commands\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doInterpolateKey(replaceKeyValues, childObj, key, value){\r\n        let nReplacedKeys = 0;\r\n        let useValue = key;\r\n\r\n        for(let i = 0; i < this._nPass; i++) {\r\n            const stringInterpolator = new StringInterpolator(useValue, replaceKeyValues, {\r\n                TrackCurlyBrackets: true, ...this._options,\r\n                ReplaceNotFoundHandler:  (templateVar, key) => {\r\n                    // Return the value to be used as the replace parameter.  Note the caller may set the action,\r\n                    // which may result in this key being deleted on the object (see code below, where we test the\r\n                    // action against the delete value\r\n                    return this.notifyReplaceNotFound(replaceKeyValues, templateVar, key, null,\r\n                        (newActionValue) => undefined);\r\n                }\r\n            });\r\n\r\n            const nextReplace = await stringInterpolator.sInterpolate();\r\n            if (nextReplace !== useValue) {\r\n                nReplacedKeys++;\r\n                useValue = nextReplace;\r\n            } else\r\n                break;\r\n        }\r\n\r\n        return { nReplacedKeys: nReplacedKeys, key: useValue };\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doInterpolateObj(replaceKeyValues, childObj, key, value){\r\n        let nReplacedKeys = 0;\r\n        let useValue = value;\r\n        const parentReplaceNotFoundHandler = this._options.ReplaceNotFoundHandler;\r\n        for(let i = 0; i < this._nPass; i++) {\r\n\r\n            // 'action' interface for setting local variable 'action'.  This code is kind of confusing, but,\r\n            // there is a reason for the complexity.  When we call interpolation on the string, the\r\n            // 'StringInterpolator' object, may invoke our handler to inform us it is not able to find a key.\r\n            // There are essentially three possible actions:\r\n            //   1. Do nothing, that is keep the un-replaced templateVar (we do this by returning the templateVar)\r\n            //   2. Return something that we do want to use, a common use case is to return an empty string (for example).\r\n            //   3. Delete the key from the object.  For this action, the client may return a special value to indicate\r\n            //      that we should delete the key.  The problem is we process this return value inside the handler.\r\n            //      To make this work, we check the value in our handler and set the action, which will be used,\r\n            //      later when the handler returns.\r\n            const actionI = new ActionI();\r\n\r\n            const stringInterpolator = new StringInterpolator(useValue, replaceKeyValues, {\r\n                TrackCurlyBrackets: true, ...this._options,\r\n                ReplaceNotFoundHandler:  (templateVar, key) => {\r\n                    // Return the value to be used as the replace parameter.  Note the caller may set the action,\r\n                    // which may result in this key being deleted on the object (see code below, where we test the\r\n                    // action against the delete value\r\n                    return this.notifyReplaceNotFound(replaceKeyValues, templateVar, key, parentReplaceNotFoundHandler,\r\n                        (newActionValue) => actionI.setAction(newActionValue));\r\n                }\r\n            });\r\n\r\n            let replace = await stringInterpolator.sInterpolate();\r\n            if(actionI.getAction() === ReplaceObjectAction.ACTION_NONE) {\r\n                if (useValue!== replace) {\r\n                    childObj[key] = replace;\r\n                    nReplacedKeys++;\r\n                    useValue = replace;\r\n                } else\r\n                    break;\r\n            }\r\n            else if(actionI.getAction() === ReplaceObjectAction.ACTION_DELETE) {\r\n                delete childObj[key];\r\n                break;\r\n            }\r\n            else if(actionI.getAction() === ReplaceObjectAction.ACTION_THROW) {\r\n                throw new InterpolationValueNotFoundError();\r\n            }\r\n        }\r\n\r\n        return nReplacedKeys;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getCmdInKey(key) {\r\n        let cmd = KeyCommands.KeyCmdNone;\r\n        if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY))\r\n            cmd = KeyCommands.KeyCmdQueueDelChildObjectIfEmpty\r\n        else if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_COPY_INTO_OBJ))\r\n            cmd = KeyCommands.KeyCmdCopyIntoObject;\r\n        else if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_COPY_INTO_PARENT_OBJ))\r\n            cmd = KeyCommands.KeyCmdCopyIntoParentObject;\r\n\r\n        return cmd;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    processDeletes(queuedDeletes) {\r\n        queuedDeletes.forEach( (pathDotNotation) => {\r\n            const path = ObjectInterpolatorBase.createObjectPath(pathDotNotation);\r\n            let itObj = this._obj;\r\n            let ownerObj = null;\r\n            let parentKey = \"\";\r\n            let parentObj = null;\r\n            let childKey = \"\";\r\n            for(let i = 0; i < path.length; i++) {\r\n                if(i === path.length - 1) {\r\n                    parentKey = childKey;\r\n                    ownerObj = parentObj;\r\n                }\r\n                childKey = path[i];\r\n                parentObj = itObj;\r\n                itObj = itObj[childKey];\r\n\r\n            }\r\n            if(parentObj && typeof parentObj === 'object') {\r\n                if(childKey)\r\n                    delete parentObj[childKey];\r\n            }\r\n            if(ownerObj && typeof ownerObj === 'object') {\r\n                if(parentKey && Object.keys(ownerObj[parentKey]).length === 0) {\r\n                    if(Array.isArray(ownerObj))\r\n                        ownerObj.splice(parentKey, 1);\r\n                    else\r\n                        delete ownerObj[parentKey];\r\n                }\r\n\r\n            }\r\n\r\n        });\r\n    }\r\n    addFlattenPaths(flattenPaths, keys) {\r\n        let currentObj = this._obj;\r\n        let flattenObjs = [];\r\n        if(Array.isArray(currentObj))\r\n                flattenObjs.push(currentObj);\r\n        for(let i = 0; i < keys.length; i++) {\r\n            const key = keys[i];\r\n            currentObj = currentObj[key];\r\n            if(Array.isArray(currentObj))\r\n                flattenObjs.push(currentObj);\r\n            else\r\n                flattenObjs = [];\r\n\r\n        }\r\n        for(let i = flattenObjs.length - 1; i >= 0; i--) {\r\n            const flattenObj = flattenObjs[i];\r\n            if(!flattenPaths.has(flattenObj))\r\n                flattenPaths.add(flattenObj);\r\n        }\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // return the interface which knows how to index into our object\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    createKeyValueContextI(keyValues) { return new (this.getOptionKeyValueContextI())(keyValues, this.getOptionKeyValueContextSeparator()); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async interpolate() {\r\n        let nReplacedKeys = 0;\r\n\r\n        const queuedDeletes = [];\r\n        let flattenRoot = false;\r\n        const trackParentSetObjects = new Set();\r\n        const flattenPaths = new Set();\r\n        for (const [childObj, key, value, keys, objs] of ObjectInterpolatorBase.iterateObjStrings(this._obj)) {\r\n\r\n            // Imagine a nested object - where we may have parameters to replace and where the childObj has some keys\r\n            // which may be used as replacement parameters\r\n            const replaceKeyValues =\r\n                this.createKeyValueContextI({ ...this._keyValues, ...ObjectInterpolatorBase.dupWithoutVars(childObj) });\r\n\r\n            const keyReplaceResult = await this.doInterpolateKey(replaceKeyValues, childObj, key, value);\r\n            nReplacedKeys += keyReplaceResult.nReplacedKeys;\r\n            const cmd = this.getCmdInKey(keyReplaceResult.key);\r\n            if((cmd === KeyCommands.KeyCmdNone) ||\r\n                    (cmd === KeyCommands.KeyCmdCopyIntoObject) ||\r\n                    (cmd === KeyCommands.KeyCmdCopyIntoParentObject)) {\r\n\r\n                nReplacedKeys += await this.doInterpolateObj(replaceKeyValues, childObj, key, value);\r\n\r\n                if (cmd === KeyCommands.KeyCmdCopyIntoObject) {\r\n                    const objCandidate = childObj[key];\r\n                    if ((typeof objCandidate === 'object') && (objCandidate !== null)) {\r\n                        Object.assign(childObj, objCandidate);\r\n                        delete childObj[key];\r\n                    }\r\n                }\r\n                else if(cmd === KeyCommands.KeyCmdCopyIntoParentObject) {\r\n                    // The parent object and the parent key can be found by looking at the objs/keys\r\n                    // (which tracks all iterated objects)\r\n                    const parentObj = objs.length > 1 ? objs[objs.length - 2] : null;\r\n                    const parentKey = keys.length > 0 ? keys[keys.length - 1] : \"\";\r\n\r\n                    if(parentObj && parentKey) {\r\n                        let wasSetOn = false;\r\n                        const objCandidate = childObj[key];\r\n                        if ((typeof objCandidate === 'object') && (objCandidate !== null)) {\r\n\r\n                            // Consider the case where we want to load multiple objects to the same element position on\r\n                            // the parent.  (reference Test case **).  This case is when the parentObj is an array\r\n                            const wasPreviouslySetOn = trackParentSetObjects.has(parentObj[parentKey]);\r\n                            if(wasPreviouslySetOn && Array.isArray(objCandidate))\r\n                                parentObj[parentKey].push(...objCandidate);\r\n                            else {\r\n                                if(Array.isArray(parentObj)) {\r\n                                    parentObj[parentKey] = objCandidate;\r\n                                    if(Array.isArray(objCandidate))\r\n                                        trackParentSetObjects.add(parentObj[parentKey]);\r\n                                }\r\n                                else {\r\n                                    ObjectInterpolatorBase.mergeInto(parentObj, objCandidate)\r\n                                    queuedDeletes.push(ObjectInterpolatorBase.createPathDotNotation(keys, key));\r\n                                }\r\n                            }\r\n\r\n                            if(Array.isArray(parentObj)) {\r\n                                this.addFlattenPaths(flattenPaths, keys);\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                    else\r\n                        throw new Error(\"No parent object to merge\");\r\n                }\r\n                else if(keyReplaceResult.nReplacedKeys > 0) {\r\n                    childObj[keyReplaceResult.key] = childObj[key];\r\n                    delete childObj[key];\r\n                }\r\n\r\n            }\r\n            else if(cmd === KeyCommands.KeyCmdQueueDelChildObjectIfEmpty) {\r\n                queuedDeletes.push(ObjectInterpolatorBase.createPathDotNotation(keys, key));\r\n            }\r\n        }\r\n        for(const flattenObj of flattenPaths)\r\n             ObjectInterpolatorBase.mergeInto(flattenObj, flattenObj.flat());\r\n\r\n        this.processDeletes(queuedDeletes);\r\n\r\n        return { obj: this.getObj(), nReplacedKeys: nReplacedKeys };\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Takes a function expression with arguments and returns abstract syntax tree\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ParseFunctionCalls extends BaseAST {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options) {\r\n        super(expression);\r\n        this._options = options;\r\n        this._options.OptionStringArgQuoted = this._options.OptionStringArgQuoted !== undefined ?\r\n            this._options.OptionStringArgQuoted : false;\r\n    }\r\n    getOptionStringArgQuoted() { return this._options.OptionStringArgQuoted; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // We need to pass over any group of characters enclosed in single quotes, double quotes or array brackets as in:\r\n    //  * 'skip this stuff'\r\n    //  * \"skip this stuff\"\r\n    //  * [skip this stuff]\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipGroupedChars() {\r\n        let beginChar = this.cAtI();\r\n\r\n        // Special token which indicates the start of a group, one of: ' \" [\r\n        if(BaseAST.isGroupTokenBegin(beginChar)) {\r\n            let inTokens = [];\r\n            inTokens.push(beginChar);\r\n\r\n            // We need to scan ahead until we find the matching end token\r\n            while(this.hasChars() && inTokens.length > 0) {\r\n\r\n                // Use the last group token pushed - and skip it\r\n                beginChar = inTokens[inTokens.length - 1];\r\n                this.skip();\r\n\r\n                // It is possible that we could have nested group tokens, consider: [\"4\", \"1\"]\r\n                while (this.hasChars()) {\r\n\r\n                    // 1st - check if we have a matching token to our current beginChar, one of: ' \" ]\r\n                    if(this.cAtIIsGroupTokenEnd(beginChar)) {\r\n                        inTokens.pop();\r\n                        break;\r\n                    }\r\n                    else {\r\n                        // 2nd - we can consider that we may have a nested group token, if we do, we will work with this\r\n                        // one until we find its matching end token\r\n                        const newBeginChar = this.cAtI();\r\n                        if (BaseAST.isGroupTokenBegin(newBeginChar)) {\r\n                            beginChar = newBeginChar;\r\n                            inTokens.push(newBeginChar);\r\n                            break;\r\n                        }\r\n                    }\r\n                    // If we got here, we are happily moving along, consuming characters between our start group token\r\n                    // while we attempt to find a matching end to our group\r\n                    this.skip();\r\n                }\r\n            }\r\n            // if we have unmatched ending tokens we should raise and exception\r\n            if(inTokens.length > 0)\r\n                throw new Error(`Parse error - mismatch on some ending symbols: [${inTokens.map((symbol) => `'${symbol}'`).join(\",\")}]`);\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipNonSpecialChars() {\r\n        while (this.hasChars() && !this.cAtIIsWhite() && !this.cAtIOIsOpen() && !this.cAtIOIsClose() && !this.cAtIIsArgSeporator()) {\r\n            this.skip();\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    readToken() {\r\n        this.skipWhitespace();\r\n\r\n        let token;\r\n        if (!this.cAtIOIsOpen() && !this.cAtIOIsClose()) {\r\n\r\n            // our token should start at this index\r\n            const start = this.getI();\r\n\r\n            this.skipGroupedChars();\r\n            this.skipNonSpecialChars();\r\n\r\n            // our token should end at this index\r\n            const end = this.getI();\r\n\r\n            // slice out our token\r\n            token = this.getExpr().slice(start, end);\r\n        }\r\n        else\r\n            throw new Error(`Parse error - Unexpected '(' or ')' missing function name`);\r\n\r\n        return token;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseArguments() {\r\n        let args = [];\r\n        while (this.hasChars() && !this.cAtIOIsClose()) {\r\n            args.push(this.parseExpression());\r\n            this.skipWhitespace();\r\n\r\n            if (this.cAtIIsArgSeporator())\r\n                this.skip();  // Skip comma\r\n        }\r\n        return args;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseExpression() {\r\n        let token = this.readToken();\r\n\r\n        if (/^true|false$/.test(token)) {\r\n            /* literal true or false */\r\n        }\r\n        else if(/^null$/.test(token)) {\r\n            /* literal null */\r\n        }\r\n        else if (/^[a-zA-Z_ƒ][\\w]*$/.test(token)) {\r\n            this.skipWhitespace();\r\n\r\n            // make sure we have an open bracket '(' - and skip it\r\n            if (this.cAtIOIsOpen()) {\r\n                /* function name */\r\n                let funcName = token;\r\n\r\n                this.skip(); // Skip\r\n\r\n                // parse the arguments\r\n                let args = this.parseArguments();\r\n\r\n                // make sure we have an open bracket '(' - and skip it\r\n                this.skipWhitespace();\r\n                if (!this.cAtIOIsClose())\r\n                    throw new Error(`Parse error - Expected '(' after function name ${funcName}`);\r\n                this.skip(); // Skip ')'\r\n\r\n                return {\r\n                    type: 'FunctionCall',\r\n                    name: funcName,\r\n                    arguments: args\r\n                };\r\n            }\r\n            else if(this.getOptionStringArgQuoted())\r\n                throw new Error(`Parse error - Expected '(' after function name ${token}`);\r\n            else {\r\n                // getting here implies that the token is a string parameter and not a function call, it also means\r\n                // we are missing single quotes around the param.  However, we should have single quotes around\r\n                // string params.  Let's add them\r\n               token = `'${token}'`;\r\n            }\r\n        }\r\n\r\n        return {\r\n          type: 'Literal',\r\n          value: token\r\n        };\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parse() {\r\n        this.notifyParseStart();\r\n\r\n        // create the abstract syntax tree\r\n        const asTree =  this.parseExpression();\r\n\r\n        this.notifyParseComplete(asTree);\r\n\r\n        return asTree;\r\n    }\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Derived class handles evaluation of abstract syntax tree\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass EvaluateFunctions extends ParseFunctionCalls {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertNum(value) {\r\n        let result = undefined;\r\n        if((typeof value === 'string') && (value !== '')) {\r\n            const num = Number(value);\r\n            if (!isNaN(num))\r\n                result = num;\r\n        }\r\n\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertString(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^['\"](.*)['\"]$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1];\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertBool(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^(true|false)$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1] === 'true';\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertNull(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^(null)$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1] === 'null' ? null : undefined;\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertObj(value) {\r\n        let result = undefined;\r\n        try {\r\n            result = JSON.parse(value);\r\n        }\r\n        catch(er) { throw new Error('Failed to convert value to Json object'); }\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertToLiteral(value) {\r\n        let result = value;\r\n        const num = EvaluateFunctions.convertNum(value);\r\n        if(num !== undefined)\r\n            result = num;\r\n        else\r\n        {\r\n            const str = EvaluateFunctions.convertString(value);\r\n            if(str !== undefined)\r\n                result = str;\r\n            else\r\n            {\r\n                const bool = EvaluateFunctions.convertBool(value);\r\n                if(bool !== undefined)\r\n                    result = bool;\r\n                else\r\n                {\r\n                    const nullValue = EvaluateFunctions.convertNull(value);\r\n                    if(nullValue !== undefined)\r\n                        result = nullValue\r\n                    else\r\n                    {\r\n                        try {\r\n                            const obj = EvaluateFunctions.convertObj(value);\r\n                            if (obj !== undefined)\r\n                                result = obj;\r\n                        }\r\n                        catch(er) {\r\n                            if(typeof value === 'string')\r\n                                return value;\r\n                            else\r\n                                throw new Error('Invalid type in convertToLiteral');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static invokeParsedFunction(sender, asTree, context) {\r\n\r\n        // If it's a literal, return the value directly\r\n        if (asTree.type === 'Literal')\r\n            return EvaluateFunctions.convertToLiteral(asTree.value);\r\n        else if (asTree.type === 'FunctionCall') {\r\n            const func = context[asTree.name];\r\n            if (typeof func !== 'function')\r\n                throw new Error(`Function ${asTree.name} is not defined in the context`);\r\n\r\n            // Recursively evaluate and collect arguments\r\n            const args = asTree.arguments.map(arg => EvaluateFunctions.invokeParsedFunction(sender, arg, context));\r\n\r\n            // Invoke the function with the evaluated arguments\r\n            return func(sender, ...args);\r\n        } else {\r\n            throw new Error(\"Unknown AST node type\");\r\n        }\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(parent, expression, keyValueContext, fContext, options = {}) {\r\n        super(expression, options);\r\n        this._parent = parent;\r\n        this._keyValueContext = keyValueContext;\r\n        this._fContext = fContext;\r\n        this._asTree = null;\r\n    }\r\n    getParent() { return this._parent; }\r\n    getKeyValueContext() { return this._keyValueContext; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parse() {\r\n        this._asTree = super.parse();\r\n        const evaluation =  EvaluateFunctions.invokeParsedFunction(this, this._asTree, this._fContext);\r\n        return evaluation;\r\n    }\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Attempts to resolve undefined parameters as embedded function calls, during interpolation.  Any key prepended with\r\n// \"->\", will be parsed as a function.  For example, interpolation parameters like:\r\n//   {{->Add(1,2)}}\r\n//  Will be parsed as function Add(1,2).  As long as \"Add\" function exists in provided context, the function will be\r\n//  invoked.  The resulting value will be used as the replacement parameter\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\n\r\nclass ObjectInterpolator extends ObjectInterpolatorBase {\r\n    static convertToString(value) {\r\n        let result = value;\r\n        if((typeof value === 'number') || (typeof value === 'bigint') ||(typeof value === 'boolean') || (typeof value === 'string'))\r\n            result = value.toString();\r\n        else if(value === null)\r\n            result = 'null';\r\n        else if(value === undefined)\r\n            result = undefined;\r\n        else if(Array.isArray(value))\r\n            result = JSON.stringify(value);\r\n        else\r\n            console.error('Failed to convert to primitive type');\r\n\r\n        return result;\r\n    }\r\n\r\n    static processExpression(expression) {\r\n        const e = new ExpressionParser(expression);\r\n        return e.evaluate();\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static getFunctionExpression(expression) {\r\n        let result = \"\";\r\n        if(expression) {\r\n            const regX = new RegExp(REGX.FUNCTION_TAG)\r\n            const match = regX.exec(expression);\r\n            if(Array.isArray(match) && (match.length === 2))\r\n                result = match[1];\r\n        }\r\n\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(obj, keyValues, parseFContext, options = {}) {\r\n        super(obj, keyValues, options);\r\n        this._parseFContext = parseFContext ? parseFContext : {};\r\n        this._buildInFContext = {\r\n            'ƒ': (sender, expression) => ObjectInterpolator.processExpression(expression),\r\n            'Exp': (sender, expression) => ObjectInterpolator.processExpression(expression),\r\n            '_': (sender, value) => ObjectInterpolator.convertToString(value)\r\n        };\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI) {\r\n        const functionExpression = ObjectInterpolator.getFunctionExpression(key);\r\n        if(this._parseFContext && functionExpression) {\r\n            const evaluateF = new EvaluateFunctions(this, functionExpression, keyValueContext,\r\n                {...this._parseFContext, ...this._buildInFContext });\r\n            return evaluateF.parse();\r\n        }\r\n        else {\r\n            return super.notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI);\r\n        }\r\n    }\r\n}\r\n\r\nexport { ObjectInterpolator, StringInterpolator, ObjectInterpolatorBase, SinglePassTagReplacer, SimpleTagParser,\r\n    InterpolationValueNotFoundError, ReplaceObjectAction, KeyValueContextI, QueryObjKeyValueContextI};\r\n\r\n","#!/usr/bin/env node\r\nimport { readFile, writeFile } from 'fs/promises';\r\nimport path from 'path';\r\nimport { StringInterpolator } from \"./interpolation_objects.js\";\r\n\r\n// --------------------------------------------------------------------------------------------------------------------\r\n//\r\n// main entry point for replace on file template\r\n//\r\n// --------------------------------------------------------------------------------------------------------------------\r\nclass Main {\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    static parseReplaceParams(paramString) {\r\n        const replaceParams = {};\r\n        paramString.split(';').forEach( (keyValuePair) => {\r\n            const [key, value] = keyValuePair.split('=');\r\n            if (key && value) {\r\n                replaceParams[key.trim()] = value.trim();\r\n            }\r\n        });\r\n        return replaceParams;\r\n    }\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    static logUsageExit() {\r\n        console.info(`Replace template parameters in a file:`);\r\n        console.info(`  Usage: ${path.basename(process.argv[0])} ${path.basename(process.argv[1])} <templateFileName> <outputFileName> <Key1=value1; Key2=value2; ...>`);\r\n        process.exit(1);\r\n    }\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    constructor() {\r\n        this._templateFileName = \"\";\r\n        this._outputFileName = \"\";\r\n        this._replaceParams = {};\r\n        if (process.argv.length > 4) {\r\n            // Step 1: Validate templateFileName\r\n            this._templateFileName = process.argv[2];\r\n            this._outputFileName = process.argv[3];\r\n\r\n            // Step 2: Parse replacement parameters\r\n            const paramString = process.argv.slice(4).join(' ');\r\n            this._replaceParams = Main.parseReplaceParams(paramString);\r\n        }\r\n        else\r\n            Main.logUsageExit();\r\n\r\n\r\n    }\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    // Main entry point\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    async main() {\r\n        try {\r\n            // Step 3: Read template file content\r\n            const templateString = await readFile(this._templateFileName, 'utf8');\r\n\r\n            // Step 4: Interpolate with provided params\r\n            const si = new StringInterpolator(templateString, this._replaceParams,\r\n                {TrackCurlyBrackets: false});\r\n            const resultingOutput = await si.sInterpolate();\r\n\r\n            // Step 5: Write the interpolated content to the output file\r\n            await writeFile(this._outputFileName, resultingOutput, 'utf8');\r\n\r\n            console.log(`File content written successfully to: ${this._outputFileName}`);\r\n\r\n        } catch (err) {\r\n            console.error('Error processing the file:', err.message);\r\n            Main.logUsageExit();\r\n        }\r\n    }\r\n}\r\n\r\n// --------------------------------------------------------------------------------------------------------------------\r\n// Run main\r\n// --------------------------------------------------------------------------------------------------------------------\r\n( async () => { await (new Main()).main(); } )();\r\n\r\n"],"names":["BaseAST","isWhitespace","char","test","isOpen","isClose","isCurlyOpen","isCurlyClose","isArgSeparate","isSquareOpen","isSquareClose","isGroupTokenBegin","isMatchingGroupTokenEnd","beginChar","constructor","expression","this","_expression","_index","notifyParseStart","notifyParseComplete","parseResult","getI","getExpr","cAtI","n","cAtIIsWhite","skip","hasChars","nChars","length","cAtIisCurlyOpen","cAtIisCurlyClose","cAtIOIsOpen","cAtIOIsClose","cAtIIsArgSeporator","cAtIIsGroupTokenEnd","cAtIIsTag","tag","hasTag","tagLen","nFoundSymbols","i","skipWhitespace","TagParser","options","super","_options","_startTag","_endTag","_ignoreEnclosed","Opens","Closes","_curlyBracketStack","_replacementEdits","TrackCurlyBrackets","undefined","getTrackCurlyBrackets","createTemplateKey","key","cAtIIsBeginTag","cAtIIsEndTag","isTag","cAtIisOpen","closing","indexOfOpen","indexOf","cAtIisClosing","matchedClosing","lastClosing","trackEnclosedChars","closingChar","push","pop","parseToken","token","start","end","iStartToken","iEndToken","slice","Match","Key","IStartToken","IEndToken","applyReplacementEdits","SinglePassTagReplacer","customStringReplacer","replacementEdits","result","lastIndex","ReplaceWith","cb","_cb","notifyParseResult","matchResultObj","match","offset","replace","Error","join","PromisesHandler","isPromise","p","then","_promises","_promiseKeys","_matchedOn","_nextKeyId","hasPromises","allSettled","Promise","processPromises","replaceKeys","NResolved","NRejected","results","promiseKey","pResult","status","value","getNextPromiseKey","add","matchedOn","pCandidate","addedKey","defaultOptions","Object","freeze","CovertValueToType","KeyValueContextI","keyValues","_keyValues","getKeyValues","get","StringInterpolator","templateStr","keyValuesI","_templateStr","_keyValuesI","ReplaceNotFoundHandler","templateVar","getOptionConvertType","getOptionReplaceNotFoundHandler","getValueInMap","doReplaces","simpleReplace","promisesHandler","sender","string","replaceCandidate","trim","canInvokeNotFoundHandler","JSON","stringify","resultingS","promiseReplaceKeys","sInterpolate","Main","parseReplaceParams","paramString","replaceParams","split","forEach","keyValuePair","logUsageExit","console","info","path","basename","process","argv","exit","_templateFileName","_outputFileName","_replaceParams","main","templateString","readFile","si","resultingOutput","writeFile","log","err","error","message"],"mappings":"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"}