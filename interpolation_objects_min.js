var e={};(()=>{e.d=(t,s)=>{for(var r in s){if(e.o(s,r)&&!e.o(t,r)){Object.defineProperty(t,r,{enumerable:true,get:s[r]})}}}})();(()=>{e.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)})();if(typeof e!=="undefined")e.ab=new URL(".",import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/)?1:0,-1)+"/";var t={};e.d(t,{lw:()=>InterpolationValueNotFoundError,N5:()=>KeyValueContextI,$A:()=>ObjectInterpolator,at:()=>ObjectInterpolatorBase,g:()=>QueryObjKeyValueContextI,_J:()=>a,g8:()=>SimpleTagParser,SR:()=>SinglePassTagReplacer,PH:()=>StringInterpolator});class ExpressionParseError extends Error{constructor(e){super(e)}}const s=Object.freeze({OPERAND_NUMBERS:"-*\\d+(\\.\\d*)*",OPERAND_STRING:"(?:'|\")[^'\"]*(?:'|\")",OPERAND_LOGICAL_TRUE:"true",OPERAND_LOGICAL_FALSE:"false",OPERAND_POS_INFINITY:"Infinity",OPERAND_NEG_INFINITY:"-Infinity",MATH_OPERATORS:"\\+|\\-|\\*|\\/|\\^|\\(|\\)",TERNARY_OPERATORS:"\\?|\\:",LOGICAL_OPERATORS:"\\|\\||&&|==|!=|!",EQUALITY_OPERATORS:">=|<=|>|<"});class Stack{constructor(){this._values=[]}get size(){return this._values.length}empty(){return this.size===0}peek(){return this.empty()?undefined:this._values[this._values.length-1]}push(e){this._values.push(e)}pop(){return this.empty()?undefined:this._values.pop()}popN(e){const t=[];if(this.size>=e){for(let s=0;s<e;s++)t.unshift(this.pop())}return t}}function toNum(e){const t=parseFloat(e);if(!isNaN(t))return t;else throw new ExpressionParseError(`Failed to convert ${e} to number`)}function toBool(e){if(e==="true"||e===true)return true;else if(e==="false"||e===false)return false;else throw new ExpressionParseError(`Failed to convert ${e} to boolean`)}function extractStrOperand(e){return e.slice(1,e.length-1)}function toStr(e){function isQuote(e){return e==="'"||e==='"'}let t=e.trim();if(t.length>1){const s=t[0];const r=t[t.length-1];if(!isQuote(s)&&!isQuote(r))throw new ExpressionParseError(`String expression ${e} must be enclosed in single quotes`)}else throw new ExpressionParseError(`Failed to convert ${e} to number`);return t}function toOperand(e){try{return toNum(e)}catch(t){try{return toBool(e)}catch(t){return toStr(e)}}}function toTypePair(e,t){const s=toOperand(e);const r=toOperand(t);if(typeof s===typeof r)return[s,r];else throw new ExpressionParseError(`Cannot operate on parameters with different types ${e} <??> ${t}`)}const r={"?":{precedence:0,associativity:"R",NArgs:0,f:function(){throw new ExpressionParseError("Ternary if mismatched")}},":":{precedence:0,associativity:"R",NArgs:2,f:function(){throw new ExpressionParseError("Ternary else if mismatched")}},"?:":{precedence:1,associativity:"R",NArgs:3,f:function(e,t,s){return toBool(e)?toOperand(t):toOperand(s)}},"^":{precedence:2,associativity:"R",NArgs:2,f:function(e,t){return toNum(e)**toNum(t)}},"+":{precedence:4,associativity:"L",NArgs:2,f:function(e,t){return toNum(e)+toNum(t)}},"-":{precedence:4,associativity:"L",NArgs:2,f:function(e,t){return toNum(e)-toNum(t)}},"*":{precedence:3,associativity:"L",NArgs:2,f:function(e,t){return toNum(e)*toNum(t)}},"/":{precedence:3,associativity:"L",NArgs:2,f:function(e,t){return toNum(e)/toNum(t)}},"==":{precedence:7,associativity:"L",NArgs:2,f:function(e,t){const[s,r]=toTypePair(e,t);return s===r}},"!=":{precedence:7,associativity:"L",NArgs:2,f:function(e,t){const[s,r]=toTypePair(e,t);return s!==r}},"!":{precedence:2,associativity:"R",NArgs:1,f:function(e){return!toBool(e)}},"&&":{precedence:11,associativity:"L",NArgs:2,f:function(e,t){return toBool(e)&&toBool(t)}},"||":{precedence:12,associativity:"L",NArgs:2,f:function(e,t){return toBool(e)||toBool(t)}},">=":{precedence:6,associativity:"L",NArgs:2,f:function(e,t){return toNum(e)>=toNum(t)}},"<=":{precedence:6,associativity:"L",NArgs:2,f:function(e,t){return toNum(e)<=toNum(t)}},">":{precedence:6,associativity:"L",NArgs:2,f:function(e,t){return toNum(e)>toNum(t)}},"<":{precedence:6,associativity:"L",NArgs:2,f:function(e,t){return toNum(e)<toNum(t)}}};const n=Object.keys(r);class InfixNotationParser{constructor(e){this._expression=e;this._isOperand=new RegExp(`^${s.OPERAND_STRING}$|^${s.OPERAND_NUMBERS}$|^${s.OPERAND_LOGICAL_TRUE}$|^${s.OPERAND_LOGICAL_FALSE}$|^${s.OPERAND_POS_INFINITY}$|^${s.OPERAND_NEG_INFINITY}$`);this._regXParseExpression=new RegExp(`${s.OPERAND_STRING}|${s.OPERAND_LOGICAL_TRUE}|${s.OPERAND_LOGICAL_FALSE}|${s.OPERAND_POS_INFINITY}|${s.OPERAND_NEG_INFINITY}|${s.OPERAND_NUMBERS}|${s.MATH_OPERATORS}|${s.LOGICAL_OPERATORS}|${s.EQUALITY_OPERATORS}|${s.TERNARY_OPERATORS}`,"g")}isOperator(e){return n.includes(e)}getOperator(e){return r[e]}isAssociative(e,t){return this.getOperator(e).associativity===t}comparePrecedence(e,t){return this.getOperator(e).precedence-this.getOperator(t).precedence}hasHigherPrecedence(e,t){return this.comparePrecedence(e,t)<0}hasLowerPrecedence(e,t){return this.comparePrecedence(e,t)>0}hasSamePrecedence(e,t){return this.comparePrecedence(e,t)===0}tokenize(){return this._expression.match(this._regXParseExpression)}isOperand(e){return this._isOperand.test(e)}toPostfix(){const e=[];const t=this.tokenize();if(Array.isArray(t)){const s=new Stack;t.forEach((t=>{if(this.isOperand(t)){e.push(t)}else if(t==="("){s.push(t)}else if(t===")"){while(s.size>0&&s.peek()!=="("){e.push(s.pop())}if(s.size>0&&s.peek()==="(")s.pop();else throw new ExpressionParseError(`Missing open parenthesis in expression`)}else if(this.isOperator(t)){let r=s.peek();if(s.empty()||r==="("||t==="?"){s.push(t)}else if(t===":"){let t=null;while(!s.empty()){t=s.pop();if(t==="?"){s.push("?:");break}else e.push(t)}if(t!=="?")throw new ExpressionParseError("Missing ternary ? symbol")}else if(this.hasHigherPrecedence(t,r)||this.hasSamePrecedence(t,r)&&this.isAssociative(t,"R")){s.push(t)}else{while(r&&r!=="("&&(this.hasLowerPrecedence(t,r)||this.hasSamePrecedence(t,r)&&this.isAssociative(t,"L"))){e.push(s.pop());r=s.peek()}s.push(t)}}}));while(s.size>0){const t=s.pop();if(t!=="(")e.push(t);else throw new ExpressionParseError(`Missing closing parenthesis in expression`)}}else throw new ExpressionParseError("Parsing expression resulted in an empty parse");return e}}class ExpressionParser extends InfixNotationParser{constructor(e){super(e)}evaluate(){const e=this.toPostfix();const t=new Stack;for(let s=0;s<e.length;s++){const r=e[s];if(this.isOperator(r)){const e=this.getOperator(r);if(t.size>=e.NArgs){const s=t.popN(e.NArgs);const r=e.f(...s);t.push(r)}else throw new ExpressionParseError(`Not enough args for operator ${r}`)}else t.push(r)}if(t.size===1){let e=toOperand(t.pop());if(typeof e==="string")e=extractStrOperand(e);return e}else throw new ExpressionParseError(`Resulting stack appears incorrect with size ${t.size}`)}}const i=Object.freeze({FUNCTION_TAG:"^\\s*->\\s*(.*)",CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY:"^(<-\\s*false\\s*)|(<--\\s*false\\s*)$",CMD_KEY_COPY_INTO_OBJ:"^(<-\\s*true\\s*)|(<-\\s*)$",CMD_KEY_COPY_INTO_PARENT_OBJ:"^(<--\\s*true\\s*)|(<--\\s*)$"});class InterpolationValueNotFoundError extends Error{constructor(){super("Interpolation value not Found")}}class BaseAST{static isWhitespace(e){return/\s/.test(e)}static isOpen(e){return e==="("}static isClose(e){return e===")"}static isCurlyOpen(e){return e==="{"}static isCurlyClose(e){return e==="}"}static isArgSeparate(e){return e===","}static isSquareOpen(e){return e==="["}static isSquareClose(e){return e==="]"}static isGroupTokenBegin(e){return e==="'"||e==='"'||e==="["||e==="{"}static isMatchingGroupTokenEnd(e,t){if(e==="'")return t==="'";else if(e==='"')return t==='"';else if(e==="[")return t==="]";else if(e==="{")return t==="}"}constructor(e){this._expression=e;this._index=0}notifyParseStart(){this._index=0}notifyParseComplete(e){}getI(){return this._index}getExpr(){return this._expression}cAtI(e=0){return this.getExpr()[this._index+e]}cAtIIsWhite(){return BaseAST.isWhitespace(this.cAtI())}skip(e=1){return this._index+=e}hasChars(e=1){return this.getExpr().length-this._index>=e}cAtIisCurlyOpen(){return BaseAST.isCurlyOpen(this.cAtI())}cAtIisCurlyClose(){return BaseAST.isCurlyClose(this.cAtI())}cAtIOIsOpen(){return BaseAST.isOpen(this.cAtI())}cAtIOIsClose(){return BaseAST.isClose(this.cAtI())}cAtIIsArgSeporator(){return BaseAST.isArgSeparate(this.cAtI())}cAtIIsGroupTokenEnd(e){return BaseAST.isMatchingGroupTokenEnd(e,this.cAtI())}cAtIIsTag(e){let t=false;const s=e.length;if(this.hasChars(s)){let r=0;for(let t=0;t<e.length;t++){if(this.cAtI(t)===e[t])r++}t=r===s}return t}skipWhitespace(){while(this.hasChars()&&this.cAtIIsWhite())this.skip()}}class TagParser extends BaseAST{constructor(e,t={}){super(e);this._options=t;this._startTag="{{";this._endTag="}}";this._ignoreEnclosed={Opens:["{"],Closes:["}"]};this._curlyBracketStack=[];this._replacementEdits=[];this._options.TrackCurlyBrackets=this._options.TrackCurlyBrackets!==undefined?this._options.TrackCurlyBrackets:false}getTrackCurlyBrackets(){return this._options.TrackCurlyBrackets}createTemplateKey(e){return`${this._startTag}${e}${this._endTag}`}cAtIIsBeginTag(){return this.cAtIIsTag(this._startTag)}cAtIIsEndTag(){let e=false;if(this._curlyBracketStack.length===0)e=this.cAtIIsTag(this._endTag);return e}cAtIisOpen(){let e=undefined;const t=this._ignoreEnclosed.Opens.indexOf(this.cAtI());if(t!==-1)e=this._ignoreEnclosed.Closes[t];return e}cAtIisClosing(){let e=false;if(this._curlyBracketStack.length>0){const t=this._curlyBracketStack[this._curlyBracketStack.length-1];if(this.cAtI()===t)e=true}return e}trackEnclosedChars(){if(this.getTrackCurlyBrackets()){const e=this.cAtIisOpen();if(e!==undefined)this._curlyBracketStack.push(e);else if(this.cAtIisClosing()){this._curlyBracketStack.pop()}}}parseToken(){let e=undefined;let t=-1;let s=-1;let r=-1;let n=-1;while(this.hasChars()){if(this.cAtIIsBeginTag()){r=this.getI();this.skip(this._startTag.length);t=this.getI()}else if(t!==-1&&this.cAtIIsEndTag()){s=this.getI();n=s+this._endTag.length;e=this.getExpr().slice(t,s);this.skip(this._endTag.length);break}else{this.trackEnclosedChars();this.skip()}}return e!==undefined?{Match:this.createTemplateKey(e),Key:e,IStartToken:r,IEndToken:n}:undefined}applyReplacementEdits(){return SinglePassTagReplacer.customStringReplacer(this.getExpr(),this._replacementEdits)}}class SimpleTagParser extends TagParser{constructor(e,t={}){super(e,t)}has(){let e=false;this.notifyParseStart();let t=this.parseToken();this.notifyParseComplete(t);return t!==undefined}}class SinglePassTagReplacer extends TagParser{static customStringReplacer(e,t){let s="";let r=0;for(let n=0;n<t.length;n++){const{ReplaceWith:i,IStartToken:o,IEndToken:a}=t[n];s+=e.slice(r,o);s+=i;r=a}s+=e.slice(r);return s}constructor(e,t,s={}){super(e,s);this._cb=t}notifyParseResult(e){const t=e.Match;const s=e.Key;const r=e.IStartToken;e.ReplaceWith=this._cb(this,t,s,r,this.getExpr());this._replacementEdits.push(e)}applyReplacementEdits(){return SinglePassTagReplacer.customStringReplacer(this.getExpr(),this._replacementEdits)}replace(){this.notifyParseStart();let e=this.parseToken();while(e!==undefined){this.notifyParseResult(e);e=this.parseToken()}if(this._curlyBracketStack.length>0)throw new Error(`Match Error - unbalanced symbols missing: ${this._curlyBracketStack.join(",")}`);this.notifyParseComplete(e);return this.applyReplacementEdits()}}class PromisesHandler{static isPromise(e){let t=false;if(e!==null&&typeof e==="object"&&typeof e.then==="function")t=true;return t}constructor(){this._promises=[];this._promiseKeys=[];this._matchedOn=[];this._nextKeyId=0}hasPromises(){return this._promises.length>0}allSettled(){return Promise.allSettled(this._promises)}async processPromises(){let e=undefined;if(this.hasPromises()){e={NResolved:0,NRejected:0};const t=await this.allSettled();for(let s=0;s<t.length;s++){const r=this._promiseKeys[s];const n=t[s];if(n.status==="fulfilled"){e[r]=n.value;e.NResolved++}else if(n.status==="rejected"){e[r]=this._matchedOn[s];e.NRejected++}}}return e}getNextPromiseKey(){const e=`${this._nextKeyId}__@uniquePKey@__${this._nextKeyId}`;this._nextKeyId++;return e}add(e,t){let s=undefined;if(PromisesHandler.isPromise(t)){this._matchedOn.push(e);this._promises.push(t);s=this.getNextPromiseKey();this._promiseKeys.push(s)}return s}}const o=Object.freeze({CovertValueToType:true});class KeyValueContextI{constructor(e){this._keyValues=e}getKeyValues(){return this._keyValues}get(e){return this._keyValues[e]}}class QueryObjKeyValueContextI extends KeyValueContextI{constructor(e,t="."){super(e);this._useSeparator=t}get(e){function arr_deref(e,t,s){const r=t.slice(0,s?-1:t.length);return!t?e:e[r]}function dot_deref(e,t){return!t?e:t.split("[").reduce(arr_deref,e)}try{return e.split(this._useSeparator).reduce(dot_deref,this.getKeyValues())}catch(e){return undefined}}}class StringInterpolator{constructor(e,t,s={}){this._templateStr=e;this._keyValuesI=t instanceof KeyValueContextI?t:new KeyValueContextI(t);this._options=s;this._options.CovertValueToType=this._options.CovertValueToType===undefined?o.CovertValueToType:this._options.CovertValueToType;this._options.ReplaceNotFoundHandler=this._options.ReplaceNotFoundHandler!==undefined?this._options.ReplaceNotFoundHandler:(e,t)=>e}getOptionConvertType(){return this._options.CovertValueToType}getOptionReplaceNotFoundHandler(){return this._options.ReplaceNotFoundHandler}getValueInMap(e){return this._keyValuesI.get(e)}async doReplaces(e,t){let s=undefined;const r=new PromisesHandler;let n=0;const i=new SinglePassTagReplacer(e,((e,n,i,o,a)=>{let c=t.getValueInMap(i.trim());if(c===undefined&&t.canInvokeNotFoundHandler())c=this.getOptionReplaceNotFoundHandler()(n,i);const l=r.add(n,c);if(l!==undefined)c=e.createTemplateKey(l);else if(this.getOptionConvertType()&&n===a)s=c;else{if(c!==null&&typeof c==="object")c=JSON.stringify(c)}return c}),this._options).replace();let o=undefined;const a=await r.processPromises();if(a!==undefined){o=await this.doReplaces(i,{getValueInMap:e=>a[e],canInvokeNotFoundHandler:()=>false})}o=o||(s!==undefined?s:i);return o}async sInterpolate(){let e=this._templateStr;if(typeof e==="string"){e=await this.doReplaces(e,{getValueInMap:e=>this.getValueInMap(e),canInvokeNotFoundHandler:()=>true})}return e}}const a=Object.freeze({ACTION_NONE:Symbol("ACTION_NONE"),ACTION_DELETE:Symbol("ACTION_DELETE"),ACTION_THROW:Symbol("ACTION_THROW"),isValidAction:function(e){let t=false;if(e)t=e===a.ACTION_NONE||e===a.ACTION_DELETE||e===a.ACTION_THROW;return t}});class ActionI{constructor(){this._action=a.ACTION_NONE}getAction(){return this._action}setAction(e){let t=false;if(a.isValidAction(e)){this._action=e;t=true}return t}}const c=Object.freeze({KeyCmdNone:0,KeyCmdCopyIntoObject:1,KeyCmdCopyIntoParentObject:2,KeyCmdDelKey:3,KeyCmdQueueDelChildObjectIfEmpty:4});class ObjectInterpolatorBase{static isKeyCmd(e,t){return e.search(new RegExp(t))!==-1}static containsTemplateVar(e){return e&&typeof e==="string"?new SimpleTagParser(e).has():false}static dupWithoutVars(e){const t={...e};for(const[s,r]of Object.entries(e)){if(ObjectInterpolatorBase.containsTemplateVar(r))delete t[s]}return t}static mergeInto(e,t){if(Array.isArray(e)&&Array.isArray(t)){e.splice(0,e.length,...t)}else{Object.assign(e,t)}}static*iterateObjStrings(e,t=[],s=[]){let r=false;if(e){if(s.length===0){s.push(e);r=true}const n=Array.isArray(e.__ProcessKeys__)?e.__ProcessKeys__:Object.keys(e);for(let r=0;r<n.length;r++){const i=n[r];const o=e[i];if(typeof o==="object"&&o!==null){t.push(i);s.push(o);yield*ObjectInterpolatorBase.iterateObjStrings(o,t,s);t.pop();s.pop()}else if(typeof o==="string"){yield[e,i,o.trim(),t,s];const r=/^__DEBUG__\d*$/;const n=!!i.match(r);if(n){console.log(e[i]);delete e[i]}}}if(r){s.pop()}}}static createPathDotNotation(e,t){return e.length>0?e.join("¤")+"¤"+t:t}static createObjectPath(e){return e.split("¤")}static dup(e){return JSON.parse(JSON.stringify(e))}constructor(e,t,s={}){this._options=s;this._options.CopyObj=this._options.CopyObj!==undefined?this._options.CopyObj:false;this._obj=this.getCopyObj()?ObjectInterpolatorBase.dup(e):e;this._keyValues=t;this._options.ActionOnNotFound=a.isValidAction(this._options.ActionOnNotFound)?this._options.ActionOnNotFound:a.ACTION_NONE;this._options.KeyValueContextI=this._options.KeyValueContextI!==undefined?this._options.KeyValueContextI:KeyValueContextI;this._nPass=2}getObj(){return this._obj}getOptions(){return this._options}getActionOnNotFound(){return this._options.ActionOnNotFound}getOptionKeyValueContextI(){return this._options.KeyValueContextI}getOptionKeyValueContextSeparator(){return this._options.KeyValueContextSeparator||"."}getCopyObj(){return this._options.CopyObj}notifyReplaceNotFound(e,t,s,r,n){let i=t;if(r){const e=r(t,s);if(!n(e))i=e}else n(this.getActionOnNotFound());return i}async doInterpolateKey(e,t,s,r){let n=0;let i=s;for(let t=0;t<this._nPass;t++){const t=new StringInterpolator(i,e,{TrackCurlyBrackets:true,...this._options,ReplaceNotFoundHandler:(t,s)=>this.notifyReplaceNotFound(e,t,s,null,(e=>undefined))});const s=await t.sInterpolate();if(s!==i){n++;i=s}else break}return{nReplacedKeys:n,key:i}}async doInterpolateObj(e,t,s,r){let n=0;let i=r;const o=this._options.ReplaceNotFoundHandler;for(let r=0;r<this._nPass;r++){const r=new ActionI;const c=new StringInterpolator(i,e,{TrackCurlyBrackets:true,...this._options,ReplaceNotFoundHandler:(t,s)=>this.notifyReplaceNotFound(e,t,s,o,(e=>r.setAction(e)))});let l=await c.sInterpolate();if(r.getAction()===a.ACTION_NONE){if(i!==l){t[s]=l;n++;i=l}else break}else if(r.getAction()===a.ACTION_DELETE){delete t[s];break}else if(r.getAction()===a.ACTION_THROW){throw new InterpolationValueNotFoundError}}return n}getCmdInKey(e){let t=c.KeyCmdNone;if(ObjectInterpolatorBase.isKeyCmd(e,i.CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY))t=c.KeyCmdQueueDelChildObjectIfEmpty;else if(ObjectInterpolatorBase.isKeyCmd(e,i.CMD_KEY_COPY_INTO_OBJ))t=c.KeyCmdCopyIntoObject;else if(ObjectInterpolatorBase.isKeyCmd(e,i.CMD_KEY_COPY_INTO_PARENT_OBJ))t=c.KeyCmdCopyIntoParentObject;return t}processDeletes(e){e.forEach((e=>{const t=ObjectInterpolatorBase.createObjectPath(e);let s=this._obj;let r=null;let n="";let i=null;let o="";for(let e=0;e<t.length;e++){if(e===t.length-1){n=o;r=i}o=t[e];i=s;s=s[o]}if(i&&typeof i==="object"){if(o)delete i[o]}if(r&&typeof r==="object"){if(n&&Object.keys(r[n]).length===0){if(Array.isArray(r))r.splice(n,1);else delete r[n]}}}))}addFlattenPaths(e,t){let s=this._obj;let r=[];if(Array.isArray(s))r.push(s);for(let e=0;e<t.length;e++){const n=t[e];s=s[n];if(Array.isArray(s))r.push(s);else r=[]}for(let t=r.length-1;t>=0;t--){const s=r[t];if(!e.has(s))e.add(s)}}createKeyValueContextI(e){return new(this.getOptionKeyValueContextI())(e,this.getOptionKeyValueContextSeparator())}async interpolate(){let e=0;const t=[];let s=false;const r=new Set;const n=new Set;for(const[s,i,o,a,l]of ObjectInterpolatorBase.iterateObjStrings(this._obj)){const u=this.createKeyValueContextI({...this._keyValues,...ObjectInterpolatorBase.dupWithoutVars(s)});const p=await this.doInterpolateKey(u,s,i,o);e+=p.nReplacedKeys;const h=this.getCmdInKey(p.key);if(h===c.KeyCmdNone||h===c.KeyCmdCopyIntoObject||h===c.KeyCmdCopyIntoParentObject){e+=await this.doInterpolateObj(u,s,i,o);if(h===c.KeyCmdCopyIntoObject){const e=s[i];if(typeof e==="object"&&e!==null){Object.assign(s,e);delete s[i]}}else if(h===c.KeyCmdCopyIntoParentObject){const e=l.length>1?l[l.length-2]:null;const o=a.length>0?a[a.length-1]:"";if(e&&o){let c=false;const l=s[i];if(typeof l==="object"&&l!==null){const s=r.has(e[o]);if(s&&Array.isArray(l))e[o].push(...l);else{if(Array.isArray(e)){e[o]=l;if(Array.isArray(l))r.add(e[o])}else{ObjectInterpolatorBase.mergeInto(e,l);t.push(ObjectInterpolatorBase.createPathDotNotation(a,i))}}if(Array.isArray(e)){this.addFlattenPaths(n,a)}}}else throw new Error("No parent object to merge")}else if(p.nReplacedKeys>0){s[p.key]=s[i];delete s[i]}}else if(h===c.KeyCmdQueueDelChildObjectIfEmpty){t.push(ObjectInterpolatorBase.createPathDotNotation(a,i))}}for(const e of n)ObjectInterpolatorBase.mergeInto(e,e.flat());this.processDeletes(t);return{obj:this.getObj(),nReplacedKeys:e}}}class ParseFunctionCalls extends BaseAST{constructor(e,t){super(e);this._options=t;this._options.OptionStringArgQuoted=this._options.OptionStringArgQuoted!==undefined?this._options.OptionStringArgQuoted:false}getOptionStringArgQuoted(){return this._options.OptionStringArgQuoted}skipGroupedChars(){let e=this.cAtI();if(BaseAST.isGroupTokenBegin(e)){let t=[];t.push(e);while(this.hasChars()&&t.length>0){e=t[t.length-1];this.skip();while(this.hasChars()){if(this.cAtIIsGroupTokenEnd(e)){t.pop();break}else{const s=this.cAtI();if(BaseAST.isGroupTokenBegin(s)){e=s;t.push(s);break}}this.skip()}}if(t.length>0)throw new Error(`Parse error - mismatch on some ending symbols: [${t.map((e=>`'${e}'`)).join(",")}]`)}}skipNonSpecialChars(){while(this.hasChars()&&!this.cAtIIsWhite()&&!this.cAtIOIsOpen()&&!this.cAtIOIsClose()&&!this.cAtIIsArgSeporator()){this.skip()}}readToken(){this.skipWhitespace();let e;if(!this.cAtIOIsOpen()&&!this.cAtIOIsClose()){const t=this.getI();this.skipGroupedChars();this.skipNonSpecialChars();const s=this.getI();e=this.getExpr().slice(t,s)}else throw new Error(`Parse error - Unexpected '(' or ')' missing function name`);return e}parseArguments(){let e=[];while(this.hasChars()&&!this.cAtIOIsClose()){e.push(this.parseExpression());this.skipWhitespace();if(this.cAtIIsArgSeporator())this.skip()}return e}parseExpression(){let e=this.readToken();if(/^true|false$/.test(e)){}else if(/^null$/.test(e)){}else if(/^[a-zA-Z_ƒ][\w]*$/.test(e)){this.skipWhitespace();if(this.cAtIOIsOpen()){let t=e;this.skip();let s=this.parseArguments();this.skipWhitespace();if(!this.cAtIOIsClose())throw new Error(`Parse error - Expected '(' after function name ${t}`);this.skip();return{type:"FunctionCall",name:t,arguments:s}}else if(this.getOptionStringArgQuoted())throw new Error(`Parse error - Expected '(' after function name ${e}`);else{e=`'${e}'`}}return{type:"Literal",value:e}}parse(){this.notifyParseStart();const e=this.parseExpression();this.notifyParseComplete(e);return e}}class EvaluateFunctions extends ParseFunctionCalls{static convertNum(e){let t=undefined;if(typeof e==="string"&&e!==""){const s=Number(e);if(!isNaN(s))t=s}return t}static convertString(e){let t=undefined;const s=e.match(/^['"](.*)['"]$/);if(Array.isArray(s)&&s.length===2)t=s[1];return t}static convertBool(e){let t=undefined;const s=e.match(/^(true|false)$/);if(Array.isArray(s)&&s.length===2)t=s[1]==="true";return t}static convertNull(e){let t=undefined;const s=e.match(/^(null)$/);if(Array.isArray(s)&&s.length===2)t=s[1]==="null"?null:undefined;return t}static convertObj(e){let t=undefined;try{t=JSON.parse(e)}catch(e){throw new Error("Failed to convert value to Json object")}return t}static convertToLiteral(e){let t=e;const s=EvaluateFunctions.convertNum(e);if(s!==undefined)t=s;else{const s=EvaluateFunctions.convertString(e);if(s!==undefined)t=s;else{const s=EvaluateFunctions.convertBool(e);if(s!==undefined)t=s;else{const s=EvaluateFunctions.convertNull(e);if(s!==undefined)t=s;else{try{const s=EvaluateFunctions.convertObj(e);if(s!==undefined)t=s}catch(t){if(typeof e==="string")return e;else throw new Error("Invalid type in convertToLiteral")}}}}}return t}static invokeParsedFunction(e,t,s){if(t.type==="Literal")return EvaluateFunctions.convertToLiteral(t.value);else if(t.type==="FunctionCall"){const r=s[t.name];if(typeof r!=="function")throw new Error(`Function ${t.name} is not defined in the context`);const n=t.arguments.map((t=>EvaluateFunctions.invokeParsedFunction(e,t,s)));return r(e,...n)}else{throw new Error("Unknown AST node type")}}constructor(e,t,s,r,n={}){super(t,n);this._parent=e;this._keyValueContext=s;this._fContext=r;this._asTree=null}getParent(){return this._parent}getKeyValueContext(){return this._keyValueContext}parse(){this._asTree=super.parse();const e=EvaluateFunctions.invokeParsedFunction(this,this._asTree,this._fContext);return e}}class ObjectInterpolator extends ObjectInterpolatorBase{static convertToString(e){let t=e;if(typeof e==="number"||typeof e==="bigint"||typeof e==="boolean"||typeof e==="string")t=e.toString();else if(e===null)t="null";else if(e===undefined)t=undefined;else if(Array.isArray(e))t=JSON.stringify(e);else console.error("Failed to convert to primitive type");return t}static processExpression(e){const t=new ExpressionParser(e);return t.evaluate()}static getFunctionExpression(e){let t="";if(e){const s=new RegExp(i.FUNCTION_TAG);const r=s.exec(e);if(Array.isArray(r)&&r.length===2)t=r[1]}return t}constructor(e,t,s,r={}){super(e,t,r);this._parseFContext=s?s:{};this._buildInFContext={"ƒ":(e,t)=>ObjectInterpolator.processExpression(t),Exp:(e,t)=>ObjectInterpolator.processExpression(t),_:(e,t)=>ObjectInterpolator.convertToString(t)}}notifyReplaceNotFound(e,t,s,r,n){const i=ObjectInterpolator.getFunctionExpression(s);if(this._parseFContext&&i){const t=new EvaluateFunctions(this,i,e,{...this._parseFContext,...this._buildInFContext});return t.parse()}else{return super.notifyReplaceNotFound(e,t,s,r,n)}}}var l=t.lw;var u=t.N5;var p=t.$A;var h=t.at;var f=t.g;var d=t._J;var y=t.g8;var g=t.SR;var _=t.PH;export{l as InterpolationValueNotFoundError,u as KeyValueContextI,p as ObjectInterpolator,h as ObjectInterpolatorBase,f as QueryObjKeyValueContextI,d as ReplaceObjectAction,y as SimpleTagParser,g as SinglePassTagReplacer,_ as StringInterpolator};