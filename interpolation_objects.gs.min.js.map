{"version":3,"file":"interpolation_objects.gs.min.js","sources":["../src/expression_parser.js","../src/interpolation_objects.js"],"sourcesContent":["\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// Exceptions\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ExpressionParseError extends Error { constructor(reason){ super(reason); } }\r\n\r\nconst REGX = Object.freeze({\r\n    OPERAND_NUMBERS: '-*\\\\d+(\\\\.\\\\d*)*',\r\n    OPERAND_STRING: \"(?:'|\\\")[^'\\\"]*(?:'|\\\")\",\r\n    OPERAND_LOGICAL_TRUE: 'true',\r\n    OPERAND_LOGICAL_FALSE: 'false',\r\n    OPERAND_POS_INFINITY: 'Infinity',\r\n    OPERAND_NEG_INFINITY: '-Infinity',\r\n    MATH_OPERATORS: '\\\\+|\\\\-|\\\\*|\\\\/|\\\\^|\\\\(|\\\\)',\r\n    TERNARY_OPERATORS: '\\\\?|\\\\:',\r\n    LOGICAL_OPERATORS: '\\\\|\\\\||&&|==|!=|!',\r\n    EQUALITY_OPERATORS: '>=|<=|>|<'\r\n});\r\n\r\n\r\n// --------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Stack implementation\r\n//\r\n// --------------------------------------------------------------------------------------------------------------------\r\nclass Stack {\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    constructor() { this._values = []; }\r\n\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    get size() { return this._values.length; }\r\n    empty() { return this.size === 0; }\r\n    peek() { return this.empty() ? undefined : this._values[this._values.length - 1]; }\r\n\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    push(value) { this._values.push(value); }\r\n    pop() { return this.empty() ? undefined : this._values.pop(); }\r\n    popN(n) {\r\n        const result = [];\r\n        if (this.size >= n) {\r\n            for (let i = 0; i < n; i++)\r\n                result.unshift(this.pop());\r\n        }\r\n        return result;\r\n    }\r\n}\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Working with operators\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// To number\r\n//---------------------------------------------------------------------------------------------------------------------\r\nfunction toNum(s) {\r\n    const result = parseFloat(s);\r\n    if(!isNaN(result))\r\n        return result;\r\n    else\r\n        throw new ExpressionParseError(`Failed to convert ${s} to number`);\r\n}\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// To boolean\r\n//---------------------------------------------------------------------------------------------------------------------\r\nfunction toBool(s) {\r\n    if((s === 'true') || (s === true))\r\n        return true;\r\n    else if((s === 'false') || (s === false))\r\n        return false;\r\n    else\r\n        throw new ExpressionParseError(`Failed to convert ${s} to boolean`);\r\n}\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// To number\r\n//---------------------------------------------------------------------------------------------------------------------\r\nfunction extractStrOperand(s) {\r\n    return s.slice(1, s.length - 1)\r\n\r\n}\r\nfunction toStr(s) {\r\n    function isQuote(char) { return (char === \"'\") || (char === '\"'); }\r\n    let result = s.trim();\r\n    if(result.length > 1) {\r\n        const firstChar = result[0];\r\n        const lastChar = result[result.length - 1];\r\n        if( !isQuote(firstChar) && !isQuote(lastChar))\r\n            throw new ExpressionParseError(`String expression ${s} must be enclosed in single quotes`);\r\n    }\r\n    else\r\n        throw new ExpressionParseError(`Failed to convert ${s} to number`);\r\n\r\n    return result;\r\n}\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// To supported operand\r\n//---------------------------------------------------------------------------------------------------------------------\r\nfunction toOperand(s) {\r\n    try {\r\n        return toNum(s);\r\n    }\r\n    catch(er) {\r\n        try {\r\n            return toBool(s);\r\n        }\r\n        catch(er) {\r\n            return toStr(s);\r\n        }\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// Converts both a and b to expected types\r\n//---------------------------------------------------------------------------------------------------------------------\r\nfunction toTypePair(a, b) {\r\n    const va = toOperand(a);\r\n    const vb = toOperand(b)\r\n    if(typeof va === typeof vb)\r\n        return [va, vb];\r\n    else\r\n        throw new ExpressionParseError(`Cannot operate on parameters with different types ${a} <??> ${b}`);\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Information on all supported operators\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst operatorData = {\r\n    '?': { precedence: 0, associativity: 'R', NArgs: 0, f:function() { throw new ExpressionParseError('Ternary if mismatched'); } },\r\n    ':': { precedence: 0, associativity: 'R', NArgs: 2, f:function() { throw new ExpressionParseError('Ternary else if mismatched'); } },\r\n    '?:': { precedence: 1, associativity: 'R', NArgs: 3, f:function(a, b, c) { return toBool(a) ? toOperand(b) : toOperand(c); } },\r\n    '^': { precedence: 2, associativity: 'R', NArgs: 2, f:function(a, b) { return toNum(a) ** toNum(b); } },\r\n    '+': { precedence: 4, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) + toNum(b); } },\r\n    '-': { precedence: 4, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) - toNum(b); } },\r\n    '*': { precedence: 3, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) * toNum(b); } },\r\n    '/': { precedence: 3, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) / toNum(b); } },\r\n\r\n    '==': { precedence: 7, associativity: 'L', NArgs: 2, f:function(a, b) {\r\n        const [va, vb] = toTypePair(a, b);\r\n        return va === vb;\r\n    } },\r\n    '!=': { precedence: 7, associativity: 'L', NArgs: 2, f:function(a, b) {\r\n        const [va, vb] = toTypePair(a, b);\r\n        return va !== vb;\r\n    } },\r\n    '!': { precedence: 2, associativity: 'R', NArgs: 1, f:function(a) {\r\n        return !toBool(a);\r\n    } },\r\n    '&&': { precedence: 11, associativity: 'L', NArgs: 2, f:function(a, b) { return toBool(a) && toBool(b); } },\r\n    '||': { precedence: 12, associativity: 'L', NArgs: 2, f:function(a, b) { return toBool(a) || toBool(b); } },\r\n    '>=': { precedence: 6, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) >= toNum(b); } },\r\n    '<=': { precedence: 6, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) <= toNum(b); } },\r\n    '>': { precedence: 6, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) > toNum(b); } },\r\n    '<': { precedence: 6, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) < toNum(b); } },\r\n};\r\nconst operatorKeys = Object.keys(operatorData);\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Implementation of Shunting Yard\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass InfixNotationParser {\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression) {\r\n        this._expression = expression;\r\n        this._isOperand =\r\n            new RegExp(`^${REGX.OPERAND_STRING}$|^${REGX.OPERAND_NUMBERS}$|^${REGX.OPERAND_LOGICAL_TRUE}$|^${REGX.OPERAND_LOGICAL_FALSE}$|^${REGX.OPERAND_POS_INFINITY}$|^${REGX.OPERAND_NEG_INFINITY}$`);\r\n\r\n        this._regXParseExpression =\r\n            new RegExp(`${REGX.OPERAND_STRING}|${REGX.OPERAND_LOGICAL_TRUE}|${REGX.OPERAND_LOGICAL_FALSE}|${REGX.OPERAND_POS_INFINITY}|${REGX.OPERAND_NEG_INFINITY}|${REGX.OPERAND_NUMBERS}|${REGX.MATH_OPERATORS}|${REGX.LOGICAL_OPERATORS}|${REGX.EQUALITY_OPERATORS}|${REGX.TERNARY_OPERATORS}`,'g');\r\n    }\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    isOperator(token) { return operatorKeys.includes(token); }\r\n    getOperator(token) { return operatorData[token]; }\r\n    isAssociative(token, type) { return this.getOperator(token).associativity === type; }\r\n    comparePrecedence(op1, op2) { return this.getOperator(op1).precedence - this.getOperator(op2).precedence; }\r\n    hasHigherPrecedence(op1, op2) { return this.comparePrecedence(op1, op2) < 0; }\r\n    hasLowerPrecedence(op1, op2) { return this.comparePrecedence(op1, op2) > 0; }\r\n    hasSamePrecedence(op1, op2) { return this.comparePrecedence(op1, op2) === 0; }\r\n    tokenize() { return this._expression.match(this._regXParseExpression); }\r\n    isOperand(token) { return this._isOperand.test(token); }\r\n\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    toPostfix() {\r\n        const outputQueue = [];\r\n        const tokens = this.tokenize();\r\n\r\n        if(Array.isArray(tokens)) {\r\n            const operatorStack = new Stack();\r\n            tokens.forEach(token => {\r\n                // 1. If the incoming symbols is an operand - push to outputQueue\r\n                if (this.isOperand(token)) {\r\n                    outputQueue.push(token);\r\n                }\r\n                // 2. If the incoming symbol is a left parenthesis, push it on the stack.\r\n                else if (token === '(') {\r\n                    operatorStack.push(token);\r\n                }\r\n                // 3. If the incoming symbol is a right parenthesis: discard the right parenthesis, pop and print the stack\r\n                //    symbols until you see a left parenthesis.\r\n                else if (token === ')') {\r\n                    while (operatorStack.size > 0 && operatorStack.peek() !== '(') {\r\n                        outputQueue.push(operatorStack.pop());\r\n                    }\r\n                    // If there is a left parenthesis - discard it.\r\n                    if ((operatorStack.size > 0) && (operatorStack.peek() === '('))\r\n                        operatorStack.pop();\r\n                    else\r\n                        throw new ExpressionParseError(`Missing open parenthesis in expression`);\r\n                }\r\n                // If the incoming symbol is an operator...\r\n                else if (this.isOperator(token)) {\r\n                    let topOperatorStack = operatorStack.peek();\r\n\r\n                    // 4. If the stack is empty or contains a left parenthesis on top or the incoming symbol is a ternary\r\n                    //    begin if\r\n                    if (operatorStack.empty() || (topOperatorStack === \"(\") || token === \"?\") {\r\n                        operatorStack.push(token);\r\n                    }\r\n                    // 5. Handle possible ternary operator\r\n                    else if(token === ':') {\r\n                        // Both ternary if (\"?\") and else (\":\") will never appear in the output.  The goal is to reverse\r\n                        // these symbols to RPN format: 'true a b ?:' or 'false a b ?:'.  The rule therefore is, when\r\n                        // finding the else branch (\":\") of the ternary operator, we pop inclusively to the start if\r\n                        // symbol (\"?\"), this goes to the output, then we follow this with the ending RPN ternary\r\n                        // operator \"?:\"\r\n                        // see also https://stackoverflow.com/questions/35609168/extending-the-shunting-yard-algorithm-to-support-the-conditional-ternary-operato\r\n                        // which goes over this in an example:\r\n                        // * \"?\" ternary-open-if\r\n                        // * \":\" ternary-else\r\n                        // * \"?:\" ternary-closed-if (note this is a dummy symbol, could be anything).  If this symbol is needed in your expression you should\r\n                        // update this parser and set it to a different unused symbol.\r\n                        let poppedSymbol = null;\r\n                        while(!operatorStack.empty()) {\r\n                            poppedSymbol = operatorStack.pop();\r\n                            if(poppedSymbol === '?') {\r\n                                operatorStack.push('?:');\r\n                                break;\r\n                            }\r\n                            else\r\n                                outputQueue.push(poppedSymbol);\r\n                        }\r\n                        if(poppedSymbol !== \"?\")\r\n                            throw new ExpressionParseError('Missing ternary ? symbol');\r\n                    }\r\n                    // 6. If the incoming operator has either higher precedence than the operator on the top of the stack,\r\n                    //    or has the same precedence as the operator on the top of the stack and is right associative\r\n                    else if ((this.hasHigherPrecedence(token, topOperatorStack)) ||\r\n                        (this.hasSamePrecedence(token, topOperatorStack) && this.isAssociative(token, 'R'))) {\r\n                        operatorStack.push(token);\r\n                    } else {\r\n                        // 7. If the incoming operator has either lower precedence than the operator on the top of the stack,\r\n                        //    or has the same precedence as the operator on the top of the stack and is left associative\r\n                        //      -- continue to pop the stack until this is not true. Then, push the incoming operator.\r\n                        while (topOperatorStack && (topOperatorStack !== '(') && (this.hasLowerPrecedence(token, topOperatorStack) ||\r\n                            (this.hasSamePrecedence(token, topOperatorStack) && this.isAssociative(token, 'L')))) {\r\n                            outputQueue.push(operatorStack.pop());\r\n                            topOperatorStack = operatorStack.peek();\r\n                        }\r\n                        operatorStack.push(token);\r\n                    }\r\n                }\r\n            });\r\n\r\n            // Last push any remaining symbols to the outputQueue\r\n            while (operatorStack.size > 0) {\r\n                const operator = operatorStack.pop()\r\n                if (operator !== '(')\r\n                    outputQueue.push(operator);\r\n                else\r\n                    throw new ExpressionParseError(`Missing closing parenthesis in expression`);\r\n            }\r\n        }\r\n        else\r\n            throw new ExpressionParseError('Parsing expression resulted in an empty parse');\r\n\r\n        return outputQueue;\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Parse and evaluate passed in expression\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ExpressionParser extends InfixNotationParser {\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression) {\r\n        super(expression);\r\n    }\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    evaluate() {\r\n        const postFix = this.toPostfix();\r\n        const stack = new Stack();\r\n        for(let i = 0; i < postFix.length; i++) {\r\n            const token = postFix[i];\r\n            if(this.isOperator(token)) {\r\n                const operator = this.getOperator(token);\r\n                if(stack.size >= operator.NArgs) {\r\n                    const args = stack.popN(operator.NArgs);\r\n                    const result = operator.f(...args);\r\n                    stack.push(result);\r\n                }\r\n                else\r\n                    throw new ExpressionParseError(`Not enough args for operator ${token}`)\r\n            }\r\n            else\r\n                stack.push(token);\r\n        }\r\n        if(stack.size === 1) {\r\n            let result = toOperand(stack.pop());\r\n\r\n            // If the type is a string remove single quotes\r\n            if(typeof result === 'string')\r\n                result = extractStrOperand(result);\r\n            return result;\r\n\r\n        }\r\n        else\r\n            throw new ExpressionParseError(`Resulting stack appears incorrect with size ${stack.size}`);\r\n    }\r\n}\r\nexport { ExpressionParser, ExpressionParseError};\r\n","import {ExpressionParser} from \"./expression_parser.js\"\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst REGX = Object.freeze({\r\n    FUNCTION_TAG: '^\\\\s*->\\\\s*(.*)',\r\n    CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY: '^(<-\\\\s*false\\\\s*)|(<--\\\\s*false\\\\s*)$',\r\n    CMD_KEY_COPY_INTO_OBJ: '^(<-\\\\s*true\\\\s*)|(<-\\\\s*)$',\r\n    CMD_KEY_COPY_INTO_PARENT_OBJ: '^(<--\\\\s*true\\\\s*)|(<--\\\\s*)$',\r\n\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// Exceptions\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass InterpolationValueNotFoundError extends Error { constructor(){ super(\"Interpolation value not Found\"); } }\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Base class for a generic parser like an Abstract Syntax Tree or any simple parser requiring simple character scanning\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass BaseAST {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static isWhitespace(char) { return /\\s/.test(char); }\r\n    static isOpen(char) { return char === '('; }\r\n    static isClose(char) { return char === ')'; }\r\n    static isCurlyOpen(char) { return char === '{'; }\r\n    static isCurlyClose(char) { return char === '}'; }\r\n    static isArgSeparate(char) { return char === ','; }\r\n    static isSquareOpen(char) { return char === '['; }\r\n    static isSquareClose(char) { return char === ']'; }\r\n    static isGroupTokenBegin(char) { return (char === \"'\") || (char === '\"') || (char === '[') || (char === '{'); }\r\n    static isMatchingGroupTokenEnd(beginChar, char) {\r\n        if(beginChar === \"'\")\r\n            return char === \"'\";\r\n        else if(beginChar === '\"')\r\n            return char === '\"';\r\n        else if(beginChar === '[')\r\n            return char === ']';\r\n        else if(beginChar === '{')\r\n            return char === '}';\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression) {\r\n        this._expression = expression;\r\n        this._index = 0;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyParseStart() { this._index = 0; }\r\n    notifyParseComplete(parseResult) {}\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Basic character functions - non consuming\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getI() { return this._index; }\r\n    getExpr() { return this._expression; }\r\n    cAtI(n = 0) { return this.getExpr()[this._index + n]; }\r\n    cAtIIsWhite() { return BaseAST.isWhitespace(this.cAtI()); }\r\n    skip(n=1) { return this._index += n; }\r\n    hasChars(nChars = 1) { return (this.getExpr().length - this._index) >= nChars; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Useful character functions for specific cases\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisCurlyOpen() { return BaseAST.isCurlyOpen(this.cAtI()); }\r\n    cAtIisCurlyClose() { return BaseAST.isCurlyClose(this.cAtI()); }\r\n    cAtIOIsOpen() { return BaseAST.isOpen(this.cAtI()); }\r\n    cAtIOIsClose() { return BaseAST.isClose(this.cAtI()); }\r\n    cAtIIsArgSeporator() { return BaseAST.isArgSeparate(this.cAtI())}\r\n    cAtIIsGroupTokenEnd(beginChar) { return BaseAST.isMatchingGroupTokenEnd(beginChar, this.cAtI()); }\r\n    cAtIIsTag(tag) {\r\n        let hasTag = false;\r\n        const tagLen = tag.length;\r\n        if(this.hasChars(tagLen)) {\r\n            let nFoundSymbols = 0;\r\n            for(let i = 0; i < tag.length; i++) {\r\n                if(this.cAtI(i) === tag[i])\r\n                    nFoundSymbols++;\r\n            }\r\n            hasTag = (nFoundSymbols === tagLen)\r\n        }\r\n        return hasTag;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Consuming\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipWhitespace() {\r\n        while (this.hasChars() && this.cAtIIsWhite())\r\n            this.skip();\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass TagParser extends BaseAST {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options = {}) {\r\n        super(expression);\r\n\r\n        this._options = options;\r\n        this._startTag = \"{{\";\r\n        this._endTag = \"}}\"\r\n        this._ignoreEnclosed = { Opens: [\"{\"], Closes: [\"}\"] }\r\n        this._curlyBracketStack = [];\r\n        this._replacementEdits = []\r\n        this._options.TrackCurlyBrackets = this._options.TrackCurlyBrackets !== undefined ?\r\n            this._options.TrackCurlyBrackets : false;\r\n    }\r\n    getTrackCurlyBrackets() { return this._options.TrackCurlyBrackets; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    createTemplateKey(key) { return `${this._startTag}${key}${this._endTag}`; }\r\n    cAtIIsBeginTag() { return this.cAtIIsTag(this._startTag); }\r\n    cAtIIsEndTag() {\r\n        let isTag = false;\r\n        if(this._curlyBracketStack.length === 0)\r\n            isTag = this.cAtIIsTag(this._endTag);\r\n        return isTag;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisOpen() {\r\n        let closing = undefined;\r\n        const indexOfOpen = this._ignoreEnclosed.Opens.indexOf(this.cAtI());\r\n        if(indexOfOpen !== -1)\r\n            closing = this._ignoreEnclosed.Closes[indexOfOpen];\r\n\r\n\r\n        return closing;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisClosing() {\r\n        let matchedClosing = false;\r\n        if(this._curlyBracketStack.length > 0) {\r\n            const lastClosing = this._curlyBracketStack[this._curlyBracketStack.length - 1];\r\n            if(this.cAtI() === lastClosing)\r\n                matchedClosing = true;\r\n        }\r\n        return matchedClosing;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    trackEnclosedChars() {\r\n        // In the cases where we have not identified a start or end token, track curly brackets.\r\n        if(this.getTrackCurlyBrackets()) {\r\n            const closingChar = this.cAtIisOpen();\r\n            if (closingChar !== undefined)\r\n                this._curlyBracketStack.push(closingChar);\r\n            else if (this.cAtIisClosing()) {\r\n                this._curlyBracketStack.pop();\r\n            }\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseToken() {\r\n        // {{A  {{B}} }}\r\n        let token = undefined;\r\n        let start = -1; let end = -1;\r\n        let iStartToken = -1; let iEndToken = -1;\r\n        while (this.hasChars()) {\r\n            if (this.cAtIIsBeginTag()) {\r\n                iStartToken = this.getI();\r\n                this.skip(this._startTag.length);\r\n                start = this.getI();\r\n            }\r\n            else if ((start !== -1) && this.cAtIIsEndTag()) {\r\n                end = this.getI();\r\n                iEndToken = end +  this._endTag.length;\r\n\r\n                // slice out our token\r\n                token = this.getExpr().slice(start, end);\r\n\r\n                this.skip(this._endTag.length);\r\n                break;\r\n            }\r\n            else {\r\n                this.trackEnclosedChars();\r\n                this.skip();\r\n            }\r\n        }\r\n        return token !== undefined ? {\r\n            Match: this.createTemplateKey(token),\r\n            Key: token,\r\n            IStartToken: iStartToken,\r\n            IEndToken: iEndToken\r\n        } : undefined;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    applyReplacementEdits() {\r\n        return SinglePassTagReplacer.customStringReplacer(this.getExpr(), this._replacementEdits);\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass SimpleTagParser extends TagParser {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options = {}) {\r\n        super(expression, options);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    has() {\r\n        let found = false;\r\n        this.notifyParseStart();\r\n        let matchResultObj = this.parseToken();\r\n        this.notifyParseComplete(matchResultObj);\r\n        return matchResultObj !== undefined;\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass SinglePassTagReplacer extends TagParser {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static customStringReplacer(expression, replacementEdits) {\r\n        // Note: edits are already sorted from left to right\r\n\r\n        // Iterate over the replacementEdits\r\n        let result = '';\r\n        let lastIndex = 0;\r\n\r\n        for (let i = 0; i < replacementEdits.length; i++) {\r\n            const { ReplaceWith, IStartToken, IEndToken } = replacementEdits[i];\r\n\r\n            // Add the existing part of the string before the start token\r\n            result += expression.slice(lastIndex, IStartToken);\r\n\r\n            // Add the new string (key)\r\n            result += ReplaceWith;\r\n\r\n            // Update the lastIndex to be after the end token\r\n            lastIndex = IEndToken;\r\n        }\r\n\r\n        // Add any remaining part of the original string after the last change\r\n        result += expression.slice(lastIndex);\r\n\r\n        return result;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, cb, options = {}) {\r\n        super(expression, options);\r\n        this._cb = cb;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyParseResult(matchResultObj) {\r\n        const match = matchResultObj.Match;\r\n        const key = matchResultObj.Key;\r\n        const offset = matchResultObj.IStartToken;\r\n\r\n        matchResultObj.ReplaceWith = this._cb(this, match, key, offset, this.getExpr());\r\n        this._replacementEdits.push(matchResultObj);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    applyReplacementEdits() {\r\n        return SinglePassTagReplacer.customStringReplacer(this.getExpr(), this._replacementEdits);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    replace() {\r\n        this.notifyParseStart();\r\n        let matchResultObj = this.parseToken();\r\n        while(matchResultObj !== undefined) {\r\n            this.notifyParseResult(matchResultObj);\r\n            matchResultObj = this.parseToken();\r\n        }\r\n        if(this._curlyBracketStack.length > 0)\r\n            throw new Error(`Match Error - unbalanced symbols missing: ${this._curlyBracketStack.join(',')}`);\r\n        this.notifyParseComplete(matchResultObj);\r\n        return this.applyReplacementEdits();\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass PromisesHandler {\r\n    static isPromise(p) {\r\n        let result = false;\r\n        if ((p !== null) && (typeof p === 'object') && typeof p.then === 'function')\r\n            result = true;\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor() {\r\n        this._promises = [];\r\n        this._promiseKeys = [];\r\n        this._matchedOn = []\r\n\r\n        this._nextKeyId = 0;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    hasPromises() { return this._promises.length > 0; }\r\n    allSettled() { return Promise.allSettled(this._promises); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async processPromises() {\r\n        let replaceKeys = undefined;\r\n        if (this.hasPromises()) {\r\n            replaceKeys = {NResolved: 0, NRejected: 0};\r\n            const results = await this.allSettled();\r\n            for (let i = 0; i < results.length; i++) {\r\n                const promiseKey = this._promiseKeys[i];\r\n                const pResult = results[i];\r\n                if(pResult.status === 'fulfilled') {\r\n                    replaceKeys[promiseKey] = pResult.value;\r\n                    replaceKeys.NResolved++;\r\n                }\r\n                else if(pResult.status === 'rejected') {\r\n                    replaceKeys[promiseKey] = this._matchedOn[i];\r\n                    replaceKeys.NRejected++;\r\n                }\r\n            }\r\n        }\r\n        return replaceKeys;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getNextPromiseKey() {\r\n        const key  = `${this._nextKeyId}__@uniquePKey@__${this._nextKeyId}`;\r\n        this._nextKeyId++;\r\n        return key;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    add(matchedOn, pCandidate) {\r\n        let addedKey = undefined;\r\n        if(PromisesHandler.isPromise(pCandidate)) {\r\n            this._matchedOn.push(matchedOn);\r\n            this._promises.push(pCandidate);\r\n            addedKey = this.getNextPromiseKey();\r\n            this._promiseKeys.push(addedKey);\r\n        }\r\n        return addedKey;\r\n    }\r\n}\r\nconst defaultOptions = Object.freeze({\r\n    CovertValueToType: true,\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Context for key values allows lookup by simple key.  This is the Base Interface for getting a value based on a key\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass KeyValueContextI {\r\n    constructor(keyValues) {\r\n        this._keyValues = keyValues;\r\n    }\r\n    getKeyValues() { return this._keyValues; }\r\n    get(key) { return this._keyValues[key]; }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Context for key values allows lookup by a query string.\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass QueryObjKeyValueContextI extends KeyValueContextI {\r\n    constructor(keyValues, useSeparator = \".\") {\r\n        super(keyValues);\r\n        this._useSeparator = useSeparator;\r\n    }\r\n    get(q) {\r\n         function arr_deref(o, ref, i) {\r\n            const key = ref.slice(0, i ? -1 : ref.length);\r\n            return !ref ? o : (o[key]);\r\n        }\r\n        function dot_deref(o, ref) {\r\n            return !ref ? o : ref.split('[').reduce(arr_deref, o);\r\n        }\r\n        try {\r\n            return q.split(this._useSeparator).reduce(dot_deref, this.getKeyValues());\r\n        }\r\n        catch(err) { return undefined; }\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass StringInterpolator {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(templateStr, keyValuesI, options = {}) {\r\n        this._templateStr = templateStr;\r\n\r\n        this._keyValuesI = (keyValuesI instanceof KeyValueContextI) ?\r\n            keyValuesI : new KeyValueContextI(keyValuesI);\r\n\r\n        this._options = options;\r\n\r\n        this._options.CovertValueToType = this._options.CovertValueToType === undefined ?\r\n            defaultOptions.CovertValueToType : this._options.CovertValueToType;\r\n\r\n        this._options.ReplaceNotFoundHandler =\r\n            this._options.ReplaceNotFoundHandler !== undefined ? this._options.ReplaceNotFoundHandler : (templateVar, key) => { return templateVar };\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getOptionConvertType() { return this._options.CovertValueToType; }\r\n    getOptionReplaceNotFoundHandler() { return this._options.ReplaceNotFoundHandler; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getValueInMap(key) { return this._keyValuesI.get(key); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doReplaces(templateStr, options) {\r\n        let simpleReplace = undefined;\r\n        const promisesHandler = new PromisesHandler();\r\n\r\n        // Replace string with found key\r\n        let nReplaces = 0;\r\n        const replace = (new SinglePassTagReplacer(templateStr,\r\n            (sender, match, key, offset, string) => {\r\n\r\n                let replaceCandidate = options.getValueInMap(key.trim());\r\n                if((replaceCandidate === undefined) && options.canInvokeNotFoundHandler())\r\n                    replaceCandidate = this.getOptionReplaceNotFoundHandler()(match, key);\r\n\r\n                // If there are promises to resolve, replace the token with our promise key\r\n                const promiseKey = promisesHandler.add(match, replaceCandidate);\r\n                if(promiseKey !== undefined)\r\n                    replaceCandidate = sender.createTemplateKey(promiseKey);\r\n                else if(this.getOptionConvertType() && (match === string))\r\n                    simpleReplace = replaceCandidate;\r\n                else {\r\n                    if((replaceCandidate !== null) && (typeof replaceCandidate === 'object'))\r\n                        replaceCandidate = JSON.stringify(replaceCandidate)\r\n                }\r\n\r\n                return replaceCandidate;\r\n\r\n        }, this._options)).replace();\r\n        let resultingS = undefined;\r\n        const promiseReplaceKeys = await promisesHandler.processPromises();\r\n        if(promiseReplaceKeys !== undefined) {\r\n            resultingS = await this.doReplaces(replace, {\r\n                getValueInMap: (key) =>  promiseReplaceKeys[key],\r\n                canInvokeNotFoundHandler: () => false\r\n            });\r\n        }\r\n\r\n        resultingS = resultingS || (simpleReplace !== undefined ? simpleReplace : replace);\r\n        return resultingS;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async sInterpolate() {\r\n        let resultingS = this._templateStr;\r\n\r\n        if (typeof resultingS === 'string') {\r\n            resultingS = await this.doReplaces(resultingS, {\r\n                getValueInMap: (key) =>  this.getValueInMap(key),\r\n                canInvokeNotFoundHandler: () => true\r\n            });\r\n        }\r\n\r\n        return resultingS;\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst ReplaceObjectAction = Object.freeze({\r\n    ACTION_NONE: Symbol(\"ACTION_NONE\"),\r\n    ACTION_DELETE: Symbol(\"ACTION_DELETE\"),\r\n    ACTION_THROW: Symbol(\"ACTION_THROW\"),\r\n    isValidAction: function (action) {\r\n        let isValid = false;\r\n        if(action)\r\n            isValid = (action === ReplaceObjectAction.ACTION_NONE) ||\r\n                (action === ReplaceObjectAction.ACTION_DELETE) ||\r\n                (action === ReplaceObjectAction.ACTION_THROW);\r\n        return isValid;\r\n    }\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ActionI {\r\n    constructor() {\r\n        this._action = ReplaceObjectAction.ACTION_NONE;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getAction() { return this._action; }\r\n    setAction(newActionValue) {\r\n        let actionSet = false;\r\n        if(ReplaceObjectAction.isValidAction(newActionValue)) {\r\n            this._action = newActionValue;\r\n\r\n            actionSet = true;\r\n        }\r\n\r\n        return actionSet;\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst KeyCommands = Object.freeze({\r\n    KeyCmdNone: 0,\r\n    KeyCmdCopyIntoObject: 1,\r\n    KeyCmdCopyIntoParentObject: 2,\r\n    KeyCmdDelKey: 3,\r\n    KeyCmdQueueDelChildObjectIfEmpty: 4\r\n});\r\n\r\nclass ObjectInterpolatorBase  {\r\n    static isKeyCmd(key, cmd) { return key.search(new RegExp(cmd)) !== -1; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static containsTemplateVar(templateString) {\r\n        return (templateString && typeof templateString === 'string') ?\r\n            ((new SimpleTagParser(templateString)).has()) : false;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static dupWithoutVars(childObj) {\r\n        const obj = {...childObj};\r\n        for (const [key, value] of Object.entries(childObj)) {\r\n            // we should remove any variable which has a template variable\r\n            if (ObjectInterpolatorBase.containsTemplateVar(value))\r\n                delete obj[key];\r\n        }\r\n        return obj;\r\n    }\r\n    static mergeInto(target, source) {\r\n        if(Array.isArray(target) && Array.isArray((source))) {\r\n            target.splice(0, target.length, ...source);\r\n        }\r\n        else {\r\n            Object.assign(target, source);\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // {A:{a:1,b:2, c:{d:4}}\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static *iterateObjStrings(obj, keys = [], objs= []) {\r\n        let isRoot = false;\r\n        if(obj) {\r\n\r\n            // push the root object\r\n            if(objs.length === 0) { objs.push(obj); isRoot = true; }\r\n\r\n\r\n            const useKeys = Array.isArray(obj.__ProcessKeys__) ? obj.__ProcessKeys__ : Object.keys(obj);\r\n            for(let i = 0; i < useKeys.length; i++) {\r\n                const key = useKeys[i]; const value = obj[key];\r\n\r\n                if ((typeof value === 'object') && (value !== null)) {\r\n                    keys.push(key); objs.push(value);\r\n                    yield* ObjectInterpolatorBase.iterateObjStrings(value, keys, objs );\r\n                    keys.pop();  objs.pop();\r\n                }\r\n                else if (typeof value === 'string') {\r\n                    yield [obj, key, value.trim(), keys, objs];\r\n                    const regex = /^__DEBUG__\\d*$/;\r\n                    const isDebugPrint = !!key.match(regex);\r\n                    if (isDebugPrint) {\r\n                        console.log(obj[key]);\r\n                        delete obj[key];\r\n                    }\r\n                }\r\n            }\r\n\r\n            // pop the root object\r\n            if(isRoot) { objs.pop(); }\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static createPathDotNotation(keys, key) { return keys.length > 0 ? keys.join(\"¤\") + \"¤\" + key : key; }\r\n    static createObjectPath(pathDotNotation) { return pathDotNotation.split(\"¤\"); }\r\n    static dup(obj) { return JSON.parse(JSON.stringify(obj)); }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(obj, keyValues, options = {}) {\r\n        this._options = options;\r\n        this._options.CopyObj = this._options.CopyObj !== undefined ? this._options.CopyObj : false\r\n\r\n        this._obj = this.getCopyObj() ? ObjectInterpolatorBase.dup(obj) : obj;\r\n        this._keyValues = keyValues;\r\n\r\n        this._options.ActionOnNotFound = ReplaceObjectAction.isValidAction(this._options.ActionOnNotFound) ?\r\n            this._options.ActionOnNotFound : ReplaceObjectAction.ACTION_NONE;\r\n\r\n        this._options.KeyValueContextI = this._options.KeyValueContextI !== undefined ?\r\n            this._options.KeyValueContextI : KeyValueContextI;\r\n\r\n        this._nPass = 2;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getObj() { return this._obj; }\r\n    getOptions() { return this._options; }\r\n    getActionOnNotFound() { return this._options.ActionOnNotFound; }\r\n    getOptionKeyValueContextI() { return this._options.KeyValueContextI; }\r\n    getOptionKeyValueContextSeparator() { return this._options.KeyValueContextSeparator || \".\"; }\r\n    getCopyObj() { return this._options.CopyObj; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // There are two possible return values, either:\r\n    // 1. The not found template var, as in \"{{var}}\".\r\n    // 2. The value returned by the handler (as long as the return value is not an action to delete the key).\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI) {\r\n        let useValue = templateVar;\r\n        if(parentReplaceNotFoundHandler) {\r\n            // If the value returned by the handler is not an action, we can use the value the handler has sent us\r\n            const actionOrValue = parentReplaceNotFoundHandler(templateVar, key);\r\n            if(!setActionI(actionOrValue))\r\n                useValue = actionOrValue;\r\n        }\r\n        else\r\n            setActionI(this.getActionOnNotFound());\r\n\r\n        return useValue;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Keys can hold replacement parameters, which act as commands\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doInterpolateKey(replaceKeyValues, childObj, key, value){\r\n        let nReplacedKeys = 0;\r\n        let useValue = key;\r\n\r\n        for(let i = 0; i < this._nPass; i++) {\r\n            const stringInterpolator = new StringInterpolator(useValue, replaceKeyValues, {\r\n                TrackCurlyBrackets: true, ...this._options,\r\n                ReplaceNotFoundHandler:  (templateVar, key) => {\r\n                    // Return the value to be used as the replace parameter.  Note the caller may set the action,\r\n                    // which may result in this key being deleted on the object (see code below, where we test the\r\n                    // action against the delete value\r\n                    return this.notifyReplaceNotFound(replaceKeyValues, templateVar, key, null,\r\n                        (newActionValue) => undefined);\r\n                }\r\n            });\r\n\r\n            const nextReplace = await stringInterpolator.sInterpolate();\r\n            if (nextReplace !== useValue) {\r\n                nReplacedKeys++;\r\n                useValue = nextReplace;\r\n            } else\r\n                break;\r\n        }\r\n\r\n        return { nReplacedKeys: nReplacedKeys, key: useValue };\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doInterpolateObj(replaceKeyValues, childObj, key, value){\r\n        let nReplacedKeys = 0;\r\n        let useValue = value;\r\n        const parentReplaceNotFoundHandler = this._options.ReplaceNotFoundHandler;\r\n        for(let i = 0; i < this._nPass; i++) {\r\n\r\n            // 'action' interface for setting local variable 'action'.  This code is kind of confusing, but,\r\n            // there is a reason for the complexity.  When we call interpolation on the string, the\r\n            // 'StringInterpolator' object, may invoke our handler to inform us it is not able to find a key.\r\n            // There are essentially three possible actions:\r\n            //   1. Do nothing, that is keep the un-replaced templateVar (we do this by returning the templateVar)\r\n            //   2. Return something that we do want to use, a common use case is to return an empty string (for example).\r\n            //   3. Delete the key from the object.  For this action, the client may return a special value to indicate\r\n            //      that we should delete the key.  The problem is we process this return value inside the handler.\r\n            //      To make this work, we check the value in our handler and set the action, which will be used,\r\n            //      later when the handler returns.\r\n            const actionI = new ActionI();\r\n\r\n            const stringInterpolator = new StringInterpolator(useValue, replaceKeyValues, {\r\n                TrackCurlyBrackets: true, ...this._options,\r\n                ReplaceNotFoundHandler:  (templateVar, key) => {\r\n                    // Return the value to be used as the replace parameter.  Note the caller may set the action,\r\n                    // which may result in this key being deleted on the object (see code below, where we test the\r\n                    // action against the delete value\r\n                    return this.notifyReplaceNotFound(replaceKeyValues, templateVar, key, parentReplaceNotFoundHandler,\r\n                        (newActionValue) => actionI.setAction(newActionValue));\r\n                }\r\n            });\r\n\r\n            let replace = await stringInterpolator.sInterpolate();\r\n            if(actionI.getAction() === ReplaceObjectAction.ACTION_NONE) {\r\n                if (useValue!== replace) {\r\n                    childObj[key] = replace;\r\n                    nReplacedKeys++;\r\n                    useValue = replace;\r\n                } else\r\n                    break;\r\n            }\r\n            else if(actionI.getAction() === ReplaceObjectAction.ACTION_DELETE) {\r\n                delete childObj[key];\r\n                break;\r\n            }\r\n            else if(actionI.getAction() === ReplaceObjectAction.ACTION_THROW) {\r\n                throw new InterpolationValueNotFoundError();\r\n            }\r\n        }\r\n\r\n        return nReplacedKeys;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getCmdInKey(key) {\r\n        let cmd = KeyCommands.KeyCmdNone;\r\n        if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY))\r\n            cmd = KeyCommands.KeyCmdQueueDelChildObjectIfEmpty\r\n        else if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_COPY_INTO_OBJ))\r\n            cmd = KeyCommands.KeyCmdCopyIntoObject;\r\n        else if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_COPY_INTO_PARENT_OBJ))\r\n            cmd = KeyCommands.KeyCmdCopyIntoParentObject;\r\n\r\n        return cmd;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    processDeletes(queuedDeletes) {\r\n        queuedDeletes.forEach( (pathDotNotation) => {\r\n            const path = ObjectInterpolatorBase.createObjectPath(pathDotNotation);\r\n            let itObj = this._obj;\r\n            let ownerObj = null;\r\n            let parentKey = \"\";\r\n            let parentObj = null;\r\n            let childKey = \"\";\r\n            for(let i = 0; i < path.length; i++) {\r\n                if(i === path.length - 1) {\r\n                    parentKey = childKey;\r\n                    ownerObj = parentObj;\r\n                }\r\n                childKey = path[i];\r\n                parentObj = itObj;\r\n                itObj = itObj[childKey];\r\n\r\n            }\r\n            if(parentObj && typeof parentObj === 'object') {\r\n                if(childKey)\r\n                    delete parentObj[childKey];\r\n            }\r\n            if(ownerObj && typeof ownerObj === 'object') {\r\n                if(parentKey && Object.keys(ownerObj[parentKey]).length === 0) {\r\n                    if(Array.isArray(ownerObj))\r\n                        ownerObj.splice(parentKey, 1);\r\n                    else\r\n                        delete ownerObj[parentKey];\r\n                }\r\n\r\n            }\r\n\r\n        });\r\n    }\r\n    addFlattenPaths(flattenPaths, keys) {\r\n        let currentObj = this._obj;\r\n        let flattenObjs = [];\r\n        if(Array.isArray(currentObj))\r\n                flattenObjs.push(currentObj);\r\n        for(let i = 0; i < keys.length; i++) {\r\n            const key = keys[i];\r\n            currentObj = currentObj[key];\r\n            if(Array.isArray(currentObj))\r\n                flattenObjs.push(currentObj);\r\n            else\r\n                flattenObjs = [];\r\n\r\n        }\r\n        for(let i = flattenObjs.length - 1; i >= 0; i--) {\r\n            const flattenObj = flattenObjs[i];\r\n            if(!flattenPaths.has(flattenObj))\r\n                flattenPaths.add(flattenObj);\r\n        }\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // return the interface which knows how to index into our object\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    createKeyValueContextI(keyValues) { return new (this.getOptionKeyValueContextI())(keyValues, this.getOptionKeyValueContextSeparator()); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async interpolate() {\r\n        let nReplacedKeys = 0;\r\n\r\n        const queuedDeletes = [];\r\n        let flattenRoot = false;\r\n        const trackParentSetObjects = new Set();\r\n        const flattenPaths = new Set();\r\n        for (const [childObj, key, value, keys, objs] of ObjectInterpolatorBase.iterateObjStrings(this._obj)) {\r\n\r\n            // Imagine a nested object - where we may have parameters to replace and where the childObj has some keys\r\n            // which may be used as replacement parameters\r\n            const replaceKeyValues =\r\n                this.createKeyValueContextI({ ...this._keyValues, ...ObjectInterpolatorBase.dupWithoutVars(childObj) });\r\n\r\n            const keyReplaceResult = await this.doInterpolateKey(replaceKeyValues, childObj, key, value);\r\n            nReplacedKeys += keyReplaceResult.nReplacedKeys;\r\n            const cmd = this.getCmdInKey(keyReplaceResult.key);\r\n            if((cmd === KeyCommands.KeyCmdNone) ||\r\n                    (cmd === KeyCommands.KeyCmdCopyIntoObject) ||\r\n                    (cmd === KeyCommands.KeyCmdCopyIntoParentObject)) {\r\n\r\n                nReplacedKeys += await this.doInterpolateObj(replaceKeyValues, childObj, key, value);\r\n\r\n                if (cmd === KeyCommands.KeyCmdCopyIntoObject) {\r\n                    const objCandidate = childObj[key];\r\n                    if ((typeof objCandidate === 'object') && (objCandidate !== null)) {\r\n                        Object.assign(childObj, objCandidate);\r\n                        delete childObj[key];\r\n                    }\r\n                }\r\n                else if(cmd === KeyCommands.KeyCmdCopyIntoParentObject) {\r\n                    // The parent object and the parent key can be found by looking at the objs/keys\r\n                    // (which tracks all iterated objects)\r\n                    const parentObj = objs.length > 1 ? objs[objs.length - 2] : null;\r\n                    const parentKey = keys.length > 0 ? keys[keys.length - 1] : \"\";\r\n\r\n                    if(parentObj && parentKey) {\r\n                        let wasSetOn = false;\r\n                        const objCandidate = childObj[key];\r\n                        if ((typeof objCandidate === 'object') && (objCandidate !== null)) {\r\n\r\n                            // Consider the case where we want to load multiple objects to the same element position on\r\n                            // the parent.  (reference Test case **).  This case is when the parentObj is an array\r\n                            const wasPreviouslySetOn = trackParentSetObjects.has(parentObj[parentKey]);\r\n                            if(wasPreviouslySetOn && Array.isArray(objCandidate))\r\n                                parentObj[parentKey].push(...objCandidate);\r\n                            else {\r\n                                if(Array.isArray(parentObj)) {\r\n                                    parentObj[parentKey] = objCandidate;\r\n                                    if(Array.isArray(objCandidate))\r\n                                        trackParentSetObjects.add(parentObj[parentKey]);\r\n                                }\r\n                                else {\r\n                                    ObjectInterpolatorBase.mergeInto(parentObj, objCandidate)\r\n                                    queuedDeletes.push(ObjectInterpolatorBase.createPathDotNotation(keys, key));\r\n                                }\r\n                            }\r\n\r\n                            if(Array.isArray(parentObj)) {\r\n                                this.addFlattenPaths(flattenPaths, keys);\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                    else\r\n                        throw new Error(\"No parent object to merge\");\r\n                }\r\n                else if(keyReplaceResult.nReplacedKeys > 0) {\r\n                    childObj[keyReplaceResult.key] = childObj[key];\r\n                    delete childObj[key];\r\n                }\r\n\r\n            }\r\n            else if(cmd === KeyCommands.KeyCmdQueueDelChildObjectIfEmpty) {\r\n                queuedDeletes.push(ObjectInterpolatorBase.createPathDotNotation(keys, key));\r\n            }\r\n        }\r\n        for(const flattenObj of flattenPaths)\r\n             ObjectInterpolatorBase.mergeInto(flattenObj, flattenObj.flat());\r\n\r\n        this.processDeletes(queuedDeletes);\r\n\r\n        return { obj: this.getObj(), nReplacedKeys: nReplacedKeys };\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Takes a function expression with arguments and returns abstract syntax tree\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ParseFunctionCalls extends BaseAST {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options) {\r\n        super(expression);\r\n        this._options = options;\r\n        this._options.OptionStringArgQuoted = this._options.OptionStringArgQuoted !== undefined ?\r\n            this._options.OptionStringArgQuoted : false;\r\n    }\r\n    getOptionStringArgQuoted() { return this._options.OptionStringArgQuoted; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // We need to pass over any group of characters enclosed in single quotes, double quotes or array brackets as in:\r\n    //  * 'skip this stuff'\r\n    //  * \"skip this stuff\"\r\n    //  * [skip this stuff]\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipGroupedChars() {\r\n        let beginChar = this.cAtI();\r\n\r\n        // Special token which indicates the start of a group, one of: ' \" [\r\n        if(BaseAST.isGroupTokenBegin(beginChar)) {\r\n            let inTokens = [];\r\n            inTokens.push(beginChar);\r\n\r\n            // We need to scan ahead until we find the matching end token\r\n            while(this.hasChars() && inTokens.length > 0) {\r\n\r\n                // Use the last group token pushed - and skip it\r\n                beginChar = inTokens[inTokens.length - 1];\r\n                this.skip();\r\n\r\n                // It is possible that we could have nested group tokens, consider: [\"4\", \"1\"]\r\n                while (this.hasChars()) {\r\n\r\n                    // 1st - check if we have a matching token to our current beginChar, one of: ' \" ]\r\n                    if(this.cAtIIsGroupTokenEnd(beginChar)) {\r\n                        inTokens.pop();\r\n                        break;\r\n                    }\r\n                    else {\r\n                        // 2nd - we can consider that we may have a nested group token, if we do, we will work with this\r\n                        // one until we find its matching end token\r\n                        const newBeginChar = this.cAtI();\r\n                        if (BaseAST.isGroupTokenBegin(newBeginChar)) {\r\n                            beginChar = newBeginChar;\r\n                            inTokens.push(newBeginChar);\r\n                            break;\r\n                        }\r\n                    }\r\n                    // If we got here, we are happily moving along, consuming characters between our start group token\r\n                    // while we attempt to find a matching end to our group\r\n                    this.skip();\r\n                }\r\n            }\r\n            // if we have unmatched ending tokens we should raise and exception\r\n            if(inTokens.length > 0)\r\n                throw new Error(`Parse error - mismatch on some ending symbols: [${inTokens.map((symbol) => `'${symbol}'`).join(\",\")}]`);\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipNonSpecialChars() {\r\n        while (this.hasChars() && !this.cAtIIsWhite() && !this.cAtIOIsOpen() && !this.cAtIOIsClose() && !this.cAtIIsArgSeporator()) {\r\n            this.skip();\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    readToken() {\r\n        this.skipWhitespace();\r\n\r\n        let token;\r\n        if (!this.cAtIOIsOpen() && !this.cAtIOIsClose()) {\r\n\r\n            // our token should start at this index\r\n            const start = this.getI();\r\n\r\n            this.skipGroupedChars();\r\n            this.skipNonSpecialChars();\r\n\r\n            // our token should end at this index\r\n            const end = this.getI();\r\n\r\n            // slice out our token\r\n            token = this.getExpr().slice(start, end);\r\n        }\r\n        else\r\n            throw new Error(`Parse error - Unexpected '(' or ')' missing function name`);\r\n\r\n        return token;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseArguments() {\r\n        let args = [];\r\n        while (this.hasChars() && !this.cAtIOIsClose()) {\r\n            args.push(this.parseExpression());\r\n            this.skipWhitespace();\r\n\r\n            if (this.cAtIIsArgSeporator())\r\n                this.skip();  // Skip comma\r\n        }\r\n        return args;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseExpression() {\r\n        let token = this.readToken();\r\n\r\n        if (/^true|false$/.test(token)) {\r\n            /* literal true or false */\r\n        }\r\n        else if(/^null$/.test(token)) {\r\n            /* literal null */\r\n        }\r\n        else if (/^[a-zA-Z_ƒ][\\w]*$/.test(token)) {\r\n            this.skipWhitespace();\r\n\r\n            // make sure we have an open bracket '(' - and skip it\r\n            if (this.cAtIOIsOpen()) {\r\n                /* function name */\r\n                let funcName = token;\r\n\r\n                this.skip(); // Skip\r\n\r\n                // parse the arguments\r\n                let args = this.parseArguments();\r\n\r\n                // make sure we have an open bracket '(' - and skip it\r\n                this.skipWhitespace();\r\n                if (!this.cAtIOIsClose())\r\n                    throw new Error(`Parse error - Expected '(' after function name ${funcName}`);\r\n                this.skip(); // Skip ')'\r\n\r\n                return {\r\n                    type: 'FunctionCall',\r\n                    name: funcName,\r\n                    arguments: args\r\n                };\r\n            }\r\n            else if(this.getOptionStringArgQuoted())\r\n                throw new Error(`Parse error - Expected '(' after function name ${token}`);\r\n            else {\r\n                // getting here implies that the token is a string parameter and not a function call, it also means\r\n                // we are missing single quotes around the param.  However, we should have single quotes around\r\n                // string params.  Let's add them\r\n               token = `'${token}'`;\r\n            }\r\n        }\r\n\r\n        return {\r\n          type: 'Literal',\r\n          value: token\r\n        };\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parse() {\r\n        this.notifyParseStart();\r\n\r\n        // create the abstract syntax tree\r\n        const asTree =  this.parseExpression();\r\n\r\n        this.notifyParseComplete(asTree);\r\n\r\n        return asTree;\r\n    }\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Derived class handles evaluation of abstract syntax tree\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass EvaluateFunctions extends ParseFunctionCalls {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertNum(value) {\r\n        let result = undefined;\r\n        if((typeof value === 'string') && (value !== '')) {\r\n            const num = Number(value);\r\n            if (!isNaN(num))\r\n                result = num;\r\n        }\r\n\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertString(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^['\"](.*)['\"]$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1];\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertBool(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^(true|false)$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1] === 'true';\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertNull(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^(null)$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1] === 'null' ? null : undefined;\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertObj(value) {\r\n        let result = undefined;\r\n        try {\r\n            result = JSON.parse(value);\r\n        }\r\n        catch(er) { throw new Error('Failed to convert value to Json object'); }\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertToLiteral(value) {\r\n        let result = value;\r\n        const num = EvaluateFunctions.convertNum(value);\r\n        if(num !== undefined)\r\n            result = num;\r\n        else\r\n        {\r\n            const str = EvaluateFunctions.convertString(value);\r\n            if(str !== undefined)\r\n                result = str;\r\n            else\r\n            {\r\n                const bool = EvaluateFunctions.convertBool(value);\r\n                if(bool !== undefined)\r\n                    result = bool;\r\n                else\r\n                {\r\n                    const nullValue = EvaluateFunctions.convertNull(value);\r\n                    if(nullValue !== undefined)\r\n                        result = nullValue\r\n                    else\r\n                    {\r\n                        try {\r\n                            const obj = EvaluateFunctions.convertObj(value);\r\n                            if (obj !== undefined)\r\n                                result = obj;\r\n                        }\r\n                        catch(er) {\r\n                            if(typeof value === 'string')\r\n                                return value;\r\n                            else\r\n                                throw new Error('Invalid type in convertToLiteral');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static invokeParsedFunction(sender, asTree, context) {\r\n\r\n        // If it's a literal, return the value directly\r\n        if (asTree.type === 'Literal')\r\n            return EvaluateFunctions.convertToLiteral(asTree.value);\r\n        else if (asTree.type === 'FunctionCall') {\r\n            const func = context[asTree.name];\r\n            if (typeof func !== 'function')\r\n                throw new Error(`Function ${asTree.name} is not defined in the context`);\r\n\r\n            // Recursively evaluate and collect arguments\r\n            const args = asTree.arguments.map(arg => EvaluateFunctions.invokeParsedFunction(sender, arg, context));\r\n\r\n            // Invoke the function with the evaluated arguments\r\n            return func(sender, ...args);\r\n        } else {\r\n            throw new Error(\"Unknown AST node type\");\r\n        }\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(parent, expression, keyValueContext, fContext, options = {}) {\r\n        super(expression, options);\r\n        this._parent = parent;\r\n        this._keyValueContext = keyValueContext;\r\n        this._fContext = fContext;\r\n        this._asTree = null;\r\n    }\r\n    getParent() { return this._parent; }\r\n    getKeyValueContext() { return this._keyValueContext; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parse() {\r\n        this._asTree = super.parse();\r\n        const evaluation =  EvaluateFunctions.invokeParsedFunction(this, this._asTree, this._fContext);\r\n        return evaluation;\r\n    }\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Attempts to resolve undefined parameters as embedded function calls, during interpolation.  Any key prepended with\r\n// \"->\", will be parsed as a function.  For example, interpolation parameters like:\r\n//   {{->Add(1,2)}}\r\n//  Will be parsed as function Add(1,2).  As long as \"Add\" function exists in provided context, the function will be\r\n//  invoked.  The resulting value will be used as the replacement parameter\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\n\r\nclass ObjectInterpolator extends ObjectInterpolatorBase {\r\n    static convertToString(value) {\r\n        let result = value;\r\n        if((typeof value === 'number') || (typeof value === 'bigint') ||(typeof value === 'boolean') || (typeof value === 'string'))\r\n            result = value.toString();\r\n        else if(value === null)\r\n            result = 'null';\r\n        else if(value === undefined)\r\n            result = undefined;\r\n        else if(Array.isArray(value))\r\n            result = JSON.stringify(value);\r\n        else\r\n            console.error('Failed to convert to primitive type');\r\n\r\n        return result;\r\n    }\r\n\r\n    static processExpression(expression) {\r\n        const e = new ExpressionParser(expression);\r\n        return e.evaluate();\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static getFunctionExpression(expression) {\r\n        let result = \"\";\r\n        if(expression) {\r\n            const regX = new RegExp(REGX.FUNCTION_TAG)\r\n            const match = regX.exec(expression);\r\n            if(Array.isArray(match) && (match.length === 2))\r\n                result = match[1];\r\n        }\r\n\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(obj, keyValues, parseFContext, options = {}) {\r\n        super(obj, keyValues, options);\r\n        this._parseFContext = parseFContext ? parseFContext : {};\r\n        this._buildInFContext = {\r\n            'ƒ': (sender, expression) => ObjectInterpolator.processExpression(expression),\r\n            'Exp': (sender, expression) => ObjectInterpolator.processExpression(expression),\r\n            '_': (sender, value) => ObjectInterpolator.convertToString(value)\r\n        };\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI) {\r\n        const functionExpression = ObjectInterpolator.getFunctionExpression(key);\r\n        if(this._parseFContext && functionExpression) {\r\n            const evaluateF = new EvaluateFunctions(this, functionExpression, keyValueContext,\r\n                {...this._parseFContext, ...this._buildInFContext });\r\n            return evaluateF.parse();\r\n        }\r\n        else {\r\n            return super.notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI);\r\n        }\r\n    }\r\n}\r\n\r\nexport { ObjectInterpolator, StringInterpolator, ObjectInterpolatorBase, SinglePassTagReplacer, SimpleTagParser,\r\n    InterpolationValueNotFoundError, ReplaceObjectAction, KeyValueContextI, QueryObjKeyValueContextI};\r\n\r\n"],"names":["ExpressionParseError","Error","constructor","reason","super","REGX","Object","freeze","OPERAND_NUMBERS","OPERAND_STRING","OPERAND_LOGICAL_TRUE","OPERAND_LOGICAL_FALSE","OPERAND_POS_INFINITY","OPERAND_NEG_INFINITY","MATH_OPERATORS","TERNARY_OPERATORS","LOGICAL_OPERATORS","EQUALITY_OPERATORS","Stack","this","_values","size","length","empty","peek","undefined","push","value","pop","popN","n","result","i","unshift","toNum","s","parseFloat","isNaN","toBool","toOperand","er","isQuote","char","trim","firstChar","lastChar","toStr","toTypePair","a","b","va","vb","operatorData","precedence","associativity","NArgs","f","c","operatorKeys","keys","InfixNotationParser","expression","_expression","_isOperand","RegExp","_regXParseExpression","isOperator","token","includes","getOperator","isAssociative","type","comparePrecedence","op1","op2","hasHigherPrecedence","hasLowerPrecedence","hasSamePrecedence","tokenize","match","isOperand","test","toPostfix","outputQueue","tokens","Array","isArray","operatorStack","forEach","topOperatorStack","poppedSymbol","operator","ExpressionParser","evaluate","postFix","stack","args","slice","FUNCTION_TAG","CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY","CMD_KEY_COPY_INTO_OBJ","CMD_KEY_COPY_INTO_PARENT_OBJ","InterpolationValueNotFoundError","BaseAST","isWhitespace","isOpen","isClose","isCurlyOpen","isCurlyClose","isArgSeparate","isSquareOpen","isSquareClose","isGroupTokenBegin","isMatchingGroupTokenEnd","beginChar","_index","notifyParseStart","notifyParseComplete","parseResult","getI","getExpr","cAtI","cAtIIsWhite","skip","hasChars","nChars","cAtIisCurlyOpen","cAtIisCurlyClose","cAtIOIsOpen","cAtIOIsClose","cAtIIsArgSeporator","cAtIIsGroupTokenEnd","cAtIIsTag","tag","hasTag","tagLen","nFoundSymbols","skipWhitespace","TagParser","options","_options","_startTag","_endTag","_ignoreEnclosed","Opens","Closes","_curlyBracketStack","_replacementEdits","TrackCurlyBrackets","getTrackCurlyBrackets","createTemplateKey","key","cAtIIsBeginTag","cAtIIsEndTag","isTag","cAtIisOpen","closing","indexOfOpen","indexOf","cAtIisClosing","matchedClosing","lastClosing","trackEnclosedChars","closingChar","parseToken","start","end","iStartToken","iEndToken","Match","Key","IStartToken","IEndToken","applyReplacementEdits","SinglePassTagReplacer","customStringReplacer","SimpleTagParser","has","matchResultObj","replacementEdits","lastIndex","ReplaceWith","cb","_cb","notifyParseResult","offset","replace","join","PromisesHandler","isPromise","p","then","_promises","_promiseKeys","_matchedOn","_nextKeyId","hasPromises","allSettled","Promise","processPromises","replaceKeys","NResolved","NRejected","results","promiseKey","pResult","status","getNextPromiseKey","add","matchedOn","pCandidate","addedKey","defaultOptions","CovertValueToType","KeyValueContextI","keyValues","_keyValues","getKeyValues","get","StringInterpolator","templateStr","keyValuesI","_templateStr","_keyValuesI","ReplaceNotFoundHandler","templateVar","getOptionConvertType","getOptionReplaceNotFoundHandler","getValueInMap","doReplaces","simpleReplace","promisesHandler","sender","string","replaceCandidate","canInvokeNotFoundHandler","JSON","stringify","resultingS","promiseReplaceKeys","sInterpolate","ReplaceObjectAction","ACTION_NONE","Symbol","ACTION_DELETE","ACTION_THROW","isValidAction","action","isValid","ActionI","_action","getAction","setAction","newActionValue","actionSet","KeyCommands","KeyCmdNone","KeyCmdCopyIntoObject","KeyCmdCopyIntoParentObject","KeyCmdDelKey","KeyCmdQueueDelChildObjectIfEmpty","ObjectInterpolatorBase","isKeyCmd","cmd","search","containsTemplateVar","templateString","dupWithoutVars","childObj","obj","entries","mergeInto","target","source","splice","assign","iterateObjStrings","objs","isRoot","useKeys","__ProcessKeys__","regex","console","log","createPathDotNotation","createObjectPath","pathDotNotation","split","dup","parse","CopyObj","_obj","getCopyObj","ActionOnNotFound","_nPass","getObj","getOptions","getActionOnNotFound","getOptionKeyValueContextI","getOptionKeyValueContextSeparator","KeyValueContextSeparator","notifyReplaceNotFound","keyValueContext","parentReplaceNotFoundHandler","setActionI","useValue","actionOrValue","doInterpolateKey","replaceKeyValues","nReplacedKeys","stringInterpolator","nextReplace","doInterpolateObj","actionI","getCmdInKey","processDeletes","queuedDeletes","path","itObj","ownerObj","parentKey","parentObj","childKey","addFlattenPaths","flattenPaths","currentObj","flattenObjs","flattenObj","createKeyValueContextI","interpolate","trackParentSetObjects","Set","keyReplaceResult","objCandidate","flat","ParseFunctionCalls","OptionStringArgQuoted","getOptionStringArgQuoted","skipGroupedChars","inTokens","newBeginChar","map","symbol","skipNonSpecialChars","readToken","parseArguments","parseExpression","funcName","name","arguments","asTree","EvaluateFunctions","convertNum","num","Number","convertString","matched","convertBool","convertNull","convertObj","convertToLiteral","str","bool","nullValue","invokeParsedFunction","context","func","arg","parent","fContext","_parent","_keyValueContext","_fContext","_asTree","getParent","getKeyValueContext","ObjectInterpolator","convertToString","toString","error","processExpression","getFunctionExpression","exec","parseFContext","_parseFContext","_buildInFContext","Exp","_","functionExpression","useSeparator","_useSeparator","q","arr_deref","o","ref","reduce","err"],"mappings":"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"}