{"version":3,"file":"interpolation_objects.gs.min.js","sources":["../src/expression_parser.js","../src/interpolation_objects.js"],"sourcesContent":["\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// Exceptions\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ExpressionParseError extends Error { constructor(reason){ super(reason); } }\r\n\r\nconst REGX = Object.freeze({\r\n    OPERAND_NUMBERS: '-*\\\\d+(\\\\.\\\\d*)*',\r\n    OPERAND_STRING: \"(?:'|\\\")[^'\\\"]*(?:'|\\\")\",\r\n    OPERAND_LOGICAL_TRUE: 'true',\r\n    OPERAND_LOGICAL_FALSE: 'false',\r\n    OPERAND_POS_INFINITY: 'Infinity',\r\n    OPERAND_NEG_INFINITY: '-Infinity',\r\n    MATH_OPERATORS: '\\\\+|\\\\-|\\\\*|\\\\/|\\\\^|\\\\(|\\\\)',\r\n    TERNARY_OPERATORS: '\\\\?|\\\\:',\r\n    LOGICAL_OPERATORS: '\\\\|\\\\||&&|==|!=|!',\r\n    EQUALITY_OPERATORS: '>=|<=|>|<'\r\n});\r\n\r\n\r\n// --------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Stack implementation\r\n//\r\n// --------------------------------------------------------------------------------------------------------------------\r\nclass Stack {\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    constructor() { this._values = []; }\r\n\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    get size() { return this._values.length; }\r\n    empty() { return this.size === 0; }\r\n    peek() { return this.empty() ? undefined : this._values[this._values.length - 1]; }\r\n\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    push(value) { this._values.push(value); }\r\n    pop() { return this.empty() ? undefined : this._values.pop(); }\r\n    popN(n) {\r\n        const result = [];\r\n        if (this.size >= n) {\r\n            for (let i = 0; i < n; i++)\r\n                result.unshift(this.pop());\r\n        }\r\n        return result;\r\n    }\r\n}\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Working with operators\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// To number\r\n//---------------------------------------------------------------------------------------------------------------------\r\nfunction toNum(s) {\r\n    const result = parseFloat(s);\r\n    if(!isNaN(result))\r\n        return result;\r\n    else\r\n        throw new ExpressionParseError(`Failed to convert ${s} to number`);\r\n}\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// To boolean\r\n//---------------------------------------------------------------------------------------------------------------------\r\nfunction toBool(s) {\r\n    if((s === 'true') || (s === true))\r\n        return true;\r\n    else if((s === 'false') || (s === false))\r\n        return false;\r\n    else\r\n        throw new ExpressionParseError(`Failed to convert ${s} to boolean`);\r\n}\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// To number\r\n//---------------------------------------------------------------------------------------------------------------------\r\nfunction extractStrOperand(s) {\r\n    return s.slice(1, s.length - 1)\r\n\r\n}\r\nfunction toStr(s) {\r\n    function isQuote(char) { return (char === \"'\") || (char === '\"'); }\r\n    let result = s.trim();\r\n    if(result.length > 1) {\r\n        const firstChar = result[0];\r\n        const lastChar = result[result.length - 1];\r\n        if( !isQuote(firstChar) && !isQuote(lastChar))\r\n            throw new ExpressionParseError(`String expression ${s} must be enclosed in single quotes`);\r\n    }\r\n    else\r\n        throw new ExpressionParseError(`Failed to convert ${s} to number`);\r\n\r\n    return result;\r\n}\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// To supported operand\r\n//---------------------------------------------------------------------------------------------------------------------\r\nfunction toOperand(s) {\r\n    try {\r\n        return toNum(s);\r\n    }\r\n    catch(er) {\r\n        try {\r\n            return toBool(s);\r\n        }\r\n        catch(er) {\r\n            return toStr(s);\r\n        }\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// Converts both a and b to expected types\r\n//---------------------------------------------------------------------------------------------------------------------\r\nfunction toTypePair(a, b) {\r\n    const va = toOperand(a);\r\n    const vb = toOperand(b)\r\n    if(typeof va === typeof vb)\r\n        return [va, vb];\r\n    else\r\n        throw new ExpressionParseError(`Cannot operate on parameters with different types ${a} <??> ${b}`);\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Information on all supported operators\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst operatorData = {\r\n    '?': { precedence: 0, associativity: 'R', NArgs: 0, f:function() { throw new ExpressionParseError('Ternary if mismatched'); } },\r\n    ':': { precedence: 0, associativity: 'R', NArgs: 2, f:function() { throw new ExpressionParseError('Ternary else if mismatched'); } },\r\n    '?:': { precedence: 1, associativity: 'R', NArgs: 3, f:function(a, b, c) { return toBool(a) ? toOperand(b) : toOperand(c); } },\r\n    '^': { precedence: 2, associativity: 'R', NArgs: 2, f:function(a, b) { return toNum(a) ** toNum(b); } },\r\n    '+': { precedence: 4, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) + toNum(b); } },\r\n    '-': { precedence: 4, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) - toNum(b); } },\r\n    '*': { precedence: 3, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) * toNum(b); } },\r\n    '/': { precedence: 3, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) / toNum(b); } },\r\n\r\n    '==': { precedence: 7, associativity: 'L', NArgs: 2, f:function(a, b) {\r\n        const [va, vb] = toTypePair(a, b);\r\n        return va === vb;\r\n    } },\r\n    '!=': { precedence: 7, associativity: 'L', NArgs: 2, f:function(a, b) {\r\n        const [va, vb] = toTypePair(a, b);\r\n        return va !== vb;\r\n    } },\r\n    '!': { precedence: 2, associativity: 'R', NArgs: 1, f:function(a) {\r\n        return !toBool(a);\r\n    } },\r\n    '&&': { precedence: 11, associativity: 'L', NArgs: 2, f:function(a, b) { return toBool(a) && toBool(b); } },\r\n    '||': { precedence: 12, associativity: 'L', NArgs: 2, f:function(a, b) { return toBool(a) || toBool(b); } },\r\n    '>=': { precedence: 6, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) >= toNum(b); } },\r\n    '<=': { precedence: 6, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) <= toNum(b); } },\r\n    '>': { precedence: 6, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) > toNum(b); } },\r\n    '<': { precedence: 6, associativity: 'L', NArgs: 2, f:function(a, b) { return toNum(a) < toNum(b); } },\r\n};\r\nconst operatorKeys = Object.keys(operatorData);\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Implementation of Shunting Yard\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass InfixNotationParser {\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression) {\r\n        this._expression = expression;\r\n        this._isOperand =\r\n            new RegExp(`^${REGX.OPERAND_STRING}$|^${REGX.OPERAND_NUMBERS}$|^${REGX.OPERAND_LOGICAL_TRUE}$|^${REGX.OPERAND_LOGICAL_FALSE}$|^${REGX.OPERAND_POS_INFINITY}$|^${REGX.OPERAND_NEG_INFINITY}$`);\r\n\r\n        this._regXParseExpression =\r\n            new RegExp(`${REGX.OPERAND_STRING}|${REGX.OPERAND_LOGICAL_TRUE}|${REGX.OPERAND_LOGICAL_FALSE}|${REGX.OPERAND_POS_INFINITY}|${REGX.OPERAND_NEG_INFINITY}|${REGX.OPERAND_NUMBERS}|${REGX.MATH_OPERATORS}|${REGX.LOGICAL_OPERATORS}|${REGX.EQUALITY_OPERATORS}|${REGX.TERNARY_OPERATORS}`,'g');\r\n    }\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    isOperator(token) { return operatorKeys.includes(token); }\r\n    getOperator(token) { return operatorData[token]; }\r\n    isAssociative(token, type) { return this.getOperator(token).associativity === type; }\r\n    comparePrecedence(op1, op2) { return this.getOperator(op1).precedence - this.getOperator(op2).precedence; }\r\n    hasHigherPrecedence(op1, op2) { return this.comparePrecedence(op1, op2) < 0; }\r\n    hasLowerPrecedence(op1, op2) { return this.comparePrecedence(op1, op2) > 0; }\r\n    hasSamePrecedence(op1, op2) { return this.comparePrecedence(op1, op2) === 0; }\r\n    tokenize() { return this._expression.match(this._regXParseExpression); }\r\n    isOperand(token) { return this._isOperand.test(token); }\r\n\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    toPostfix() {\r\n        const outputQueue = [];\r\n        const tokens = this.tokenize();\r\n\r\n        if(Array.isArray(tokens)) {\r\n            const operatorStack = new Stack();\r\n            tokens.forEach(token => {\r\n                // 1. If the incoming symbols is an operand - push to outputQueue\r\n                if (this.isOperand(token)) {\r\n                    outputQueue.push(token);\r\n                }\r\n                // 2. If the incoming symbol is a left parenthesis, push it on the stack.\r\n                else if (token === '(') {\r\n                    operatorStack.push(token);\r\n                }\r\n                // 3. If the incoming symbol is a right parenthesis: discard the right parenthesis, pop and print the stack\r\n                //    symbols until you see a left parenthesis.\r\n                else if (token === ')') {\r\n                    while (operatorStack.size > 0 && operatorStack.peek() !== '(') {\r\n                        outputQueue.push(operatorStack.pop());\r\n                    }\r\n                    // If there is a left parenthesis - discard it.\r\n                    if ((operatorStack.size > 0) && (operatorStack.peek() === '('))\r\n                        operatorStack.pop();\r\n                    else\r\n                        throw new ExpressionParseError(`Missing open parenthesis in expression`);\r\n                }\r\n                // If the incoming symbol is an operator...\r\n                else if (this.isOperator(token)) {\r\n                    let topOperatorStack = operatorStack.peek();\r\n\r\n                    // 4. If the stack is empty or contains a left parenthesis on top or the incoming symbol is a ternary\r\n                    //    begin if\r\n                    if (operatorStack.empty() || (topOperatorStack === \"(\") || token === \"?\") {\r\n                        operatorStack.push(token);\r\n                    }\r\n                    // 5. Handle possible ternary operator\r\n                    else if(token === ':') {\r\n                        // Both ternary if (\"?\") and else (\":\") will never appear in the output.  The goal is to reverse\r\n                        // these symbols to RPN format: 'true a b ?:' or 'false a b ?:'.  The rule therefore is, when\r\n                        // finding the else branch (\":\") of the ternary operator, we pop inclusively to the start if\r\n                        // symbol (\"?\"), this goes to the output, then we follow this with the ending RPN ternary\r\n                        // operator \"?:\"\r\n                        // see also https://stackoverflow.com/questions/35609168/extending-the-shunting-yard-algorithm-to-support-the-conditional-ternary-operato\r\n                        // which goes over this in an example:\r\n                        // * \"?\" ternary-open-if\r\n                        // * \":\" ternary-else\r\n                        // * \"?:\" ternary-closed-if (note this is a dummy symbol, could be anything).  If this symbol is needed in your expression you should\r\n                        // update this parser and set it to a different unused symbol.\r\n                        let poppedSymbol = null;\r\n                        while(!operatorStack.empty()) {\r\n                            poppedSymbol = operatorStack.pop();\r\n                            if(poppedSymbol === '?') {\r\n                                operatorStack.push('?:');\r\n                                break;\r\n                            }\r\n                            else\r\n                                outputQueue.push(poppedSymbol);\r\n                        }\r\n                        if(poppedSymbol !== \"?\")\r\n                            throw new ExpressionParseError('Missing ternary ? symbol');\r\n                    }\r\n                    // 6. If the incoming operator has either higher precedence than the operator on the top of the stack,\r\n                    //    or has the same precedence as the operator on the top of the stack and is right associative\r\n                    else if ((this.hasHigherPrecedence(token, topOperatorStack)) ||\r\n                        (this.hasSamePrecedence(token, topOperatorStack) && this.isAssociative(token, 'R'))) {\r\n                        operatorStack.push(token);\r\n                    } else {\r\n                        // 7. If the incoming operator has either lower precedence than the operator on the top of the stack,\r\n                        //    or has the same precedence as the operator on the top of the stack and is left associative\r\n                        //      -- continue to pop the stack until this is not true. Then, push the incoming operator.\r\n                        while (topOperatorStack && (topOperatorStack !== '(') && (this.hasLowerPrecedence(token, topOperatorStack) ||\r\n                            (this.hasSamePrecedence(token, topOperatorStack) && this.isAssociative(token, 'L')))) {\r\n                            outputQueue.push(operatorStack.pop());\r\n                            topOperatorStack = operatorStack.peek();\r\n                        }\r\n                        operatorStack.push(token);\r\n                    }\r\n                }\r\n            });\r\n\r\n            // Last push any remaining symbols to the outputQueue\r\n            while (operatorStack.size > 0) {\r\n                const operator = operatorStack.pop()\r\n                if (operator !== '(')\r\n                    outputQueue.push(operator);\r\n                else\r\n                    throw new ExpressionParseError(`Missing closing parenthesis in expression`);\r\n            }\r\n        }\r\n        else\r\n            throw new ExpressionParseError('Parsing expression resulted in an empty parse');\r\n\r\n        return outputQueue;\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Parse and evaluate passed in expression\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ExpressionParser extends InfixNotationParser {\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression) {\r\n        super(expression);\r\n    }\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    // ----------------------------------------------------------------------------------------------------------------\r\n    evaluate() {\r\n        const postFix = this.toPostfix();\r\n        const stack = new Stack();\r\n        for(let i = 0; i < postFix.length; i++) {\r\n            const token = postFix[i];\r\n            if(this.isOperator(token)) {\r\n                const operator = this.getOperator(token);\r\n                if(stack.size >= operator.NArgs) {\r\n                    const args = stack.popN(operator.NArgs);\r\n                    const result = operator.f(...args);\r\n                    stack.push(result);\r\n                }\r\n                else\r\n                    throw new ExpressionParseError(`Not enough args for operator ${token}`)\r\n            }\r\n            else\r\n                stack.push(token);\r\n        }\r\n        if(stack.size === 1) {\r\n            let result = toOperand(stack.pop());\r\n\r\n            // If the type is a string remove single quotes\r\n            if(typeof result === 'string')\r\n                result = extractStrOperand(result);\r\n            return result;\r\n\r\n        }\r\n        else\r\n            throw new ExpressionParseError(`Resulting stack appears incorrect with size ${stack.size}`);\r\n    }\r\n}\r\nexport { ExpressionParser, ExpressionParseError};\r\n","import {ExpressionParser} from \"./expression_parser.js\"\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst REGX = Object.freeze({\r\n    FUNCTION_TAG: '^\\\\s*->\\\\s*(.*)',\r\n    CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY: '^(<-\\\\s*false\\\\s*)|(<--\\\\s*false\\\\s*)$',\r\n    CMD_KEY_COPY_INTO_OBJ: '^(<-\\\\s*true\\\\s*)|(<-\\\\s*)$',\r\n    CMD_KEY_COPY_INTO_PARENT_OBJ: '^(<--\\\\s*true\\\\s*)|(<--\\\\s*)$',\r\n    CMD_KEY_IF_BLOCK_START: '^(<--|<-)\\\\s*(IF\\\\().*',\r\n    CMD_KEY_ELSE_BLOCK: '^(<--|<-)\\\\s*(ELSE)$'\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n// Exceptions\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass InterpolationValueNotFoundError extends Error { constructor(){ super(\"Interpolation value not Found\"); } }\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Base class for a generic parser like an Abstract Syntax Tree or any simple parser requiring simple character scanning\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass BaseAST {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static isWhitespace(char) { return /\\s/.test(char); }\r\n    static isOpen(char) { return char === '('; }\r\n    static isClose(char) { return char === ')'; }\r\n    static isCurlyOpen(char) { return char === '{'; }\r\n    static isCurlyClose(char) { return char === '}'; }\r\n    static isArgSeparate(char) { return char === ','; }\r\n    static isSquareOpen(char) { return char === '['; }\r\n    static isSquareClose(char) { return char === ']'; }\r\n    static isGroupTokenBegin(char) { return (char === \"'\") || (char === '\"') || (char === '[') || (char === '{'); }\r\n    static isMatchingGroupTokenEnd(beginChar, char) {\r\n        if(beginChar === \"'\")\r\n            return char === \"'\";\r\n        else if(beginChar === '\"')\r\n            return char === '\"';\r\n        else if(beginChar === '[')\r\n            return char === ']';\r\n        else if(beginChar === '{')\r\n            return char === '}';\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression) {\r\n        this._expression = expression;\r\n        this._index = 0;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyParseStart() { this._index = 0; }\r\n    notifyParseComplete(parseResult) {}\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Basic character functions - non consuming\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getI() { return this._index; }\r\n    getExpr() { return this._expression; }\r\n    cAtI(n = 0) { return this.getExpr()[this._index + n]; }\r\n    cAtIIsWhite() { return BaseAST.isWhitespace(this.cAtI()); }\r\n    skip(n=1) { return this._index += n; }\r\n    hasChars(nChars = 1) { return (this.getExpr().length - this._index) >= nChars; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Useful character functions for specific cases\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisCurlyOpen() { return BaseAST.isCurlyOpen(this.cAtI()); }\r\n    cAtIisCurlyClose() { return BaseAST.isCurlyClose(this.cAtI()); }\r\n    cAtIOIsOpen() { return BaseAST.isOpen(this.cAtI()); }\r\n    cAtIOIsClose() { return BaseAST.isClose(this.cAtI()); }\r\n    cAtIIsArgSeporator() { return BaseAST.isArgSeparate(this.cAtI())}\r\n    cAtIIsGroupTokenEnd(beginChar) { return BaseAST.isMatchingGroupTokenEnd(beginChar, this.cAtI()); }\r\n    cAtIIsTag(tag) {\r\n        let hasTag = false;\r\n        const tagLen = tag.length;\r\n        if(this.hasChars(tagLen)) {\r\n            let nFoundSymbols = 0;\r\n            for(let i = 0; i < tag.length; i++) {\r\n                if(this.cAtI(i) === tag[i])\r\n                    nFoundSymbols++;\r\n            }\r\n            hasTag = (nFoundSymbols === tagLen)\r\n        }\r\n        return hasTag;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Consuming\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipWhitespace() {\r\n        while (this.hasChars() && this.cAtIIsWhite())\r\n            this.skip();\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass TagParser extends BaseAST {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options = {}) {\r\n        super(expression);\r\n\r\n        this._options = options;\r\n        this._startTag = \"{{\";\r\n        this._endTag = \"}}\"\r\n        this._ignoreEnclosed = { Opens: [\"{\"], Closes: [\"}\"] }\r\n        this._curlyBracketStack = [];\r\n        this._replacementEdits = []\r\n        this._options.TrackCurlyBrackets = this._options.TrackCurlyBrackets !== undefined ?\r\n            this._options.TrackCurlyBrackets : false;\r\n    }\r\n    getTrackCurlyBrackets() { return this._options.TrackCurlyBrackets; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    createTemplateKey(key) { return `${this._startTag}${key}${this._endTag}`; }\r\n    cAtIIsBeginTag() { return this.cAtIIsTag(this._startTag); }\r\n    cAtIIsEndTag() {\r\n        let isTag = false;\r\n        if(this._curlyBracketStack.length === 0)\r\n            isTag = this.cAtIIsTag(this._endTag);\r\n        return isTag;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisOpen() {\r\n        let closing = undefined;\r\n        const indexOfOpen = this._ignoreEnclosed.Opens.indexOf(this.cAtI());\r\n        if(indexOfOpen !== -1)\r\n            closing = this._ignoreEnclosed.Closes[indexOfOpen];\r\n\r\n\r\n        return closing;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    cAtIisClosing() {\r\n        let matchedClosing = false;\r\n        if(this._curlyBracketStack.length > 0) {\r\n            const lastClosing = this._curlyBracketStack[this._curlyBracketStack.length - 1];\r\n            if(this.cAtI() === lastClosing)\r\n                matchedClosing = true;\r\n        }\r\n        return matchedClosing;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    trackEnclosedChars() {\r\n        // In the cases where we have not identified a start or end token, track curly brackets.\r\n        if(this.getTrackCurlyBrackets()) {\r\n            const closingChar = this.cAtIisOpen();\r\n            if (closingChar !== undefined)\r\n                this._curlyBracketStack.push(closingChar);\r\n            else if (this.cAtIisClosing()) {\r\n                this._curlyBracketStack.pop();\r\n            }\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseToken() {\r\n        // {{A  {{B}} }}\r\n        let token = undefined;\r\n        let start = -1; let end = -1;\r\n        let iStartToken = -1; let iEndToken = -1;\r\n        while (this.hasChars()) {\r\n            if (this.cAtIIsBeginTag()) {\r\n                iStartToken = this.getI();\r\n                this.skip(this._startTag.length);\r\n                start = this.getI();\r\n            }\r\n            else if ((start !== -1) && this.cAtIIsEndTag()) {\r\n                end = this.getI();\r\n                iEndToken = end +  this._endTag.length;\r\n\r\n                // slice out our token\r\n                token = this.getExpr().slice(start, end);\r\n\r\n                this.skip(this._endTag.length);\r\n                break;\r\n            }\r\n            else {\r\n                this.trackEnclosedChars();\r\n                this.skip();\r\n            }\r\n        }\r\n        return token !== undefined ? {\r\n            Match: this.createTemplateKey(token),\r\n            Key: token,\r\n            IStartToken: iStartToken,\r\n            IEndToken: iEndToken\r\n        } : undefined;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    applyReplacementEdits() {\r\n        return SinglePassTagReplacer.customStringReplacer(this.getExpr(), this._replacementEdits);\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass SimpleTagParser extends TagParser {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options = {}) {\r\n        super(expression, options);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    has() {\r\n        let found = false;\r\n        this.notifyParseStart();\r\n        let matchResultObj = this.parseToken();\r\n        this.notifyParseComplete(matchResultObj);\r\n        return matchResultObj !== undefined;\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass SinglePassTagReplacer extends TagParser {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static customStringReplacer(expression, replacementEdits) {\r\n        // Note: edits are already sorted from left to right\r\n\r\n        // Iterate over the replacementEdits\r\n        let result = '';\r\n        let lastIndex = 0;\r\n\r\n        for (let i = 0; i < replacementEdits.length; i++) {\r\n            const { ReplaceWith, IStartToken, IEndToken } = replacementEdits[i];\r\n\r\n            // Add the existing part of the string before the start token\r\n            result += expression.slice(lastIndex, IStartToken);\r\n\r\n            // Add the new string (key)\r\n            result += ReplaceWith;\r\n\r\n            // Update the lastIndex to be after the end token\r\n            lastIndex = IEndToken;\r\n        }\r\n\r\n        // Add any remaining part of the original string after the last change\r\n        result += expression.slice(lastIndex);\r\n\r\n        return result;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, cb, options = {}) {\r\n        super(expression, options);\r\n        this._cb = cb;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyParseResult(matchResultObj) {\r\n        const match = matchResultObj.Match;\r\n        const key = matchResultObj.Key;\r\n        const offset = matchResultObj.IStartToken;\r\n\r\n        matchResultObj.ReplaceWith = this._cb(this, match, key, offset, this.getExpr());\r\n        this._replacementEdits.push(matchResultObj);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    applyReplacementEdits() {\r\n        return SinglePassTagReplacer.customStringReplacer(this.getExpr(), this._replacementEdits);\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    replace() {\r\n        this.notifyParseStart();\r\n        let matchResultObj = this.parseToken();\r\n        while(matchResultObj !== undefined) {\r\n            this.notifyParseResult(matchResultObj);\r\n            matchResultObj = this.parseToken();\r\n        }\r\n        if(this._curlyBracketStack.length > 0)\r\n            throw new Error(`Match Error - unbalanced symbols missing: ${this._curlyBracketStack.join(',')}`);\r\n        this.notifyParseComplete(matchResultObj);\r\n        return this.applyReplacementEdits();\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass PromisesHandler {\r\n    static isPromise(p) {\r\n        let result = false;\r\n        if ((p !== null) && (typeof p === 'object') && typeof p.then === 'function')\r\n            result = true;\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor() {\r\n        this._promises = [];\r\n        this._promiseKeys = [];\r\n        this._matchedOn = []\r\n\r\n        this._nextKeyId = 0;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    hasPromises() { return this._promises.length > 0; }\r\n    allSettled() { return Promise.allSettled(this._promises); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async processPromises() {\r\n        let replaceKeys = undefined;\r\n        if (this.hasPromises()) {\r\n            replaceKeys = {NResolved: 0, NRejected: 0};\r\n            const results = await this.allSettled();\r\n            for (let i = 0; i < results.length; i++) {\r\n                const promiseKey = this._promiseKeys[i];\r\n                const pResult = results[i];\r\n                if(pResult.status === 'fulfilled') {\r\n                    replaceKeys[promiseKey] = pResult.value;\r\n                    replaceKeys.NResolved++;\r\n                }\r\n                else if(pResult.status === 'rejected') {\r\n                    replaceKeys[promiseKey] = this._matchedOn[i];\r\n                    replaceKeys.NRejected++;\r\n                }\r\n            }\r\n        }\r\n        return replaceKeys;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getNextPromiseKey() {\r\n        const key  = `${this._nextKeyId}__@uniquePKey@__${this._nextKeyId}`;\r\n        this._nextKeyId++;\r\n        return key;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    add(matchedOn, pCandidate) {\r\n        let addedKey = undefined;\r\n        if(PromisesHandler.isPromise(pCandidate)) {\r\n            this._matchedOn.push(matchedOn);\r\n            this._promises.push(pCandidate);\r\n            addedKey = this.getNextPromiseKey();\r\n            this._promiseKeys.push(addedKey);\r\n        }\r\n        return addedKey;\r\n    }\r\n}\r\nconst defaultOptions = Object.freeze({\r\n    CovertValueToType: true,\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Context for key values allows lookup by simple key.  This is the Base Interface for getting a value based on a key\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass KeyValueContextI {\r\n    constructor(keyValues) {\r\n        this._keyValues = keyValues;\r\n    }\r\n    getKeyValues() { return this._keyValues; }\r\n    get(key) { return this._keyValues[key]; }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Context for key values allows lookup by a query string.\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass QueryObjKeyValueContextI extends KeyValueContextI {\r\n    constructor(keyValues, useSeparator = \".\") {\r\n        super(keyValues);\r\n        this._useSeparator = useSeparator;\r\n    }\r\n    get(q) {\r\n         function arr_deref(o, ref, i) {\r\n            const key = ref.slice(0, i ? -1 : ref.length);\r\n            return !ref ? o : (o[key]);\r\n        }\r\n        function dot_deref(o, ref) {\r\n            return !ref ? o : ref.split('[').reduce(arr_deref, o);\r\n        }\r\n        try {\r\n            return q.split(this._useSeparator).reduce(dot_deref, this.getKeyValues());\r\n        }\r\n        catch(err) { return undefined; }\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass StringInterpolator {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(templateStr, keyValuesI, options = {}) {\r\n        this._templateStr = templateStr;\r\n\r\n        this._keyValuesI = (keyValuesI instanceof KeyValueContextI) ?\r\n            keyValuesI : new KeyValueContextI(keyValuesI);\r\n\r\n        this._options = options;\r\n\r\n        this._options.CovertValueToType = this._options.CovertValueToType === undefined ?\r\n            defaultOptions.CovertValueToType : this._options.CovertValueToType;\r\n\r\n        this._options.ReplaceNotFoundHandler =\r\n            this._options.ReplaceNotFoundHandler !== undefined ? this._options.ReplaceNotFoundHandler : (templateVar, key) => { return templateVar };\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getOptionConvertType() { return this._options.CovertValueToType; }\r\n    getOptionReplaceNotFoundHandler() { return this._options.ReplaceNotFoundHandler; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getValueInMap(key) { return this._keyValuesI.get(key); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doReplaces(templateStr, options) {\r\n        let simpleReplace = undefined;\r\n        const promisesHandler = new PromisesHandler();\r\n\r\n        // Replace string with found key\r\n        let nReplaces = 0;\r\n        const replace = (new SinglePassTagReplacer(templateStr,\r\n            (sender, match, key, offset, string) => {\r\n\r\n                let replaceCandidate = options.getValueInMap(key.trim());\r\n                if((replaceCandidate === undefined) && options.canInvokeNotFoundHandler())\r\n                    replaceCandidate = this.getOptionReplaceNotFoundHandler()(match, key);\r\n\r\n                // If there are promises to resolve, replace the token with our promise key\r\n                const promiseKey = promisesHandler.add(match, replaceCandidate);\r\n                if(promiseKey !== undefined)\r\n                    replaceCandidate = sender.createTemplateKey(promiseKey);\r\n                else if(this.getOptionConvertType() && (match === string))\r\n                    simpleReplace = replaceCandidate;\r\n                else {\r\n                    if((replaceCandidate !== null) && (typeof replaceCandidate === 'object'))\r\n                        replaceCandidate = JSON.stringify(replaceCandidate)\r\n                }\r\n\r\n                return replaceCandidate;\r\n\r\n        }, this._options)).replace();\r\n        let resultingS = undefined;\r\n        const promiseReplaceKeys = await promisesHandler.processPromises();\r\n        if(promiseReplaceKeys !== undefined) {\r\n            resultingS = await this.doReplaces(replace, {\r\n                getValueInMap: (key) =>  promiseReplaceKeys[key],\r\n                canInvokeNotFoundHandler: () => false\r\n            });\r\n        }\r\n\r\n        resultingS = resultingS || (simpleReplace !== undefined ? simpleReplace : replace);\r\n        return resultingS;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async sInterpolate() {\r\n        let resultingS = this._templateStr;\r\n\r\n        if (typeof resultingS === 'string') {\r\n            resultingS = await this.doReplaces(resultingS, {\r\n                getValueInMap: (key) =>  this.getValueInMap(key),\r\n                canInvokeNotFoundHandler: () => true\r\n            });\r\n        }\r\n\r\n        return resultingS;\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst ReplaceObjectAction = Object.freeze({\r\n    ACTION_NONE: Symbol(\"ACTION_NONE\"),\r\n    ACTION_DELETE: Symbol(\"ACTION_DELETE\"),\r\n    ACTION_THROW: Symbol(\"ACTION_THROW\"),\r\n    isValidAction: function (action) {\r\n        let isValid = false;\r\n        if(action)\r\n            isValid = (action === ReplaceObjectAction.ACTION_NONE) ||\r\n                (action === ReplaceObjectAction.ACTION_DELETE) ||\r\n                (action === ReplaceObjectAction.ACTION_THROW);\r\n        return isValid;\r\n    }\r\n});\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ActionI {\r\n    constructor() {\r\n        this._action = ReplaceObjectAction.ACTION_NONE;\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getAction() { return this._action; }\r\n    setAction(newActionValue) {\r\n        let actionSet = false;\r\n        if(ReplaceObjectAction.isValidAction(newActionValue)) {\r\n            this._action = newActionValue;\r\n\r\n            actionSet = true;\r\n        }\r\n\r\n        return actionSet;\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nconst KeyCommands = Object.freeze({\r\n    KeyCmdNone: 0,\r\n    KeyCmdCopyIntoObject: 1,\r\n    KeyCmdCopyIntoParentObject: 2,\r\n    KeyCmdDelKey: 3,\r\n    KeyCmdQueueDelChildObjectIfEmpty: 4\r\n});\r\n\r\nclass ObjectInterpolatorBase  {\r\n    static isKeyCmd(key, cmd) { return key.search(new RegExp(cmd)) !== -1; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static containsTemplateVar(templateString) {\r\n        return (templateString && typeof templateString === 'string') ?\r\n            ((new SimpleTagParser(templateString)).has()) : false;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static dupWithoutVars(childObj) {\r\n        const obj = {...childObj};\r\n        for (const [key, value] of Object.entries(childObj)) {\r\n            // we should remove any variable which has a template variable\r\n            if (ObjectInterpolatorBase.containsTemplateVar(value))\r\n                delete obj[key];\r\n        }\r\n        return obj;\r\n    }\r\n    static mergeInto(target, source) {\r\n        if(Array.isArray(target) && Array.isArray((source))) {\r\n            target.splice(0, target.length, ...source);\r\n        }\r\n        else {\r\n            Object.assign(target, source);\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // {A:{a:1,b:2, c:{d:4}}\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static *iterateObjStrings(obj, keys = [], objs= []) {\r\n        let isRoot = false;\r\n        if(obj) {\r\n\r\n            // push the root object\r\n            if(objs.length === 0) { objs.push(obj); isRoot = true; }\r\n\r\n\r\n            const useKeys = Array.isArray(obj.__ProcessKeys__) ? obj.__ProcessKeys__ : Object.keys(obj);\r\n            for(let i = 0; i < useKeys.length; i++) {\r\n                const key = useKeys[i]; const value = obj[key];\r\n\r\n                if ((typeof value === 'object') && (value !== null)) {\r\n                    if(!Array.isArray(value))\r\n                        yield [obj, key, value, keys, objs];\r\n                    keys.push(key); objs.push(value);\r\n                    yield* ObjectInterpolatorBase.iterateObjStrings(value, keys, objs );\r\n                    keys.pop();  objs.pop();\r\n                }\r\n                else if (typeof value === 'string') {\r\n                    yield [obj, key, value.trim(), keys, objs];\r\n                    const regex = /^__DEBUG__\\d*$/;\r\n                    const isDebugPrint = !!key.match(regex);\r\n                    if (isDebugPrint) {\r\n                        console.log(obj[key]);\r\n                        delete obj[key];\r\n                    }\r\n                }\r\n            }\r\n\r\n            // pop the root object\r\n            if(isRoot) { objs.pop(); }\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static createPathDotNotation(keys, key) { return keys.length > 0 ? keys.join(\"\") + \"\" + key : key; }\r\n    static createObjectPath(pathDotNotation) { return pathDotNotation.split(\"\"); }\r\n    static dup(obj) { return JSON.parse(JSON.stringify(obj)); }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(obj, keyValues, options = {}) {\r\n        this._options = options;\r\n        this._options.CopyObj = this._options.CopyObj !== undefined ? this._options.CopyObj : false\r\n\r\n        this._obj = this.getCopyObj() ? ObjectInterpolatorBase.dup(obj) : obj;\r\n        this._keyValues = keyValues;\r\n\r\n        this._options.ActionOnNotFound = ReplaceObjectAction.isValidAction(this._options.ActionOnNotFound) ?\r\n            this._options.ActionOnNotFound : ReplaceObjectAction.ACTION_NONE;\r\n\r\n        this._options.KeyValueContextI = this._options.KeyValueContextI !== undefined ?\r\n            this._options.KeyValueContextI : KeyValueContextI;\r\n\r\n        this._nPass = 3;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getObj() { return this._obj; }\r\n    getOptions() { return this._options; }\r\n    getActionOnNotFound() { return this._options.ActionOnNotFound; }\r\n    getOptionKeyValueContextI() { return this._options.KeyValueContextI; }\r\n    getOptionKeyValueContextSeparator() { return this._options.KeyValueContextSeparator || \".\"; }\r\n    getCopyObj() { return this._options.CopyObj; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // There are two possible return values, either:\r\n    // 1. The not found template var, as in \"{{var}}\".\r\n    // 2. The value returned by the handler (as long as the return value is not an action to delete the key).\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI) {\r\n        let useValue = templateVar;\r\n        if(parentReplaceNotFoundHandler) {\r\n            // If the value returned by the handler is not an action, we can use the value the handler has sent us\r\n            const actionOrValue = parentReplaceNotFoundHandler(templateVar, key);\r\n            if(!setActionI(actionOrValue))\r\n                useValue = actionOrValue;\r\n        }\r\n        else\r\n            setActionI(this.getActionOnNotFound());\r\n\r\n        return useValue;\r\n\r\n    }\r\n    getKeyInterpolator(replaceKeyValues, childObj, key, value) { return null; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Keys can hold replacement parameters, which act as commands\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doInterpolateKey(replaceKeyValues, childObj, key, value){\r\n        let result = { nReplacedKeys: 0, key: key };\r\n        const keyInterpolator =  this.getKeyInterpolator(replaceKeyValues, childObj, key, value);\r\n        if(keyInterpolator)\r\n            result = await keyInterpolator.interpolate();\r\n\r\n        return result;\r\n\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async doInterpolateObj(replaceKeyValues, childObj, key, value){\r\n        let nReplacedKeys = 0;\r\n        let useValue = value;\r\n        const parentReplaceNotFoundHandler = this._options.ReplaceNotFoundHandler;\r\n        for(let i = 0; i < this._nPass; i++) {\r\n\r\n            // 'action' interface for setting local variable 'action'.  This code is kind of confusing, but,\r\n            // there is a reason for the complexity.  When we call interpolation on the string, the\r\n            // 'StringInterpolator' object, may invoke our handler to inform us it is not able to find a key.\r\n            // There are essentially three possible actions:\r\n            //   1. Do nothing, that is keep the un-replaced templateVar (we do this by returning the templateVar)\r\n            //   2. Return something that we do want to use, a common use case is to return an empty string (for example).\r\n            //   3. Delete the key from the object.  For this action, the client may return a special value to indicate\r\n            //      that we should delete the key.  The problem is we process this return value inside the handler.\r\n            //      To make this work, we check the value in our handler and set the action, which will be used,\r\n            //      later when the handler returns.\r\n            const actionI = new ActionI();\r\n\r\n            const stringInterpolator = new StringInterpolator(useValue, replaceKeyValues, {\r\n                TrackCurlyBrackets: true, ...this._options,\r\n                ReplaceNotFoundHandler:  (templateVar, key) => {\r\n                    // Return the value to be used as the replace parameter.  Note the caller may set the action,\r\n                    // which may result in this key being deleted on the object (see code below, where we test the\r\n                    // action against the delete value\r\n                    return this.notifyReplaceNotFound(replaceKeyValues, templateVar, key, parentReplaceNotFoundHandler,\r\n                        (newActionValue) => actionI.setAction(newActionValue));\r\n                }\r\n            });\r\n\r\n            let replace = await stringInterpolator.sInterpolate();\r\n            if(actionI.getAction() === ReplaceObjectAction.ACTION_NONE) {\r\n                if (useValue!== replace) {\r\n                    childObj[key] = replace;\r\n                    nReplacedKeys++;\r\n                    useValue = replace;\r\n                } else\r\n                    break;\r\n            }\r\n            else if(actionI.getAction() === ReplaceObjectAction.ACTION_DELETE) {\r\n                delete childObj[key];\r\n                break;\r\n            }\r\n            else if(actionI.getAction() === ReplaceObjectAction.ACTION_THROW) {\r\n                throw new InterpolationValueNotFoundError();\r\n            }\r\n        }\r\n\r\n        return nReplacedKeys;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getCmdInKey(key) {\r\n        let cmd = KeyCommands.KeyCmdNone;\r\n        if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY))\r\n            cmd = KeyCommands.KeyCmdQueueDelChildObjectIfEmpty\r\n        else if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_COPY_INTO_OBJ))\r\n            cmd = KeyCommands.KeyCmdCopyIntoObject;\r\n        else if(ObjectInterpolatorBase.isKeyCmd(key, REGX.CMD_KEY_COPY_INTO_PARENT_OBJ))\r\n            cmd = KeyCommands.KeyCmdCopyIntoParentObject;\r\n\r\n        return cmd;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    processDeletes(queuedDeletes) {\r\n        queuedDeletes.forEach( (pathDotNotation) => {\r\n            const path = ObjectInterpolatorBase.createObjectPath(pathDotNotation);\r\n            let itObj = this._obj;\r\n            let ownerObj = null;\r\n            let parentKey = \"\";\r\n            let parentObj = null;\r\n            let childKey = \"\";\r\n            for(let i = 0; i < path.length; i++) {\r\n                if(i === path.length - 1) {\r\n                    parentKey = childKey;\r\n                    ownerObj = parentObj;\r\n                }\r\n                childKey = path[i];\r\n                parentObj = itObj;\r\n                itObj = itObj[childKey];\r\n\r\n            }\r\n            if(parentObj && typeof parentObj === 'object') {\r\n                if(childKey)\r\n                    delete parentObj[childKey];\r\n            }\r\n            if(ownerObj && typeof ownerObj === 'object') {\r\n                if(parentKey && Object.keys(ownerObj[parentKey]).length === 0) {\r\n                    if(Array.isArray(ownerObj))\r\n                        ownerObj.splice(parentKey, 1);\r\n                    else\r\n                        delete ownerObj[parentKey];\r\n                }\r\n\r\n            }\r\n\r\n        });\r\n    }\r\n    addFlattenPaths(flattenPaths, keys) {\r\n        let currentObj = this._obj;\r\n        let flattenObjs = [];\r\n        if(Array.isArray(currentObj))\r\n                flattenObjs.push(currentObj);\r\n        for(let i = 0; i < keys.length; i++) {\r\n            const key = keys[i];\r\n            currentObj = currentObj[key];\r\n            if(Array.isArray(currentObj))\r\n                flattenObjs.push(currentObj);\r\n            else\r\n                flattenObjs = [];\r\n\r\n        }\r\n        for(let i = flattenObjs.length - 1; i >= 0; i--) {\r\n            const flattenObj = flattenObjs[i];\r\n            if(!flattenPaths.has(flattenObj))\r\n                flattenPaths.add(flattenObj);\r\n        }\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // return the interface which knows how to index into our object\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    createKeyValueContextI(keyValues) { return new (this.getOptionKeyValueContextI())(keyValues, this.getOptionKeyValueContextSeparator()); }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async interpolate() {\r\n        let nReplacedKeys = 0;\r\n\r\n        const queuedDeletes = [];\r\n        let flattenRoot = false;\r\n        const trackParentSetObjects = new Set();\r\n        const flattenPaths = new Set();\r\n        for (const [childObj, key, value, keys, objs] of ObjectInterpolatorBase.iterateObjStrings(this._obj)) {\r\n\r\n            // Imagine a nested object - where we may have parameters to replace and where the childObj has some keys\r\n            // which may be used as replacement parameters\r\n            const replaceKeyValues =\r\n                this.createKeyValueContextI({ ...this._keyValues, ...ObjectInterpolatorBase.dupWithoutVars(childObj) });\r\n\r\n            const keyReplaceResult = await this.doInterpolateKey(replaceKeyValues, childObj, key, value);\r\n            nReplacedKeys += keyReplaceResult.nReplacedKeys;\r\n            const cmd = this.getCmdInKey(keyReplaceResult.key);\r\n            if((cmd === KeyCommands.KeyCmdNone) ||\r\n                    (cmd === KeyCommands.KeyCmdCopyIntoObject) ||\r\n                    (cmd === KeyCommands.KeyCmdCopyIntoParentObject)) {\r\n\r\n                nReplacedKeys += await this.doInterpolateObj(replaceKeyValues, childObj, key, value);\r\n\r\n                if (cmd === KeyCommands.KeyCmdCopyIntoObject) {\r\n                    const objCandidate = childObj[key];\r\n                    if ((typeof objCandidate === 'object') && (objCandidate !== null)) {\r\n                        Object.assign(childObj, objCandidate);\r\n                        delete childObj[key];\r\n                    }\r\n                }\r\n                else if(cmd === KeyCommands.KeyCmdCopyIntoParentObject) {\r\n                    // The parent object and the parent key can be found by looking at the objs/keys\r\n                    // (which tracks all iterated objects)\r\n                    const parentObj = objs.length > 1 ? objs[objs.length - 2] : null;\r\n                    const parentKey = keys.length > 0 ? keys[keys.length - 1] : \"\";\r\n\r\n                    if(parentObj && parentKey) {\r\n                        let wasSetOn = false;\r\n                        const objCandidate = childObj[key];\r\n                        if (objCandidate !== undefined) {\r\n\r\n                            // Consider the case where we want to load multiple objects to the same element position on\r\n                            // the parent.  (reference Test case **).  This case is when the parentObj is an array\r\n                            const wasPreviouslySetOn = trackParentSetObjects.has(parentObj[parentKey]);\r\n                            if(wasPreviouslySetOn && Array.isArray(objCandidate))\r\n                                parentObj[parentKey].push(...objCandidate);\r\n                            else {\r\n                                if(Array.isArray(parentObj)) {\r\n                                    parentObj[parentKey] = objCandidate;\r\n                                    if(Array.isArray(objCandidate))\r\n                                        trackParentSetObjects.add(parentObj[parentKey]);\r\n                                }\r\n                                else {\r\n                                    ObjectInterpolatorBase.mergeInto(parentObj, objCandidate)\r\n                                    queuedDeletes.push(ObjectInterpolatorBase.createPathDotNotation(keys, key));\r\n                                }\r\n                            }\r\n\r\n                            if(Array.isArray(parentObj)) {\r\n                                this.addFlattenPaths(flattenPaths, keys);\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                    else\r\n                        throw new Error(\"No parent object to merge\");\r\n                }\r\n                else if(keyReplaceResult.nReplacedKeys > 0) {\r\n                    childObj[keyReplaceResult.key] = childObj[key];\r\n                    delete childObj[key];\r\n                }\r\n\r\n            }\r\n            else if(cmd === KeyCommands.KeyCmdQueueDelChildObjectIfEmpty) {\r\n                queuedDeletes.push(ObjectInterpolatorBase.createPathDotNotation(keys, key));\r\n            }\r\n        }\r\n        for(const flattenObj of flattenPaths)\r\n             ObjectInterpolatorBase.mergeInto(flattenObj, flattenObj.flat());\r\n\r\n        this.processDeletes(queuedDeletes);\r\n\r\n        return { obj: this.getObj(), nReplacedKeys: nReplacedKeys };\r\n    }\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Takes a function expression with arguments and returns abstract syntax tree\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ParseFunctionCalls extends BaseAST {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(expression, options) {\r\n        super(expression);\r\n        this._options = options;\r\n        this._options.OptionStringArgQuoted = this._options.OptionStringArgQuoted !== undefined ?\r\n            this._options.OptionStringArgQuoted : false;\r\n    }\r\n    getOptionStringArgQuoted() { return this._options.OptionStringArgQuoted; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // We need to pass over any group of characters enclosed in single quotes, double quotes or array brackets as in:\r\n    //  * 'skip this stuff'\r\n    //  * \"skip this stuff\"\r\n    //  * [skip this stuff]\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipGroupedChars() {\r\n        let beginChar = this.cAtI();\r\n\r\n        // Special token which indicates the start of a group, one of: ' \" [\r\n        if(BaseAST.isGroupTokenBegin(beginChar)) {\r\n            let inTokens = [];\r\n            inTokens.push(beginChar);\r\n\r\n            // We need to scan ahead until we find the matching end token\r\n            while(this.hasChars() && inTokens.length > 0) {\r\n\r\n                // Use the last group token pushed - and skip it\r\n                beginChar = inTokens[inTokens.length - 1];\r\n                this.skip();\r\n\r\n                // It is possible that we could have nested group tokens, consider: [\"4\", \"1\"]\r\n                while (this.hasChars()) {\r\n\r\n                    // 1st - check if we have a matching token to our current beginChar, one of: ' \" ]\r\n                    if(this.cAtIIsGroupTokenEnd(beginChar)) {\r\n                        inTokens.pop();\r\n                        break;\r\n                    }\r\n                    else {\r\n                        // 2nd - we can consider that we may have a nested group token, if we do, we will work with this\r\n                        // one until we find its matching end token\r\n                        const newBeginChar = this.cAtI();\r\n                        if (BaseAST.isGroupTokenBegin(newBeginChar)) {\r\n                            beginChar = newBeginChar;\r\n                            inTokens.push(newBeginChar);\r\n                            break;\r\n                        }\r\n                    }\r\n                    // If we got here, we are happily moving along, consuming characters between our start group token\r\n                    // while we attempt to find a matching end to our group\r\n                    this.skip();\r\n                }\r\n            }\r\n            // if we have unmatched ending tokens we should raise and exception\r\n            if(inTokens.length > 0)\r\n                throw new Error(`Parse error - mismatch on some ending symbols: [${inTokens.map((symbol) => `'${symbol}'`).join(\",\")}]`);\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    skipNonSpecialChars() {\r\n        while (this.hasChars() && !this.cAtIIsWhite() && !this.cAtIOIsOpen() && !this.cAtIOIsClose() && !this.cAtIIsArgSeporator()) {\r\n            this.skip();\r\n        }\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    readToken() {\r\n        this.skipWhitespace();\r\n\r\n        let token;\r\n        if (!this.cAtIOIsOpen() && !this.cAtIOIsClose()) {\r\n\r\n            // our token should start at this index\r\n            const start = this.getI();\r\n\r\n            this.skipGroupedChars();\r\n            this.skipNonSpecialChars();\r\n\r\n            // our token should end at this index\r\n            const end = this.getI();\r\n\r\n            // slice out our token\r\n            token = this.getExpr().slice(start, end);\r\n        }\r\n        else\r\n            throw new Error(`Parse error - Unexpected '(' or ')' missing function name`);\r\n\r\n        return token;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseArguments() {\r\n        let args = [];\r\n        while (this.hasChars() && !this.cAtIOIsClose()) {\r\n            args.push(this.parseExpression());\r\n            this.skipWhitespace();\r\n\r\n            if (this.cAtIIsArgSeporator())\r\n                this.skip();  // Skip comma\r\n        }\r\n        return args;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parseExpression() {\r\n        let token = this.readToken();\r\n\r\n        if (/^true|false$/.test(token)) {\r\n            /* literal true or false */\r\n        }\r\n        else if(/^null$/.test(token)) {\r\n            /* literal null */\r\n        }\r\n        else if (/^[a-zA-Z_][\\w]*$/.test(token)) {\r\n            this.skipWhitespace();\r\n\r\n            // make sure we have an open bracket '(' - and skip it\r\n            if (this.cAtIOIsOpen()) {\r\n                /* function name */\r\n                let funcName = token;\r\n\r\n                this.skip(); // Skip\r\n\r\n                // parse the arguments\r\n                let args = this.parseArguments();\r\n\r\n                // make sure we have an open bracket '(' - and skip it\r\n                this.skipWhitespace();\r\n                if (!this.cAtIOIsClose())\r\n                    throw new Error(`Parse error - Expected '(' after function name ${funcName}`);\r\n                this.skip(); // Skip ')'\r\n\r\n                return {\r\n                    type: 'FunctionCall',\r\n                    name: funcName,\r\n                    arguments: args\r\n                };\r\n            }\r\n            else if(this.getOptionStringArgQuoted())\r\n                throw new Error(`Parse error - Expected '(' after function name ${token}`);\r\n            else {\r\n                // getting here implies that the token is a string parameter and not a function call, it also means\r\n                // we are missing single quotes around the param.  However, we should have single quotes around\r\n                // string params.  Let's add them\r\n               token = `'${token}'`;\r\n            }\r\n        }\r\n\r\n        return {\r\n          type: 'Literal',\r\n          value: token\r\n        };\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parse() {\r\n        this.notifyParseStart();\r\n\r\n        // create the abstract syntax tree\r\n        const asTree =  this.parseExpression();\r\n\r\n        this.notifyParseComplete(asTree);\r\n\r\n        return asTree;\r\n    }\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Derived class handles evaluation of abstract syntax tree\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass EvaluateFunctions extends ParseFunctionCalls {\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertNum(value) {\r\n        let result = undefined;\r\n        if((typeof value === 'string') && (value !== '')) {\r\n            const num = Number(value);\r\n            if (!isNaN(num))\r\n                result = num;\r\n        }\r\n\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertString(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^['\"](.*)['\"]$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1];\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertBool(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^(true|false)$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1] === 'true';\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertNull(value) {\r\n        let result = undefined;\r\n        const matched = value.match(/^(null)$/)\r\n        if(Array.isArray(matched) && (matched.length === 2))\r\n            result = matched[1] === 'null' ? null : undefined;\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertObj(value) {\r\n        let result = undefined;\r\n        try {\r\n            result = JSON.parse(value);\r\n        }\r\n        catch(er) { throw new Error('Failed to convert value to Json object'); }\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static convertToLiteral(value) {\r\n        let result = value;\r\n        const num = EvaluateFunctions.convertNum(value);\r\n        if(num !== undefined)\r\n            result = num;\r\n        else\r\n        {\r\n            const str = EvaluateFunctions.convertString(value);\r\n            if(str !== undefined)\r\n                result = str;\r\n            else\r\n            {\r\n                const bool = EvaluateFunctions.convertBool(value);\r\n                if(bool !== undefined)\r\n                    result = bool;\r\n                else\r\n                {\r\n                    const nullValue = EvaluateFunctions.convertNull(value);\r\n                    if(nullValue !== undefined)\r\n                        result = nullValue\r\n                    else\r\n                    {\r\n                        try {\r\n                            const obj = EvaluateFunctions.convertObj(value);\r\n                            if (obj !== undefined)\r\n                                result = obj;\r\n                        }\r\n                        catch(er) {\r\n                            if(typeof value === 'string')\r\n                                return value;\r\n                            else\r\n                                throw new Error('Invalid type in convertToLiteral');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static invokeParsedFunction(sender, asTree, context) {\r\n\r\n        // If it's a literal, return the value directly\r\n        if (asTree.type === 'Literal')\r\n            return EvaluateFunctions.convertToLiteral(asTree.value);\r\n        else if (asTree.type === 'FunctionCall') {\r\n            const func = context[asTree.name];\r\n            if (typeof func !== 'function')\r\n                throw new Error(`Function ${asTree.name} is not defined in the context`);\r\n\r\n            // Recursively evaluate and collect arguments\r\n            const args = asTree.arguments.map(arg => EvaluateFunctions.invokeParsedFunction(sender, arg, context));\r\n\r\n            // Invoke the function with the evaluated arguments\r\n            return func(sender, ...args);\r\n        } else {\r\n            throw new Error(\"Unknown AST node type\");\r\n        }\r\n    }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(parent, expression, keyValueContext, fContext, options = {}) {\r\n        super(expression, options);\r\n        this._parent = parent;\r\n        this._keyValueContext = keyValueContext;\r\n        this._fContext = fContext;\r\n        this._asTree = null;\r\n    }\r\n    getParent() { return this._parent; }\r\n    getKeyValueContext() { return this._keyValueContext; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    parse() {\r\n        this._asTree = super.parse();\r\n        const evaluation =  EvaluateFunctions.invokeParsedFunction(this, this._asTree, this._fContext);\r\n        return evaluation;\r\n    }\r\n\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// Attempts to resolve undefined parameters as embedded function calls, during interpolation.  Any key prepended with\r\n// \"->\", will be parsed as a function.  For example, interpolation parameters like:\r\n//   {{->Add(1,2)}}\r\n//  Will be parsed as function Add(1,2).  As long as \"Add\" function exists in provided context, the function will be\r\n//  invoked.  The resulting value will be used as the replacement parameter\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass ObjectInterpolator extends ObjectInterpolatorBase {\r\n    static convertToString(value) {\r\n        let result = value;\r\n        if((typeof value === 'number') || (typeof value === 'bigint') ||(typeof value === 'boolean') || (typeof value === 'string'))\r\n            result = value.toString();\r\n        else if(value === null)\r\n            result = 'null';\r\n        else if(value === undefined)\r\n            result = undefined;\r\n        else if(Array.isArray(value))\r\n            result = JSON.stringify(value);\r\n        else\r\n            console.error('Failed to convert to primitive type');\r\n\r\n        return result;\r\n    }\r\n\r\n    static processExpression(expression) {\r\n        const e = new ExpressionParser(expression);\r\n        return e.evaluate();\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    static getFunctionExpression(expression) {\r\n        let result = \"\";\r\n        if(expression) {\r\n            const regX = new RegExp(REGX.FUNCTION_TAG)\r\n            const match = regX.exec(expression);\r\n            if(Array.isArray(match) && (match.length === 2))\r\n                result = match[1];\r\n        }\r\n\r\n        return result;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(obj, keyValues, parseFContext, options = {}) {\r\n        super(obj, keyValues, options);\r\n        this._parseFContext = parseFContext ? parseFContext : {};\r\n        this._buildInFContext = {\r\n            '': (sender, expression) => ObjectInterpolator.processExpression(expression),\r\n            'Exp': (sender, expression) => ObjectInterpolator.processExpression(expression),\r\n            '_': (sender, value) => ObjectInterpolator.convertToString(value)\r\n        };\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getKeyInterpolator(replaceKeyValues, childObj, key, value) {\r\n        return new KeyInterpolator(key, replaceKeyValues, {}, {ChildObj: childObj});\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI) {\r\n        const functionExpression = ObjectInterpolator.getFunctionExpression(key);\r\n        if(this._parseFContext && functionExpression) {\r\n            const evaluateF = new EvaluateFunctions(this, functionExpression, keyValueContext,\r\n                {...this._parseFContext, ...this._buildInFContext });\r\n            return evaluateF.parse();\r\n        }\r\n        else {\r\n            return super.notifyReplaceNotFound(keyValueContext, templateVar, key, parentReplaceNotFoundHandler, setActionI);\r\n        }\r\n    }\r\n}\r\n\r\nclass TransformKeyExpression {\r\n    static validateTransformMatch(match) { return Array.isArray(match) && (match.length === 3); }\r\n    constructor(key, childObj) {\r\n        this._key = key;\r\n        this._childObj = childObj;\r\n    }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // The goal of this function is to identify Keys in the form 1: '<-IF(expression)' or '<--IF(expression)' and\r\n    // transform them to form 2: {{->( '${expression}' ) }}.  Externally, at the interface level, the first form is\r\n    // clearer and easier to understand.\r\n    //\r\n    // Returns object containing:\r\n    //   Cmd - will be an empty string if the key was not transformed or either <- or <-- (if it was transformed).\r\n    //   Key - will be the transformed string or the unchanged key (when Cmd is an empty string).\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    transformFromIf(key, wholeMatchString, cmdPart, reverse = false) {\r\n        let cmd = \"\";\r\n        let cmdType = \"\";\r\n\r\n        const endIndex = key.lastIndexOf(\")\");\r\n        const startIndex = wholeMatchString.indexOf(\"(\");\r\n        if((endIndex === wholeMatchString.length - 1) && (startIndex !== -1)) {\r\n\r\n            const expression = key.slice(startIndex + 1, endIndex);\r\n            const useExpression = reverse ? `!(${expression})` : expression;\r\n            key = `{{->( \"${useExpression}\" ) }}`;\r\n            cmdType = REGX.CMD_KEY_IF_BLOCK_START;\r\n            cmd = cmdPart;\r\n        }\r\n        return { CmdType: cmdType, Cmd: cmd, Key: key }\r\n    }\r\n    reverseTransformFirstIfKey(key, wholeMatchString, cmdPart) {\r\n        let result = null;\r\n\r\n        for(const [siblingKey, value] of Object.entries(this._childObj)) {\r\n            const matchIf = siblingKey.match(new RegExp(REGX.CMD_KEY_IF_BLOCK_START, 'i'));\r\n            if(TransformKeyExpression.validateTransformMatch(matchIf)) {\r\n                result = this.transformFromIf(siblingKey, matchIf[0], matchIf[1], true  /* reverse */);\r\n                break;\r\n            }\r\n        }\r\n        return result !== null ? result : { CmdType: REGX.CMD_KEY_ELSE_BLOCK, Cmd: cmdPart, Key: `false` }\r\n\r\n    }\r\n    transformElse(key, wholeMatchString, cmdPart) {\r\n        const result = this.reverseTransformFirstIfKey(key, wholeMatchString, cmdPart);\r\n        const cmd = result ? result.Cmd : \"\";\r\n        const useKey = result ? result.Key : key;\r\n        return { CmdType: REGX.CMD_KEY_ELSE_BLOCK, Cmd: cmd, Key: useKey };\r\n    }\r\n    transform() {\r\n        const key = this._key.trim();\r\n        let result = { CmdType: \"\", Cmd: \"\", Key: key }\r\n        const matchIf = key.match(new RegExp(REGX.CMD_KEY_IF_BLOCK_START, 'i'));\r\n        if(TransformKeyExpression.validateTransformMatch(matchIf))\r\n            result = this.transformFromIf(key, matchIf[0], matchIf[1]);\r\n        else {\r\n            const matchElse = key.match(new RegExp(REGX.CMD_KEY_ELSE_BLOCK, 'i'));\r\n            if(TransformKeyExpression.validateTransformMatch(matchElse))\r\n                result = this.transformElse(key, matchElse[0], matchElse[1]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n}\r\n//---------------------------------------------------------------------------------------------------------------------\r\n//\r\n// This type is used specifically in cases of key replacement.  There is a bit of recursion here as this class\r\n// subclasses from ObjectInterpolator.  Further, this class is instantiated as part of the 'getKeyInterpolator' method.\r\n// To avoid infinite recursion we must insure we do not re-interpolate over key, we do this by turning off this\r\n// unneeded functionality by overriding 'getKeyInterpolator' and returning null.\r\n// It is generally idea to reuse ObjectInterpolator as the base class, since we can add the power of object expression\r\n// parsing, without duplicating the functionality.  However, this approach is subject to change and generally supporting\r\n// of else branch will require some rework on this class.\r\n//\r\n//---------------------------------------------------------------------------------------------------------------------\r\nclass KeyInterpolator extends ObjectInterpolator {\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    //\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    constructor(key, keyValues, parseFContext, options = {}) {\r\n\r\n        const transformKeyExpression = new TransformKeyExpression(key, options.ChildObj);\r\n        const transformData = transformKeyExpression.transform();\r\n        super({Key: transformData.Key}, keyValues.getKeyValues(), parseFContext, options);\r\n\r\n        this._cmdType = transformData.CmdType;\r\n        this._cmd = transformData.Cmd;\r\n\r\n        this._originalKey = key;\r\n    }\r\n    getChildObj() { return this.getOptions().ChildObj; }\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // Turn off interpolation over the key\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    getKeyInterpolator(replaceKeyValues, childObj, key, value) { return null; }\r\n\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    // We override 'interpolate', to support slightly different return interface:\r\n    //   { nReplacedKeys: n, key: s }\r\n    // Additionally, the goal is to transform the key in cases where the IF directive is used\r\n    //-----------------------------------------------------------------------------------------------------------------\r\n    async interpolate() {\r\n        const iResult = await super.interpolate();\r\n\r\n        let resultingKey;\r\n\r\n        // 1. The key was transformed, we should assemble the key to the following form:\r\n            // * '<-<result> or <--<result>' where result is the actual interpolation result.\r\n        // Note case 1 may be a problem in cases where the replaceable keys are not currently resolvable.  We may detect\r\n        // this upfront with:  ((new SimpleTagParser(templateString)).has())\r\n        if(this._cmd)\r\n            resultingKey = `${this._cmd}${iResult.obj.Key}`;\r\n        else\r\n            resultingKey = iResult.obj.Key;\r\n\r\n\r\n        return { nReplacedKeys: iResult.nReplacedKeys, key: resultingKey };\r\n    }\r\n}\r\n\r\nexport { ObjectInterpolator, StringInterpolator, ObjectInterpolatorBase, SinglePassTagReplacer, SimpleTagParser,\r\n    InterpolationValueNotFoundError, ReplaceObjectAction, KeyValueContextI, QueryObjKeyValueContextI};\r\n\r\n"],"names":["ExpressionParseError","Error","constructor","reason","super","REGX","Object","freeze","OPERAND_NUMBERS","OPERAND_STRING","OPERAND_LOGICAL_TRUE","OPERAND_LOGICAL_FALSE","OPERAND_POS_INFINITY","OPERAND_NEG_INFINITY","MATH_OPERATORS","TERNARY_OPERATORS","LOGICAL_OPERATORS","EQUALITY_OPERATORS","Stack","this","_values","size","length","empty","peek","undefined","push","value","pop","popN","n","result","i","unshift","toNum","s","parseFloat","isNaN","toBool","toOperand","er","isQuote","char","trim","firstChar","lastChar","toStr","toTypePair","a","b","va","vb","operatorData","precedence","associativity","NArgs","f","c","operatorKeys","keys","InfixNotationParser","expression","_expression","_isOperand","RegExp","_regXParseExpression","isOperator","token","includes","getOperator","isAssociative","type","comparePrecedence","op1","op2","hasHigherPrecedence","hasLowerPrecedence","hasSamePrecedence","tokenize","match","isOperand","test","toPostfix","outputQueue","tokens","Array","isArray","operatorStack","forEach","topOperatorStack","poppedSymbol","operator","ExpressionParser","evaluate","postFix","stack","args","slice","FUNCTION_TAG","CMD_KEY_QUEUE_DEL_CHILD_OBJ_IF_EMPTY","CMD_KEY_COPY_INTO_OBJ","CMD_KEY_COPY_INTO_PARENT_OBJ","CMD_KEY_IF_BLOCK_START","CMD_KEY_ELSE_BLOCK","InterpolationValueNotFoundError","BaseAST","isWhitespace","isOpen","isClose","isCurlyOpen","isCurlyClose","isArgSeparate","isSquareOpen","isSquareClose","isGroupTokenBegin","isMatchingGroupTokenEnd","beginChar","_index","notifyParseStart","notifyParseComplete","parseResult","getI","getExpr","cAtI","cAtIIsWhite","skip","hasChars","nChars","cAtIisCurlyOpen","cAtIisCurlyClose","cAtIOIsOpen","cAtIOIsClose","cAtIIsArgSeporator","cAtIIsGroupTokenEnd","cAtIIsTag","tag","hasTag","tagLen","nFoundSymbols","skipWhitespace","TagParser","options","_options","_startTag","_endTag","_ignoreEnclosed","Opens","Closes","_curlyBracketStack","_replacementEdits","TrackCurlyBrackets","getTrackCurlyBrackets","createTemplateKey","key","cAtIIsBeginTag","cAtIIsEndTag","isTag","cAtIisOpen","closing","indexOfOpen","indexOf","cAtIisClosing","matchedClosing","lastClosing","trackEnclosedChars","closingChar","parseToken","start","end","iStartToken","iEndToken","Match","Key","IStartToken","IEndToken","applyReplacementEdits","SinglePassTagReplacer","customStringReplacer","SimpleTagParser","has","matchResultObj","replacementEdits","lastIndex","ReplaceWith","cb","_cb","notifyParseResult","offset","replace","join","PromisesHandler","isPromise","p","then","_promises","_promiseKeys","_matchedOn","_nextKeyId","hasPromises","allSettled","Promise","processPromises","replaceKeys","NResolved","NRejected","results","promiseKey","pResult","status","getNextPromiseKey","add","matchedOn","pCandidate","addedKey","defaultOptions","CovertValueToType","KeyValueContextI","keyValues","_keyValues","getKeyValues","get","StringInterpolator","templateStr","keyValuesI","_templateStr","_keyValuesI","ReplaceNotFoundHandler","templateVar","getOptionConvertType","getOptionReplaceNotFoundHandler","getValueInMap","doReplaces","simpleReplace","promisesHandler","sender","string","replaceCandidate","canInvokeNotFoundHandler","JSON","stringify","resultingS","promiseReplaceKeys","sInterpolate","ReplaceObjectAction","ACTION_NONE","Symbol","ACTION_DELETE","ACTION_THROW","isValidAction","action","isValid","ActionI","_action","getAction","setAction","newActionValue","actionSet","KeyCommands","KeyCmdNone","KeyCmdCopyIntoObject","KeyCmdCopyIntoParentObject","KeyCmdDelKey","KeyCmdQueueDelChildObjectIfEmpty","ObjectInterpolatorBase","isKeyCmd","cmd","search","containsTemplateVar","templateString","dupWithoutVars","childObj","obj","entries","mergeInto","target","source","splice","assign","iterateObjStrings","objs","isRoot","useKeys","__ProcessKeys__","regex","console","log","createPathDotNotation","createObjectPath","pathDotNotation","split","dup","parse","CopyObj","_obj","getCopyObj","ActionOnNotFound","_nPass","getObj","getOptions","getActionOnNotFound","getOptionKeyValueContextI","getOptionKeyValueContextSeparator","KeyValueContextSeparator","notifyReplaceNotFound","keyValueContext","parentReplaceNotFoundHandler","setActionI","useValue","actionOrValue","getKeyInterpolator","replaceKeyValues","doInterpolateKey","nReplacedKeys","keyInterpolator","interpolate","doInterpolateObj","actionI","stringInterpolator","getCmdInKey","processDeletes","queuedDeletes","path","itObj","ownerObj","parentKey","parentObj","childKey","addFlattenPaths","flattenPaths","currentObj","flattenObjs","flattenObj","createKeyValueContextI","trackParentSetObjects","Set","keyReplaceResult","objCandidate","flat","ParseFunctionCalls","OptionStringArgQuoted","getOptionStringArgQuoted","skipGroupedChars","inTokens","newBeginChar","map","symbol","skipNonSpecialChars","readToken","parseArguments","parseExpression","funcName","name","arguments","asTree","EvaluateFunctions","convertNum","num","Number","convertString","matched","convertBool","convertNull","convertObj","convertToLiteral","str","bool","nullValue","invokeParsedFunction","context","func","arg","parent","fContext","_parent","_keyValueContext","_fContext","_asTree","getParent","getKeyValueContext","ObjectInterpolator","convertToString","toString","error","processExpression","getFunctionExpression","exec","parseFContext","_parseFContext","_buildInFContext","Exp","_","KeyInterpolator","ChildObj","functionExpression","TransformKeyExpression","validateTransformMatch","_key","_childObj","transformFromIf","wholeMatchString","cmdPart","reverse","cmdType","endIndex","lastIndexOf","startIndex","CmdType","Cmd","reverseTransformFirstIfKey","siblingKey","matchIf","transformElse","useKey","transform","matchElse","transformData","_cmdType","_cmd","_originalKey","getChildObj","iResult","resultingKey","useSeparator","_useSeparator","q","arr_deref","o","ref","reduce","err"],"mappings":"kCAIA,MAAMA,UAA6BC,MAAQ,WAAAC,CAAYC,GAASC,MAAMD,IAEtE,MAAME,EAAOC,OAAOC,OAAO,CACvBC,gBAAiB,mBACjBC,eAAgB,0BAChBC,qBAAsB,OACtBC,sBAAuB,QACvBC,qBAAsB,WACtBC,qBAAsB,YACtBC,eAAgB,8BAChBC,kBAAmB,UACnBC,kBAAmB,oBACnBC,mBAAoB,cASxB,MAAMC,EAIF,WAAAhB,GAAgBiB,KAAKC,QAAU,EAAK,CAKpC,QAAIC,GAAS,OAAOF,KAAKC,QAAQE,MAAS,CAC1C,KAAAC,GAAU,OAAqB,IAAdJ,KAAKE,IAAa,CACnC,IAAAG,GAAS,OAAOL,KAAKI,aAAUE,EAAYN,KAAKC,QAAQD,KAAKC,QAAQE,OAAS,EAAK,CAKnF,IAAAI,CAAKC,GAASR,KAAKC,QAAQM,KAAKC,EAAS,CACzC,GAAAC,GAAQ,OAAOT,KAAKI,aAAUE,EAAYN,KAAKC,QAAQQ,KAAQ,CAC/D,IAAAC,CAAKC,GACD,MAAMC,EAAS,GACf,GAAIZ,KAAKE,MAAQS,EACb,IAAK,IAAIE,EAAI,EAAGA,EAAIF,EAAGE,IACnBD,EAAOE,QAAQd,KAAKS,OAE5B,OAAOG,CACV,EAWL,SAASG,EAAMC,GACX,MAAMJ,EAASK,WAAWD,GAC1B,GAAIE,MAAMN,GAGN,MAAM,IAAI/B,EAAqB,qBAAqBmC,eAFpD,OAAOJ,CAGf,CAIA,SAASO,EAAOH,GACZ,GAAU,SAANA,IAAwB,IAANA,EAClB,OAAO,EACN,GAAU,UAANA,IAAyB,IAANA,EACxB,OAAO,EAEP,MAAM,IAAInC,EAAqB,qBAAqBmC,eAC5D,CAyBA,SAASI,EAAUJ,GACf,IACI,OAAOD,EAAMC,EAChB,CACD,MAAMK,GACF,IACI,OAAOF,EAAOH,EACjB,CACD,MAAMK,GACF,OA1BZ,SAAeL,GACX,SAASM,EAAQC,GAAQ,MAAiB,MAATA,GAA2B,MAATA,CAAgB,CACnE,IAAIX,EAASI,EAAEQ,OACf,KAAGZ,EAAOT,OAAS,GAOf,MAAM,IAAItB,EAAqB,qBAAqBmC,eAPlC,CAClB,MAAMS,EAAYb,EAAO,GACnBc,EAAWd,EAAOA,EAAOT,OAAS,GACxC,IAAKmB,EAAQG,KAAeH,EAAQI,GAChC,MAAM,IAAI7C,EAAqB,qBAAqBmC,sCAC3D,CAID,OAAOJ,CACX,CAamBe,CAAMX,EAChB,CACJ,CACL,CAKA,SAASY,EAAWC,EAAGC,GACnB,MAAMC,EAAKX,EAAUS,GACfG,EAAKZ,EAAUU,GACrB,UAAUC,UAAcC,EACpB,MAAO,CAACD,EAAIC,GAEZ,MAAM,IAAInD,EAAqB,qDAAqDgD,UAAUC,IACtG,CAOA,MAAMG,EAAe,CACjB,IAAK,CAAEC,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,WAAa,MAAM,IAAIxD,EAAqB,wBAAyB,GAC3H,IAAK,CAAEqD,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,WAAa,MAAM,IAAIxD,EAAqB,6BAA8B,GAChI,KAAM,CAAEqD,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,EAAGQ,GAAK,OAAOnB,EAAOU,GAAKT,EAAUU,GAAKV,EAAUkB,KACvH,IAAK,CAAEJ,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAAK,OAAOf,EAAMc,IAAMd,EAAMe,KAChG,IAAK,CAAEI,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAAK,OAAOf,EAAMc,GAAKd,EAAMe,KAC/F,IAAK,CAAEI,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAAK,OAAOf,EAAMc,GAAKd,EAAMe,KAC/F,IAAK,CAAEI,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAAK,OAAOf,EAAMc,GAAKd,EAAMe,KAC/F,IAAK,CAAEI,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAAK,OAAOf,EAAMc,GAAKd,EAAMe,KAE/F,KAAM,CAAEI,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAC/D,MAAOC,EAAIC,GAAMJ,EAAWC,EAAGC,GAC/B,OAAOC,IAAOC,CACtB,GACI,KAAM,CAAEE,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAC/D,MAAOC,EAAIC,GAAMJ,EAAWC,EAAGC,GAC/B,OAAOC,IAAOC,CACtB,GACI,IAAK,CAAEE,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,GAC3D,OAAQV,EAAOU,EACvB,GACI,KAAM,CAAEK,WAAY,GAAIC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAAK,OAAOX,EAAOU,IAAMV,EAAOW,KACpG,KAAM,CAAEI,WAAY,GAAIC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAAK,OAAOX,EAAOU,IAAMV,EAAOW,KACpG,KAAM,CAAEI,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAAK,OAAOf,EAAMc,IAAMd,EAAMe,KACjG,KAAM,CAAEI,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAAK,OAAOf,EAAMc,IAAMd,EAAMe,KACjG,IAAK,CAAEI,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAAK,OAAOf,EAAMc,GAAKd,EAAMe,KAC/F,IAAK,CAAEI,WAAY,EAAGC,cAAe,IAAKC,MAAO,EAAGC,EAAE,SAASR,EAAGC,GAAK,OAAOf,EAAMc,GAAKd,EAAMe,MAE7FS,EAAepD,OAAOqD,KAAKP,GAOjC,MAAMQ,EAIF,WAAA1D,CAAY2D,GACR1C,KAAK2C,YAAcD,EACnB1C,KAAK4C,WACD,IAAIC,OAAO,IAAI3D,EAAKI,oBAAoBJ,EAAKG,qBAAqBH,EAAKK,0BAA0BL,EAAKM,2BAA2BN,EAAKO,0BAA0BP,EAAKQ,yBAEzKM,KAAK8C,qBACD,IAAID,OAAO,GAAG3D,EAAKI,kBAAkBJ,EAAKK,wBAAwBL,EAAKM,yBAAyBN,EAAKO,wBAAwBP,EAAKQ,wBAAwBR,EAAKG,mBAAmBH,EAAKS,kBAAkBT,EAAKW,qBAAqBX,EAAKY,sBAAsBZ,EAAKU,oBAAoB,IAC9R,CAID,UAAAmD,CAAWC,GAAS,OAAOT,EAAaU,SAASD,EAAS,CAC1D,WAAAE,CAAYF,GAAS,OAAOf,EAAae,EAAS,CAClD,aAAAG,CAAcH,EAAOI,GAAQ,OAAOpD,KAAKkD,YAAYF,GAAOb,gBAAkBiB,CAAO,CACrF,iBAAAC,CAAkBC,EAAKC,GAAO,OAAOvD,KAAKkD,YAAYI,GAAKpB,WAAalC,KAAKkD,YAAYK,GAAKrB,UAAa,CAC3G,mBAAAsB,CAAoBF,EAAKC,GAAO,OAAOvD,KAAKqD,kBAAkBC,EAAKC,GAAO,CAAI,CAC9E,kBAAAE,CAAmBH,EAAKC,GAAO,OAAOvD,KAAKqD,kBAAkBC,EAAKC,GAAO,CAAI,CAC7E,iBAAAG,CAAkBJ,EAAKC,GAAO,OAA4C,IAArCvD,KAAKqD,kBAAkBC,EAAKC,EAAa,CAC9E,QAAAI,GAAa,OAAO3D,KAAK2C,YAAYiB,MAAM5D,KAAK8C,qBAAwB,CACxE,SAAAe,CAAUb,GAAS,OAAOhD,KAAK4C,WAAWkB,KAAKd,EAAS,CAKxD,SAAAe,GACI,MAAMC,EAAc,GACdC,EAASjE,KAAK2D,WAEpB,IAAGO,MAAMC,QAAQF,GAuFb,MAAM,IAAIpF,EAAqB,iDAvFT,CACtB,MAAMuF,EAAgB,IAAIrE,EA6E1B,IA5EAkE,EAAOI,SAAQrB,IAEX,GAAIhD,KAAK6D,UAAUb,GACfgB,EAAYzD,KAAKyC,QAGhB,GAAc,MAAVA,EACLoB,EAAc7D,KAAKyC,QAIlB,GAAc,MAAVA,EAAe,CACpB,KAAOoB,EAAclE,KAAO,GAA8B,MAAzBkE,EAAc/D,QAC3C2D,EAAYzD,KAAK6D,EAAc3D,OAGnC,KAAK2D,EAAclE,KAAO,GAAgC,MAAzBkE,EAAc/D,QAG3C,MAAM,IAAIxB,EAAqB,0CAF/BuF,EAAc3D,KAGrB,MAEI,GAAIT,KAAK+C,WAAWC,GAAQ,CAC7B,IAAIsB,EAAmBF,EAAc/D,OAIrC,GAAI+D,EAAchE,SAAiC,MAArBkE,GAAuC,MAAVtB,EACvDoB,EAAc7D,KAAKyC,QAGlB,GAAa,MAAVA,EAAe,CAYnB,IAAIuB,EAAe,KACnB,MAAOH,EAAchE,SAAS,CAE1B,GADAmE,EAAeH,EAAc3D,MACT,MAAjB8D,EAAsB,CACrBH,EAAc7D,KAAK,MACnB,KACH,CAEGyD,EAAYzD,KAAKgE,EACxB,CACD,GAAoB,MAAjBA,EACC,MAAM,IAAI1F,EAAqB,2BACtC,MAGI,GAAKmB,KAAKwD,oBAAoBR,EAAOsB,IACrCtE,KAAK0D,kBAAkBV,EAAOsB,IAAqBtE,KAAKmD,cAAcH,EAAO,KAC9EoB,EAAc7D,KAAKyC,OAChB,CAIH,KAAOsB,GAA0C,MAArBA,IAA8BtE,KAAKyD,mBAAmBT,EAAOsB,IACpFtE,KAAK0D,kBAAkBV,EAAOsB,IAAqBtE,KAAKmD,cAAcH,EAAO,OAC9EgB,EAAYzD,KAAK6D,EAAc3D,OAC/B6D,EAAmBF,EAAc/D,OAErC+D,EAAc7D,KAAKyC,EACtB,CACJ,KAIEoB,EAAclE,KAAO,GAAG,CAC3B,MAAMsE,EAAWJ,EAAc3D,MAC/B,GAAiB,MAAb+D,EAGA,MAAM,IAAI3F,EAAqB,6CAF/BmF,EAAYzD,KAAKiE,EAGxB,CACJ,CAID,OAAOR,CACV,EAQL,MAAMS,UAAyBhC,EAI3B,WAAA1D,CAAY2D,GACRzD,MAAMyD,EACT,CAID,QAAAgC,GACI,MAAMC,EAAU3E,KAAK+D,YACfa,EAAQ,IAAI7E,EAClB,IAAI,IAAIc,EAAI,EAAGA,EAAI8D,EAAQxE,OAAQU,IAAK,CACpC,MAAMmC,EAAQ2B,EAAQ9D,GACtB,GAAGb,KAAK+C,WAAWC,GAAQ,CACvB,MAAMwB,EAAWxE,KAAKkD,YAAYF,GAClC,KAAG4B,EAAM1E,MAAQsE,EAASpC,OAMtB,MAAM,IAAIvD,EAAqB,gCAAgCmE,KANlC,CAC7B,MAAM6B,EAAOD,EAAMlE,KAAK8D,EAASpC,OAC3BxB,EAAS4D,EAASnC,KAAKwC,GAC7BD,EAAMrE,KAAKK,EACd,CAGJ,MAEGgE,EAAMrE,KAAKyC,EAClB,CACD,GAAkB,IAAf4B,EAAM1E,KAAY,CACjB,IAAIU,EAASQ,EAAUwD,EAAMnE,OAK7B,MAFqB,iBAAXG,IACNA,GA1PWI,EA0PgBJ,GAzP9BkE,MAAM,EAAG9D,EAAEb,OAAS,IA0PdS,CAEV,CAEG,MAAM,IAAI/B,EAAqB,+CAA+C+F,EAAM1E,QA/PhG,IAA2Bc,CAgQtB,EC/UL,MAAM9B,EAAOC,OAAOC,OAAO,CACvB2F,aAAc,kBACdC,qCAAsC,yCACtCC,sBAAuB,8BACvBC,6BAA8B,gCAC9BC,uBAAwB,yBACxBC,mBAAoB,yBAMxB,MAAMC,UAAwCvG,MAAQ,WAAAC,GAAeE,MAAM,kCAO3E,MAAMqG,EAIF,mBAAOC,CAAahE,GAAQ,MAAO,KAAKuC,KAAKvC,EAAQ,CACrD,aAAOiE,CAAOjE,GAAQ,MAAgB,MAATA,CAAe,CAC5C,cAAOkE,CAAQlE,GAAQ,MAAgB,MAATA,CAAe,CAC7C,kBAAOmE,CAAYnE,GAAQ,MAAgB,MAATA,CAAe,CACjD,mBAAOoE,CAAapE,GAAQ,MAAgB,MAATA,CAAe,CAClD,oBAAOqE,CAAcrE,GAAQ,MAAgB,MAATA,CAAe,CACnD,mBAAOsE,CAAatE,GAAQ,MAAgB,MAATA,CAAe,CAClD,oBAAOuE,CAAcvE,GAAQ,MAAgB,MAATA,CAAe,CACnD,wBAAOwE,CAAkBxE,GAAQ,MAAiB,MAATA,GAA2B,MAATA,GAA2B,MAATA,GAA2B,MAATA,CAAgB,CAC/G,8BAAOyE,CAAwBC,EAAW1E,GACtC,MAAiB,MAAd0E,EACiB,MAAT1E,EACW,MAAd0E,EACY,MAAT1E,EACW,MAAd0E,EACY,MAAT1E,EACW,MAAd0E,EACY,MAAT1E,OADN,CAER,CAKD,WAAAxC,CAAY2D,GACR1C,KAAK2C,YAAcD,EACnB1C,KAAKkG,OAAS,CACjB,CAID,gBAAAC,GAAqBnG,KAAKkG,OAAS,CAAI,CACvC,mBAAAE,CAAoBC,GAAe,CAKnC,IAAAC,GAAS,OAAOtG,KAAKkG,MAAS,CAC9B,OAAAK,GAAY,OAAOvG,KAAK2C,WAAc,CACtC,IAAA6D,CAAK7F,EAAI,GAAK,OAAOX,KAAKuG,UAAUvG,KAAKkG,OAASvF,EAAK,CACvD,WAAA8F,GAAgB,OAAOnB,EAAQC,aAAavF,KAAKwG,OAAU,CAC3D,IAAAE,CAAK/F,EAAE,GAAK,OAAOX,KAAKkG,QAAUvF,CAAI,CACtC,QAAAgG,CAASC,EAAS,GAAK,OAAQ5G,KAAKuG,UAAUpG,OAASH,KAAKkG,QAAWU,CAAS,CAKhF,eAAAC,GAAoB,OAAOvB,EAAQI,YAAY1F,KAAKwG,OAAU,CAC9D,gBAAAM,GAAqB,OAAOxB,EAAQK,aAAa3F,KAAKwG,OAAU,CAChE,WAAAO,GAAgB,OAAOzB,EAAQE,OAAOxF,KAAKwG,OAAU,CACrD,YAAAQ,GAAiB,OAAO1B,EAAQG,QAAQzF,KAAKwG,OAAU,CACvD,kBAAAS,GAAuB,OAAO3B,EAAQM,cAAc5F,KAAKwG,OAAO,CAChE,mBAAAU,CAAoBjB,GAAa,OAAOX,EAAQU,wBAAwBC,EAAWjG,KAAKwG,OAAU,CAClG,SAAAW,CAAUC,GACN,IAAIC,GAAS,EACb,MAAMC,EAASF,EAAIjH,OACnB,GAAGH,KAAK2G,SAASW,GAAS,CACtB,IAAIC,EAAgB,EACpB,IAAI,IAAI1G,EAAI,EAAGA,EAAIuG,EAAIjH,OAAQU,IACxBb,KAAKwG,KAAK3F,KAAOuG,EAAIvG,IACpB0G,IAERF,EAAUE,IAAkBD,CAC/B,CACD,OAAOD,CAEV,CAID,cAAAG,GACI,KAAOxH,KAAK2G,YAAc3G,KAAKyG,eAC3BzG,KAAK0G,MACZ,EAQL,MAAMe,UAAkBnC,EAKpB,WAAAvG,CAAY2D,EAAYgF,EAAU,IAC9BzI,MAAMyD,GAEN1C,KAAK2H,SAAWD,EAChB1H,KAAK4H,UAAY,KACjB5H,KAAK6H,QAAU,KACf7H,KAAK8H,gBAAkB,CAAEC,MAAO,CAAC,KAAMC,OAAQ,CAAC,MAChDhI,KAAKiI,mBAAqB,GAC1BjI,KAAKkI,kBAAoB,GACzBlI,KAAK2H,SAASQ,wBAA0D7H,IAArCN,KAAK2H,SAASQ,oBAC7CnI,KAAK2H,SAASQ,kBACrB,CACD,qBAAAC,GAA0B,OAAOpI,KAAK2H,SAASQ,kBAAqB,CAIpE,iBAAAE,CAAkBC,GAAO,MAAO,GAAGtI,KAAK4H,YAAYU,IAAMtI,KAAK6H,SAAY,CAC3E,cAAAU,GAAmB,OAAOvI,KAAKmH,UAAUnH,KAAK4H,UAAa,CAC3D,YAAAY,GACI,IAAIC,GAAQ,EAGZ,OAFsC,IAAnCzI,KAAKiI,mBAAmB9H,SACvBsI,EAAQzI,KAAKmH,UAAUnH,KAAK6H,UACzBY,CAEV,CAID,UAAAC,GACI,IAAIC,EACJ,MAAMC,EAAc5I,KAAK8H,gBAAgBC,MAAMc,QAAQ7I,KAAKwG,QAK5D,OAJqB,IAAlBoC,IACCD,EAAU3I,KAAK8H,gBAAgBE,OAAOY,IAGnCD,CACV,CAID,aAAAG,GACI,IAAIC,GAAiB,EACrB,GAAG/I,KAAKiI,mBAAmB9H,OAAS,EAAG,CACnC,MAAM6I,EAAchJ,KAAKiI,mBAAmBjI,KAAKiI,mBAAmB9H,OAAS,GAC1EH,KAAKwG,SAAWwC,IACfD,GAAiB,EACxB,CACD,OAAOA,CACV,CAID,kBAAAE,GAEI,GAAGjJ,KAAKoI,wBAAyB,CAC7B,MAAMc,EAAclJ,KAAK0I,kBACLpI,IAAhB4I,EACAlJ,KAAKiI,mBAAmB1H,KAAK2I,GACxBlJ,KAAK8I,iBACV9I,KAAKiI,mBAAmBxH,KAE/B,CACJ,CAID,UAAA0I,GAEI,IAAInG,EACAoG,GAAU,EAAMC,GAAM,EACtBC,GAAgB,EAAMC,GAAY,EACtC,KAAOvJ,KAAK2G,YACR,GAAI3G,KAAKuI,iBACLe,EAActJ,KAAKsG,OACnBtG,KAAK0G,KAAK1G,KAAK4H,UAAUzH,QACzBiJ,EAAQpJ,KAAKsG,WAEZ,KAAe,IAAV8C,GAAiBpJ,KAAKwI,eAAgB,CAC5Ca,EAAMrJ,KAAKsG,OACXiD,EAAYF,EAAOrJ,KAAK6H,QAAQ1H,OAGhC6C,EAAQhD,KAAKuG,UAAUzB,MAAMsE,EAAOC,GAEpCrJ,KAAK0G,KAAK1G,KAAK6H,QAAQ1H,QACvB,KACH,CAEGH,KAAKiJ,qBACLjJ,KAAK0G,MACR,CAEL,YAAiBpG,IAAV0C,EAAsB,CACzBwG,MAAOxJ,KAAKqI,kBAAkBrF,GAC9ByG,IAAKzG,EACL0G,YAAaJ,EACbK,UAAWJ,QACXjJ,CACP,CAKD,qBAAAsJ,GACI,OAAOC,EAAsBC,qBAAqB9J,KAAKuG,UAAWvG,KAAKkI,kBAC1E,EASL,MAAM6B,UAAwBtC,EAK1B,WAAA1I,CAAY2D,EAAYgF,EAAU,IAC9BzI,MAAMyD,EAAYgF,EACrB,CAID,GAAAsC,GAEIhK,KAAKmG,mBACL,IAAI8D,EAAiBjK,KAAKmJ,aAE1B,OADAnJ,KAAKoG,oBAAoB6D,QACC3J,IAAnB2J,CACV,EASL,MAAMJ,UAA8BpC,EAIhC,2BAAOqC,CAAqBpH,EAAYwH,GAIpC,IAAItJ,EAAS,GACTuJ,EAAY,EAEhB,IAAK,IAAItJ,EAAI,EAAGA,EAAIqJ,EAAiB/J,OAAQU,IAAK,CAC9C,MAAMuJ,YAAEA,EAAWV,YAAEA,EAAWC,UAAEA,GAAcO,EAAiBrJ,GAGjED,GAAU8B,EAAWoC,MAAMqF,EAAWT,GAGtC9I,GAAUwJ,EAGVD,EAAYR,CACf,CAKD,OAFA/I,GAAU8B,EAAWoC,MAAMqF,GAEpBvJ,CACV,CAKD,WAAA7B,CAAY2D,EAAY2H,EAAI3C,EAAU,CAAA,GAClCzI,MAAMyD,EAAYgF,GAClB1H,KAAKsK,IAAMD,CACd,CAID,iBAAAE,CAAkBN,GACd,MAAMrG,EAAQqG,EAAeT,MACvBlB,EAAM2B,EAAeR,IACrBe,EAASP,EAAeP,YAE9BO,EAAeG,YAAcpK,KAAKsK,IAAItK,KAAM4D,EAAO0E,EAAKkC,EAAQxK,KAAKuG,WACrEvG,KAAKkI,kBAAkB3H,KAAK0J,EAC/B,CAID,qBAAAL,GACI,OAAOC,EAAsBC,qBAAqB9J,KAAKuG,UAAWvG,KAAKkI,kBAC1E,CAID,OAAAuC,GACIzK,KAAKmG,mBACL,IAAI8D,EAAiBjK,KAAKmJ,aAC1B,UAAyB7I,IAAnB2J,GACFjK,KAAKuK,kBAAkBN,GACvBA,EAAiBjK,KAAKmJ,aAE1B,GAAGnJ,KAAKiI,mBAAmB9H,OAAS,EAChC,MAAM,IAAIrB,MAAM,6CAA6CkB,KAAKiI,mBAAmByC,KAAK,QAE9F,OADA1K,KAAKoG,oBAAoB6D,GAClBjK,KAAK4J,uBACf,EAOL,MAAMe,EACF,gBAAOC,CAAUC,GACb,IAAIjK,GAAS,EAGb,OAFW,OAANiK,GAA6B,iBAANA,GAAqC,mBAAXA,EAAEC,OACpDlK,GAAS,GACNA,CACV,CAID,WAAA7B,GACIiB,KAAK+K,UAAY,GACjB/K,KAAKgL,aAAe,GACpBhL,KAAKiL,WAAa,GAElBjL,KAAKkL,WAAa,CACrB,CAID,WAAAC,GAAgB,OAAOnL,KAAK+K,UAAU5K,OAAS,CAAI,CACnD,UAAAiL,GAAe,OAAOC,QAAQD,WAAWpL,KAAK+K,UAAa,CAI3D,qBAAMO,GACF,IAAIC,EACJ,GAAIvL,KAAKmL,cAAe,CACpBI,EAAc,CAACC,UAAW,EAAGC,UAAW,GACxC,MAAMC,QAAgB1L,KAAKoL,aAC3B,IAAK,IAAIvK,EAAI,EAAGA,EAAI6K,EAAQvL,OAAQU,IAAK,CACrC,MAAM8K,EAAa3L,KAAKgL,aAAanK,GAC/B+K,EAAUF,EAAQ7K,GACF,cAAnB+K,EAAQC,QACPN,EAAYI,GAAcC,EAAQpL,MAClC+K,EAAYC,aAEW,aAAnBI,EAAQC,SACZN,EAAYI,GAAc3L,KAAKiL,WAAWpK,GAC1C0K,EAAYE,YAEnB,CACJ,CACD,OAAOF,CACV,CAID,iBAAAO,GACI,MAAMxD,EAAO,GAAGtI,KAAKkL,6BAA6BlL,KAAKkL,aAEvD,OADAlL,KAAKkL,aACE5C,CACV,CAID,GAAAyD,CAAIC,EAAWC,GACX,IAAIC,EAOJ,OANGvB,EAAgBC,UAAUqB,KACzBjM,KAAKiL,WAAW1K,KAAKyL,GACrBhM,KAAK+K,UAAUxK,KAAK0L,GACpBC,EAAWlM,KAAK8L,oBAChB9L,KAAKgL,aAAazK,KAAK2L,IAEpBA,CACV,EAEL,MAAMC,EAAiBhN,OAAOC,OAAO,CACjCgN,mBAAmB,IAQvB,MAAMC,EACF,WAAAtN,CAAYuN,GACRtM,KAAKuM,WAAaD,CACrB,CACD,YAAAE,GAAiB,OAAOxM,KAAKuM,UAAa,CAC1C,GAAAE,CAAInE,GAAO,OAAOtI,KAAKuM,WAAWjE,EAAO,EAiC7C,MAAMoE,EAKF,WAAA3N,CAAY4N,EAAaC,EAAYlF,EAAU,CAAA,GAC3C1H,KAAK6M,aAAeF,EAEpB3M,KAAK8M,YAAeF,aAAsBP,EACtCO,EAAa,IAAIP,EAAiBO,GAEtC5M,KAAK2H,SAAWD,EAEhB1H,KAAK2H,SAASyE,uBAAwD9L,IAApCN,KAAK2H,SAASyE,kBAC5CD,EAAeC,kBAAoBpM,KAAK2H,SAASyE,kBAErDpM,KAAK2H,SAASoF,4BAC+BzM,IAAzCN,KAAK2H,SAASoF,uBAAuC/M,KAAK2H,SAASoF,uBAAyB,CAACC,EAAa1E,IAAiB0E,CAClI,CAID,oBAAAC,GAAyB,OAAOjN,KAAK2H,SAASyE,iBAAoB,CAClE,+BAAAc,GAAoC,OAAOlN,KAAK2H,SAASoF,sBAAyB,CAKlF,aAAAI,CAAc7E,GAAO,OAAOtI,KAAK8M,YAAYL,IAAInE,EAAO,CAIxD,gBAAM8E,CAAWT,EAAajF,GAC1B,IAAI2F,EACJ,MAAMC,EAAkB,IAAI3C,EAItBF,EAAU,IAAKZ,EAAsB8C,GACvC,CAACY,EAAQ3J,EAAO0E,EAAKkC,EAAQgD,KAEzB,IAAIC,EAAmB/F,EAAQyF,cAAc7E,EAAI9G,aACxBlB,IAArBmN,GAAmC/F,EAAQgG,6BAC3CD,EAAmBzN,KAAKkN,iCAALlN,CAAuC4D,EAAO0E,IAGrE,MAAMqD,EAAa2B,EAAgBvB,IAAInI,EAAO6J,GAU9C,YATkBnN,IAAfqL,EACC8B,EAAmBF,EAAOlF,kBAAkBsD,GACxC3L,KAAKiN,wBAA2BrJ,IAAU4J,EAC9CH,EAAgBI,EAES,OAArBA,GAA2D,iBAArBA,IACtCA,EAAmBE,KAAKC,UAAUH,IAGnCA,CAAgB,GAE5BzN,KAAK2H,UAAW8C,UACnB,IAAIoD,EACJ,MAAMC,QAA2BR,EAAgBhC,kBASjD,YAR0BhL,IAAvBwN,IACCD,QAAmB7N,KAAKoN,WAAW3C,EAAS,CACxC0C,cAAgB7E,GAASwF,EAAmBxF,GAC5CoF,yBAA0B,KAAM,KAIxCG,EAAaA,SAAiCvN,IAAlB+M,EAA8BA,EAAgB5C,GACnEoD,CACV,CAID,kBAAME,GACF,IAAIF,EAAa7N,KAAK6M,aAStB,MAP0B,iBAAfgB,IACPA,QAAmB7N,KAAKoN,WAAWS,EAAY,CAC3CV,cAAgB7E,GAAStI,KAAKmN,cAAc7E,GAC5CoF,yBAA0B,KAAM,KAIjCG,CACV,EAKA,MAACG,EAAsB7O,OAAOC,OAAO,CACtC6O,YAAaC,OAAO,eACpBC,cAAeD,OAAO,iBACtBE,aAAcF,OAAO,gBACrBG,cAAe,SAAUC,GACrB,IAAIC,GAAU,EAKd,OAJGD,IACCC,EAAWD,IAAWN,EAAoBC,aACrCK,IAAWN,EAAoBG,eAC/BG,IAAWN,EAAoBI,cACjCG,CACV,IAOL,MAAMC,EACF,WAAAzP,GACIiB,KAAKyO,QAAUT,EAAoBC,WACtC,CAKD,SAAAS,GAAc,OAAO1O,KAAKyO,OAAU,CACpC,SAAAE,CAAUC,GACN,IAAIC,GAAY,EAOhB,OANGb,EAAoBK,cAAcO,KACjC5O,KAAKyO,QAAUG,EAEfC,GAAY,GAGTA,CACV,EAOL,MAAMC,EAAc3P,OAAOC,OAAO,CAC9B2P,WAAY,EACZC,qBAAsB,EACtBC,2BAA4B,EAC5BC,aAAc,EACdC,iCAAkC,IAGtC,MAAMC,EACF,eAAOC,CAAS/G,EAAKgH,GAAO,OAAyC,IAAlChH,EAAIiH,OAAO,IAAI1M,OAAOyM,GAAe,CAIxE,0BAAOE,CAAoBC,GACvB,SAAQA,GAA4C,iBAAnBA,IAC5B,IAAK1F,EAAgB0F,GAAiBzF,KAC9C,CAID,qBAAO0F,CAAeC,GAClB,MAAMC,EAAM,IAAID,GAChB,IAAK,MAAOrH,EAAK9H,KAAUrB,OAAO0Q,QAAQF,GAElCP,EAAuBI,oBAAoBhP,WACpCoP,EAAItH,GAEnB,OAAOsH,CACV,CACD,gBAAOE,CAAUC,EAAQC,GAClB9L,MAAMC,QAAQ4L,IAAW7L,MAAMC,QAAS,GACvC4L,EAAOE,OAAO,EAAGF,EAAO5P,UAAW6P,GAGnC7Q,OAAO+Q,OAAOH,EAAQC,EAE7B,CAID,wBAAQG,CAAkBP,EAAKpN,EAAO,GAAI4N,EAAM,IAC5C,IAAIC,GAAS,EACb,GAAGT,EAAK,CAGe,IAAhBQ,EAAKjQ,SAAgBiQ,EAAK7P,KAAKqP,GAAMS,GAAS,GAGjD,MAAMC,EAAUpM,MAAMC,QAAQyL,EAAIW,iBAAmBX,EAAIW,gBAAkBpR,OAAOqD,KAAKoN,GACvF,IAAI,IAAI/O,EAAI,EAAGA,EAAIyP,EAAQnQ,OAAQU,IAAK,CACpC,MAAMyH,EAAMgI,EAAQzP,GAAUL,EAAQoP,EAAItH,GAE1C,GAAsB,iBAAV9H,GAAkC,OAAVA,EAC5B0D,MAAMC,QAAQ3D,UACR,CAACoP,EAAKtH,EAAK9H,EAAOgC,EAAM4N,IAClC5N,EAAKjC,KAAK+H,GAAM8H,EAAK7P,KAAKC,SACnB4O,EAAuBe,kBAAkB3P,EAAOgC,EAAM4N,GAC7D5N,EAAK/B,MAAQ2P,EAAK3P,WAEjB,GAAqB,iBAAVD,EAAoB,MAC1B,CAACoP,EAAKtH,EAAK9H,EAAMgB,OAAQgB,EAAM4N,GACrC,MAAMI,EAAQ,mBACSlI,EAAI1E,MAAM4M,KAE7BC,QAAQC,IAAId,EAAItH,WACTsH,EAAItH,GAElB,CACJ,CAGE+H,GAAUD,EAAK3P,KACrB,CACJ,CAID,4BAAOkQ,CAAsBnO,EAAM8F,GAAO,OAAO9F,EAAKrC,OAAS,EAAIqC,EAAKkI,KAAK,KAAO,IAAMpC,EAAMA,CAAM,CACtG,uBAAOsI,CAAiBC,GAAmB,OAAOA,EAAgBC,MAAM,IAAO,CAC/E,UAAOC,CAAInB,GAAO,OAAOjC,KAAKqD,MAAMrD,KAAKC,UAAUgC,GAAQ,CAK3D,WAAA7Q,CAAY6Q,EAAKtD,EAAW5E,EAAU,CAAA,GAClC1H,KAAK2H,SAAWD,EAChB1H,KAAK2H,SAASsJ,aAAoC3Q,IAA1BN,KAAK2H,SAASsJ,SAAwBjR,KAAK2H,SAASsJ,QAE5EjR,KAAKkR,KAAOlR,KAAKmR,aAAe/B,EAAuB2B,IAAInB,GAAOA,EAClE5P,KAAKuM,WAAaD,EAElBtM,KAAK2H,SAASyJ,iBAAmBpD,EAAoBK,cAAcrO,KAAK2H,SAASyJ,kBAC7EpR,KAAK2H,SAASyJ,iBAAmBpD,EAAoBC,YAEzDjO,KAAK2H,SAAS0E,sBAAsD/L,IAAnCN,KAAK2H,SAAS0E,iBAC3CrM,KAAK2H,SAAS0E,iBAAmBA,EAErCrM,KAAKqR,OAAS,CACjB,CAID,MAAAC,GAAW,OAAOtR,KAAKkR,IAAO,CAC9B,UAAAK,GAAe,OAAOvR,KAAK2H,QAAW,CACtC,mBAAA6J,GAAwB,OAAOxR,KAAK2H,SAASyJ,gBAAmB,CAChE,yBAAAK,GAA8B,OAAOzR,KAAK2H,SAAS0E,gBAAmB,CACtE,iCAAAqF,GAAsC,OAAO1R,KAAK2H,SAASgK,0BAA4B,GAAM,CAC7F,UAAAR,GAAe,OAAOnR,KAAK2H,SAASsJ,OAAU,CAO9C,qBAAAW,CAAsBC,EAAiB7E,EAAa1E,EAAKwJ,EAA8BC,GACnF,IAAIC,EAAWhF,EACf,GAAG8E,EAA8B,CAE7B,MAAMG,EAAgBH,EAA6B9E,EAAa1E,GAC5DyJ,EAAWE,KACXD,EAAWC,EAClB,MAEGF,EAAW/R,KAAKwR,uBAEpB,OAAOQ,CAEV,CACD,kBAAAE,CAAmBC,EAAkBxC,EAAUrH,EAAK9H,GAAS,OAAO,IAAO,CAI3E,sBAAM4R,CAAiBD,EAAkBxC,EAAUrH,EAAK9H,GACpD,IAAII,EAAS,CAAEyR,cAAe,EAAG/J,IAAKA,GACtC,MAAMgK,EAAmBtS,KAAKkS,mBAAmBC,EAAkBxC,EAAUrH,EAAK9H,GAIlF,OAHG8R,IACC1R,QAAe0R,EAAgBC,eAE5B3R,CAEV,CAID,sBAAM4R,CAAiBL,EAAkBxC,EAAUrH,EAAK9H,GACpD,IAAI6R,EAAgB,EAChBL,EAAWxR,EACf,MAAMsR,EAA+B9R,KAAK2H,SAASoF,uBACnD,IAAI,IAAIlM,EAAI,EAAGA,EAAIb,KAAKqR,OAAQxQ,IAAK,CAYjC,MAAM4R,EAAU,IAAIjE,EAEdkE,EAAqB,IAAIhG,EAAmBsF,EAAUG,EAAkB,CAC1EhK,oBAAoB,KAASnI,KAAK2H,SAClCoF,uBAAyB,CAACC,EAAa1E,IAI5BtI,KAAK4R,sBAAsBO,EAAkBnF,EAAa1E,EAAKwJ,GACjElD,GAAmB6D,EAAQ9D,UAAUC,OAIlD,IAAInE,QAAgBiI,EAAmB3E,eACvC,GAAG0E,EAAQ/D,cAAgBV,EAAoBC,YAAa,CACxD,GAAI+D,IAAYvH,EAKZ,MAJAkF,EAASrH,GAAOmC,EAChB4H,IACAL,EAAWvH,CAGlB,KACI,IAAGgI,EAAQ/D,cAAgBV,EAAoBG,cAAe,QACxDwB,EAASrH,GAChB,KACH,CACI,GAAGmK,EAAQ/D,cAAgBV,EAAoBI,aAChD,MAAM,IAAI/I,CACb,CACJ,CAED,OAAOgN,CACV,CAID,WAAAM,CAAYrK,GACR,IAAIgH,EAAMR,EAAYC,WAQtB,OAPGK,EAAuBC,SAAS/G,EAAKpJ,EAAK8F,sCACzCsK,EAAMR,EAAYK,iCACdC,EAAuBC,SAAS/G,EAAKpJ,EAAK+F,uBAC9CqK,EAAMR,EAAYE,qBACdI,EAAuBC,SAAS/G,EAAKpJ,EAAKgG,gCAC9CoK,EAAMR,EAAYG,4BAEfK,CACV,CAID,cAAAsD,CAAeC,GACXA,EAAcxO,SAAUwM,IACpB,MAAMiC,EAAO1D,EAAuBwB,iBAAiBC,GACrD,IAAIkC,EAAQ/S,KAAKkR,KACb8B,EAAW,KACXC,EAAY,GACZC,EAAY,KACZC,EAAW,GACf,IAAI,IAAItS,EAAI,EAAGA,EAAIiS,EAAK3S,OAAQU,IACzBA,IAAMiS,EAAK3S,OAAS,IACnB8S,EAAYE,EACZH,EAAWE,GAEfC,EAAWL,EAAKjS,GAChBqS,EAAYH,EACZA,EAAQA,EAAMI,GAGfD,GAAkC,iBAAdA,GAChBC,UACQD,EAAUC,GAEtBH,GAAgC,iBAAbA,GACfC,GAAyD,IAA5C9T,OAAOqD,KAAKwQ,EAASC,IAAY9S,SAC1C+D,MAAMC,QAAQ6O,GACbA,EAAS/C,OAAOgD,EAAW,UAEpBD,EAASC,GAG3B,GAGR,CACD,eAAAG,CAAgBC,EAAc7Q,GAC1B,IAAI8Q,EAAatT,KAAKkR,KAClBqC,EAAc,GACfrP,MAAMC,QAAQmP,IACTC,EAAYhT,KAAK+S,GACzB,IAAI,IAAIzS,EAAI,EAAGA,EAAI2B,EAAKrC,OAAQU,IAAK,CAEjCyS,EAAaA,EADD9Q,EAAK3B,IAEdqD,MAAMC,QAAQmP,GACbC,EAAYhT,KAAK+S,GAEjBC,EAAc,EAErB,CACD,IAAI,IAAI1S,EAAI0S,EAAYpT,OAAS,EAAGU,GAAK,EAAGA,IAAK,CAC7C,MAAM2S,EAAaD,EAAY1S,GAC3BwS,EAAarJ,IAAIwJ,IACjBH,EAAatH,IAAIyH,EACxB,CACJ,CAKD,sBAAAC,CAAuBnH,GAAa,OAAO,IAAKtM,KAAKyR,4BAAV,CAAuCnF,EAAWtM,KAAK0R,oCAAuC,CAIzI,iBAAMa,GACF,IAAIF,EAAgB,EAEpB,MAAMQ,EAAgB,GAEhBa,EAAwB,IAAIC,IAC5BN,EAAe,IAAIM,IACzB,IAAK,MAAOhE,EAAUrH,EAAK9H,EAAOgC,EAAM4N,KAAShB,EAAuBe,kBAAkBnQ,KAAKkR,MAAO,CAIlG,MAAMiB,EACFnS,KAAKyT,uBAAuB,IAAKzT,KAAKuM,cAAe6C,EAAuBM,eAAeC,KAEzFiE,QAAyB5T,KAAKoS,iBAAiBD,EAAkBxC,EAAUrH,EAAK9H,GACtF6R,GAAiBuB,EAAiBvB,cAClC,MAAM/C,EAAMtP,KAAK2S,YAAYiB,EAAiBtL,KAC9C,GAAIgH,IAAQR,EAAYC,YACfO,IAAQR,EAAYE,sBACpBM,IAAQR,EAAYG,2BAIzB,GAFAoD,SAAuBrS,KAAKwS,iBAAiBL,EAAkBxC,EAAUrH,EAAK9H,GAE1E8O,IAAQR,EAAYE,qBAAsB,CAC1C,MAAM6E,EAAelE,EAASrH,GACD,iBAAjBuL,GAAgD,OAAjBA,IACvC1U,OAAO+Q,OAAOP,EAAUkE,UACjBlE,EAASrH,GAEvB,MACI,GAAGgH,IAAQR,EAAYG,2BAA4B,CAGpD,MAAMiE,EAAY9C,EAAKjQ,OAAS,EAAIiQ,EAAKA,EAAKjQ,OAAS,GAAK,KACtD8S,EAAYzQ,EAAKrC,OAAS,EAAIqC,EAAKA,EAAKrC,OAAS,GAAK,GAE5D,IAAG+S,IAAaD,EA6BZ,MAAM,IAAInU,MAAM,6BA7BO,CAEvB,MAAM+U,EAAelE,EAASrH,GAC9B,QAAqBhI,IAAjBuT,EAA4B,CAIDH,EAAsB1J,IAAIkJ,EAAUD,KACtC/O,MAAMC,QAAQ0P,GACnCX,EAAUD,GAAW1S,QAAQsT,GAE1B3P,MAAMC,QAAQ+O,IACbA,EAAUD,GAAaY,EACpB3P,MAAMC,QAAQ0P,IACbH,EAAsB3H,IAAImH,EAAUD,MAGxC7D,EAAuBU,UAAUoD,EAAWW,GAC5ChB,EAActS,KAAK6O,EAAuBuB,sBAAsBnO,EAAM8F,KAI3EpE,MAAMC,QAAQ+O,IACblT,KAAKoT,gBAAgBC,EAAc7Q,EAG1C,CACJ,CAGJ,MACOoR,EAAiBvB,cAAgB,IACrC1C,EAASiE,EAAiBtL,KAAOqH,EAASrH,UACnCqH,EAASrH,SAIhBgH,IAAQR,EAAYK,kCACxB0D,EAActS,KAAK6O,EAAuBuB,sBAAsBnO,EAAM8F,GAE7E,CACD,IAAI,MAAMkL,KAAcH,EACnBjE,EAAuBU,UAAU0D,EAAYA,EAAWM,QAI7D,OAFA9T,KAAK4S,eAAeC,GAEb,CAAEjD,IAAK5P,KAAKsR,SAAUe,cAAeA,EAC/C,EASL,MAAM0B,UAA2BzO,EAI7B,WAAAvG,CAAY2D,EAAYgF,GACpBzI,MAAMyD,GACN1C,KAAK2H,SAAWD,EAChB1H,KAAK2H,SAASqM,2BAAgE1T,IAAxCN,KAAK2H,SAASqM,uBAChDhU,KAAK2H,SAASqM,qBACrB,CACD,wBAAAC,GAA6B,OAAOjU,KAAK2H,SAASqM,qBAAwB,CAO1E,gBAAAE,GACI,IAAIjO,EAAYjG,KAAKwG,OAGrB,GAAGlB,EAAQS,kBAAkBE,GAAY,CACrC,IAAIkO,EAAW,GAIf,IAHAA,EAAS5T,KAAK0F,GAGRjG,KAAK2G,YAAcwN,EAAShU,OAAS,GAOvC,IAJA8F,EAAYkO,EAASA,EAAShU,OAAS,GACvCH,KAAK0G,OAGE1G,KAAK2G,YAAY,CAGpB,GAAG3G,KAAKkH,oBAAoBjB,GAAY,CACpCkO,EAAS1T,MACT,KACH,CACI,CAGD,MAAM2T,EAAepU,KAAKwG,OAC1B,GAAIlB,EAAQS,kBAAkBqO,GAAe,CACzCnO,EAAYmO,EACZD,EAAS5T,KAAK6T,GACd,KACH,CACJ,CAGDpU,KAAK0G,MACR,CAGL,GAAGyN,EAAShU,OAAS,EACjB,MAAM,IAAIrB,MAAM,mDAAmDqV,EAASE,KAAKC,GAAW,IAAIA,OAAW5J,KAAK,QACvH,CACJ,CAID,mBAAA6J,GACI,KAAOvU,KAAK2G,aAAe3G,KAAKyG,gBAAkBzG,KAAK+G,gBAAkB/G,KAAKgH,iBAAmBhH,KAAKiH,sBAClGjH,KAAK0G,MAEZ,CAID,SAAA8N,GAGI,IAAIxR,EACJ,GAHAhD,KAAKwH,iBAGAxH,KAAK+G,eAAkB/G,KAAKgH,eAe7B,MAAM,IAAIlI,MAAM,6DAf6B,CAG7C,MAAMsK,EAAQpJ,KAAKsG,OAEnBtG,KAAKkU,mBACLlU,KAAKuU,sBAGL,MAAMlL,EAAMrJ,KAAKsG,OAGjBtD,EAAQhD,KAAKuG,UAAUzB,MAAMsE,EAAOC,EACvC,CAID,OAAOrG,CACV,CAID,cAAAyR,GACI,IAAI5P,EAAO,GACX,KAAO7E,KAAK2G,aAAe3G,KAAKgH,gBAC5BnC,EAAKtE,KAAKP,KAAK0U,mBACf1U,KAAKwH,iBAEDxH,KAAKiH,sBACLjH,KAAK0G,OAEb,OAAO7B,CACV,CAID,eAAA6P,GACI,IAAI1R,EAAQhD,KAAKwU,YAEjB,GAAI,eAAe1Q,KAAKd,SAGnB,GAAG,SAASc,KAAKd,SAGjB,GAAI,oBAAoBc,KAAKd,GAAQ,CAItC,GAHAhD,KAAKwH,iBAGDxH,KAAK+G,cAAe,CAEpB,IAAI4N,EAAW3R,EAEfhD,KAAK0G,OAGL,IAAI7B,EAAO7E,KAAKyU,iBAIhB,GADAzU,KAAKwH,kBACAxH,KAAKgH,eACN,MAAM,IAAIlI,MAAM,kDAAkD6V,KAGtE,OAFA3U,KAAK0G,OAEE,CACHtD,KAAM,eACNwR,KAAMD,EACNE,UAAWhQ,EAElB,CACI,GAAG7E,KAAKiU,2BACT,MAAM,IAAInV,MAAM,kDAAkDkE,KAKnEA,EAAQ,IAAIA,IAElB,CAED,MAAO,CACLI,KAAM,UACN5C,MAAOwC,EAEZ,CAKD,KAAAgO,GACIhR,KAAKmG,mBAGL,MAAM2O,EAAU9U,KAAK0U,kBAIrB,OAFA1U,KAAKoG,oBAAoB0O,GAElBA,CACV,EASL,MAAMC,UAA0BhB,EAI5B,iBAAOiB,CAAWxU,GACd,IAAII,EACJ,GAAqB,iBAAVJ,GAAkC,KAAVA,EAAe,CAC9C,MAAMyU,EAAMC,OAAO1U,GACdU,MAAM+T,KACPrU,EAASqU,EAChB,CAED,OAAOrU,CACV,CAID,oBAAOuU,CAAc3U,GACjB,IAAII,EACJ,MAAMwU,EAAU5U,EAAMoD,MAAM,kBAG5B,OAFGM,MAAMC,QAAQiR,IAAgC,IAAnBA,EAAQjV,SAClCS,EAASwU,EAAQ,IACdxU,CACV,CAID,kBAAOyU,CAAY7U,GACf,IAAII,EACJ,MAAMwU,EAAU5U,EAAMoD,MAAM,kBAG5B,OAFGM,MAAMC,QAAQiR,IAAgC,IAAnBA,EAAQjV,SAClCS,EAAwB,SAAfwU,EAAQ,IACdxU,CACV,CAID,kBAAO0U,CAAY9U,GACf,IAAII,EACJ,MAAMwU,EAAU5U,EAAMoD,MAAM,YAG5B,OAFGM,MAAMC,QAAQiR,IAAgC,IAAnBA,EAAQjV,SAClCS,EAAwB,SAAfwU,EAAQ,GAAgB,UAAO9U,GACrCM,CACV,CAID,iBAAO2U,CAAW/U,GACd,IAAII,EACJ,IACIA,EAAS+M,KAAKqD,MAAMxQ,EACvB,CACD,MAAMa,GAAM,MAAM,IAAIvC,MAAM,yCAA4C,CACxE,OAAO8B,CACV,CAID,uBAAO4U,CAAiBhV,GACpB,IAAII,EAASJ,EACb,MAAMyU,EAAMF,EAAkBC,WAAWxU,GACzC,QAAWF,IAAR2U,EACCrU,EAASqU,MAEb,CACI,MAAMQ,EAAMV,EAAkBI,cAAc3U,GAC5C,QAAWF,IAARmV,EACC7U,EAAS6U,MAEb,CACI,MAAMC,EAAOX,EAAkBM,YAAY7U,GAC3C,QAAYF,IAAToV,EACC9U,EAAS8U,MAEb,CACI,MAAMC,EAAYZ,EAAkBO,YAAY9U,GAChD,QAAiBF,IAAdqV,EACC/U,EAAS+U,OAGT,IACI,MAAM/F,EAAMmF,EAAkBQ,WAAW/U,QAC7BF,IAARsP,IACAhP,EAASgP,EAChB,CACD,MAAMvO,GACF,GAAoB,iBAAVb,EACN,OAAOA,EAEP,MAAM,IAAI1B,MAAM,mCACvB,CAER,CACJ,CACJ,CACD,OAAO8B,CACV,CAID,2BAAOgV,CAAqBrI,EAAQuH,EAAQe,GAGxC,GAAoB,YAAhBf,EAAO1R,KACP,OAAO2R,EAAkBS,iBAAiBV,EAAOtU,OAChD,GAAoB,iBAAhBsU,EAAO1R,KAAyB,CACrC,MAAM0S,EAAOD,EAAQf,EAAOF,MAC5B,GAAoB,mBAATkB,EACP,MAAM,IAAIhX,MAAM,YAAYgW,EAAOF,sCAGvC,MAAM/P,EAAOiQ,EAAOD,UAAUR,KAAI0B,GAAOhB,EAAkBa,qBAAqBrI,EAAQwI,EAAKF,KAG7F,OAAOC,EAAKvI,KAAW1I,EACnC,CACY,MAAM,IAAI/F,MAAM,wBAEvB,CAKD,WAAAC,CAAYiX,EAAQtT,EAAYmP,EAAiBoE,EAAUvO,EAAU,IACjEzI,MAAMyD,EAAYgF,GAClB1H,KAAKkW,QAAUF,EACfhW,KAAKmW,iBAAmBtE,EACxB7R,KAAKoW,UAAYH,EACjBjW,KAAKqW,QAAU,IAClB,CACD,SAAAC,GAAc,OAAOtW,KAAKkW,OAAU,CACpC,kBAAAK,GAAuB,OAAOvW,KAAKmW,gBAAmB,CAKtD,KAAAnF,GACIhR,KAAKqW,QAAUpX,MAAM+R,QAErB,OADoB+D,EAAkBa,qBAAqB5V,KAAMA,KAAKqW,QAASrW,KAAKoW,UAEvF,EAaL,MAAMI,UAA2BpH,EAC7B,sBAAOqH,CAAgBjW,GACnB,IAAII,EAASJ,EAYb,MAXqB,iBAAVA,GAAyC,iBAAVA,GAAwC,kBAAVA,GAA0C,iBAAVA,EACpGI,EAASJ,EAAMkW,WACD,OAAVlW,EACJI,EAAS,YACKN,IAAVE,EACJI,OAASN,EACL4D,MAAMC,QAAQ3D,GAClBI,EAAS+M,KAAKC,UAAUpN,GAExBiQ,QAAQkG,MAAM,uCAEX/V,CACV,CAED,wBAAOgW,CAAkBlU,GAErB,OADU,IAAI+B,EAAiB/B,GACtBgC,UACZ,CAID,4BAAOmS,CAAsBnU,GACzB,IAAI9B,EAAS,GACb,GAAG8B,EAAY,CACX,MACMkB,EADO,IAAIf,OAAO3D,EAAK6F,cACV+R,KAAKpU,GACrBwB,MAAMC,QAAQP,IAA4B,IAAjBA,EAAMzD,SAC9BS,EAASgD,EAAM,GACtB,CAED,OAAOhD,CACV,CAID,WAAA7B,CAAY6Q,EAAKtD,EAAWyK,EAAerP,EAAU,CAAA,GACjDzI,MAAM2Q,EAAKtD,EAAW5E,GACtB1H,KAAKgX,eAAiBD,GAAgC,CAAA,EACtD/W,KAAKiX,iBAAmB,CACpB,IAAK,CAAC1J,EAAQ7K,IAAe8T,EAAmBI,kBAAkBlU,GAClEwU,IAAO,CAAC3J,EAAQ7K,IAAe8T,EAAmBI,kBAAkBlU,GACpEyU,EAAK,CAAC5J,EAAQ/M,IAAUgW,EAAmBC,gBAAgBjW,GAElE,CAID,kBAAA0R,CAAmBC,EAAkBxC,EAAUrH,EAAK9H,GAChD,OAAO,IAAI4W,EAAgB9O,EAAK6J,EAAkB,CAAE,EAAE,CAACkF,SAAU1H,GACpE,CAID,qBAAAiC,CAAsBC,EAAiB7E,EAAa1E,EAAKwJ,EAA8BC,GACnF,MAAMuF,EAAqBd,EAAmBK,sBAAsBvO,GACpE,GAAGtI,KAAKgX,gBAAkBM,EAAoB,CAG1C,OAFkB,IAAIvC,EAAkB/U,KAAMsX,EAAoBzF,EAC9D,IAAI7R,KAAKgX,kBAAmBhX,KAAKiX,mBACpBjG,OACpB,CAEG,OAAO/R,MAAM2S,sBAAsBC,EAAiB7E,EAAa1E,EAAKwJ,EAA8BC,EAE3G,EAGL,MAAMwF,EACF,6BAAOC,CAAuB5T,GAAS,OAAOM,MAAMC,QAAQP,IAA4B,IAAjBA,EAAMzD,MAAgB,CAC7F,WAAApB,CAAYuJ,EAAKqH,GACb3P,KAAKyX,KAAOnP,EACZtI,KAAK0X,UAAY/H,CACpB,CAUD,eAAAgI,CAAgBrP,EAAKsP,EAAkBC,EAASC,GAAU,GACtD,IAAIxI,EAAM,GACNyI,EAAU,GAEd,MAAMC,EAAW1P,EAAI2P,YAAY,KAC3BC,EAAaN,EAAiB/O,QAAQ,KAC5C,GAAImP,IAAaJ,EAAiBzX,OAAS,IAAsB,IAAf+X,EAAoB,CAElE,MAAMxV,EAAa4F,EAAIxD,MAAMoT,EAAa,EAAGF,GAE7C1P,EAAM,WADgBwP,EAAU,KAAKpV,KAAgBA,UAErDqV,EAAU7Y,EAAKiG,uBACfmK,EAAMuI,CACT,CACD,MAAO,CAAEM,QAASJ,EAASK,IAAK9I,EAAK7F,IAAKnB,EAC7C,CACD,0BAAA+P,CAA2B/P,EAAKsP,EAAkBC,GAC9C,IAAIjX,EAAS,KAEb,IAAI,MAAO0X,EAAY9X,KAAUrB,OAAO0Q,QAAQ7P,KAAK0X,WAAY,CAC7D,MAAMa,EAAUD,EAAW1U,MAAM,IAAIf,OAAO3D,EAAKiG,uBAAwB,MACzE,GAAGoS,EAAuBC,uBAAuBe,GAAU,CACvD3X,EAASZ,KAAK2X,gBAAgBW,EAAYC,EAAQ,GAAIA,EAAQ,IAAI,GAClE,KACH,CACJ,CACD,OAAkB,OAAX3X,EAAkBA,EAAS,CAAEuX,QAASjZ,EAAKkG,mBAAoBgT,IAAKP,EAASpO,IAAK,QAE5F,CACD,aAAA+O,CAAclQ,EAAKsP,EAAkBC,GACjC,MAAMjX,EAASZ,KAAKqY,2BAA2B/P,EAAKsP,EAAkBC,GAChEvI,EAAM1O,EAASA,EAAOwX,IAAM,GAC5BK,EAAS7X,EAASA,EAAO6I,IAAMnB,EACrC,MAAO,CAAE6P,QAASjZ,EAAKkG,mBAAoBgT,IAAK9I,EAAK7F,IAAKgP,EAC7D,CACD,SAAAC,GACI,MAAMpQ,EAAMtI,KAAKyX,KAAKjW,OACtB,IAAIZ,EAAS,CAAEuX,QAAS,GAAIC,IAAK,GAAI3O,IAAKnB,GAC1C,MAAMiQ,EAAUjQ,EAAI1E,MAAM,IAAIf,OAAO3D,EAAKiG,uBAAwB,MAClE,GAAGoS,EAAuBC,uBAAuBe,GAC7C3X,EAASZ,KAAK2X,gBAAgBrP,EAAKiQ,EAAQ,GAAIA,EAAQ,QACtD,CACD,MAAMI,EAAYrQ,EAAI1E,MAAM,IAAIf,OAAO3D,EAAKkG,mBAAoB,MAC7DmS,EAAuBC,uBAAuBmB,KAC7C/X,EAASZ,KAAKwY,cAAclQ,EAAKqQ,EAAU,GAAIA,EAAU,IAChE,CAED,OAAO/X,CACV,EAcL,MAAMwW,UAAwBZ,EAK1B,WAAAzX,CAAYuJ,EAAKgE,EAAWyK,EAAerP,EAAU,CAAA,GAEjD,MACMkR,EADyB,IAAIrB,EAAuBjP,EAAKZ,EAAQ2P,UAC1BqB,YAC7CzZ,MAAM,CAACwK,IAAKmP,EAAcnP,KAAM6C,EAAUE,eAAgBuK,EAAerP,GAEzE1H,KAAK6Y,SAAWD,EAAcT,QAC9BnY,KAAK8Y,KAAOF,EAAcR,IAE1BpY,KAAK+Y,aAAezQ,CACvB,CACD,WAAA0Q,GAAgB,OAAOhZ,KAAKuR,aAAa8F,QAAW,CAIpD,kBAAAnF,CAAmBC,EAAkBxC,EAAUrH,EAAK9H,GAAS,OAAO,IAAO,CAO3E,iBAAM+R,GACF,MAAM0G,QAAgBha,MAAMsT,cAE5B,IAAI2G,EAYJ,OALIA,EADDlZ,KAAK8Y,KACW,GAAG9Y,KAAK8Y,OAAOG,EAAQrJ,IAAInG,MAE3BwP,EAAQrJ,IAAInG,IAGxB,CAAE4I,cAAe4G,EAAQ5G,cAAe/J,IAAK4Q,EACvD,+IAthCL,cAAuC7M,EACnC,WAAAtN,CAAYuN,EAAW6M,EAAe,KAClCla,MAAMqN,GACNtM,KAAKoZ,cAAgBD,CACxB,CACD,GAAA1M,CAAI4M,GACC,SAASC,EAAUC,EAAGC,EAAK3Y,GACxB,MAAMyH,EAAMkR,EAAI1U,MAAM,EAAGjE,GAAM,EAAG2Y,EAAIrZ,QACtC,OAAQqZ,EAAWD,EAAEjR,GAAPiR,CACjB,CAID,IACI,OAAOF,EAAEvI,MAAM9Q,KAAKoZ,eAAeK,QAJvC,SAAmBF,EAAGC,GAClB,OAAQA,EAAUA,EAAI1I,MAAM,KAAK2I,OAAOH,EAAWC,GAArCA,CACjB,GAEwDvZ,KAAKwM,eAC7D,CACD,MAAMkN,GAAO,MAAmB,CACnC"}